/*! \page Tutorials Tutorials


  The following provides a several tutorials to help in getting started with the core Helios system and associated plug-ins. Programs associated with the tutorials can be found in the "samples" directory. Assuming that you have the necessary dependent software installed (see \ref DependentSoftware), the samples/tutorials can be built by changing into the "build" subdirectory for the tutorial, then running the command "cmake .." followed by "make". This should generate an executable file with the same name as the tutorial directory.

  \section ContextTuts Context

  \subsection ContextBasicsTut Context Basics

  - \subpage context_selftest_tutorial "Tutorial 0: Context Self-Test"
  - \subpage context_vectors_tutorial "Tutorial 1: Helios Vector Types"
  - \subpage context_primitives_tutorial "Tutorial 2: Working with Context Geometry"
  - \subpage context_timeseries_tutorial "Tutorial 3: Data Timeseries"
  - Tutorial 4: File I/O

  \subsection PrimDataTut Working with Context Data
  - \subpage context_primdata_tutorial "Tutorial 5: Primitive Data"
  - \subpage context_globaldata_tutorial "Tutorial 6: Global Data"

  \section VisualizerTuts Visualizer Plug-In
  - \subpage visualizer_basics_tutorial "Tutorial 7: Visualizer Basics"
  - \subpage visualizer_pdata_tutorial "Tutorial 8: Visualizing Variable and Primitive Data"
  - Tutorial 9: Customizing_tutorial %Visualizer Configuration

  \section RadiationTuts Radiation Model Plug-In
  - \subpage radiation_basics_tutorial "Tutorial 10: Radiation model basics - tree light interception"
  - \subpage radiation_BeersLaw_tutorial "Tutorial 11: Light interception and fraction of sunlit/shaded leaf area for a homogeneous canopy"

  \section WUETuts Canopy Water-Use Efficiency
    - \subpage canopy_WUE_tutorial "Tutorial 12: Canopy water-use efficiency - integrates many plug-ins, including radiation, energy balance, stomatal conductance, photosynthesis, etc.

*/

##################### TUTORIAL 0 #####################

/*! \page context_selftest_tutorial Tutorial 0: Context Self-Test Tutorial

  This tutorial illustrates a very simple example of how to declare the Helios context, and run its self-test function.  The self-test function runs through a series of sanity checks to verify that the core system is working properly.  This tutorial will illustrate how to:

  1. Write a simple program that uses the Helios API.
     - Declare and instance of the Helios context class.
     - Run the context self-test function.
  2. Build and compile the core Helios library.

  \section program_1 C++ Program	  

  We will first write a basic C++ program that uses types included as part of the Helios library. The program is written in the same way any C++ program, and contains a <a href="http://en.cppreference.com/w/cpp/language/main_function">main function</a>.  Helios simply provides a group of data types and functions that manages model geometry and data.  These types and functions are defined in the header file "Context.h", which must be included in any files that use Helios constructs. 

  ```
  #include "Context.h"

  int main(){

    //Write program here

  }
  ```

  The above program does not actually perform any calculations.  Next, we will declare and instance of the Helios context, which is a C++ <a href="http://en.cppreference.com/w/cpp/language/class">class</a> that contains a number of functions and data structures.  We will declare an instance of the class, which we will give the arbitrary name of "context".  

  Next, we will call the function within the Context class called \ref helios::Context::selfTest() "selfTest()", which performs a number of basic tests to ensure that the context is working properly.

 ```
  #include "Context.h"

  int main(){

     //Declare and initialize the Helios context
     helios::Context context;

     //Run the self-test
     context.selfTest(); 

  }
  ```

  Note that the Context is within the "helios" <a href="http://en.cppreference.com/w/cpp/language/namespace">namespace</a>.  Alternatively, we could use the "using namespace helios" directive before our main function to avoid the need to explicitly specify the namespace for each name (i.e., "helios::" no longer needed).

  We will save this file as "main.cpp", which we will reference later when building/compiling.

  \section build_2 Building, Compiling, and Running

  Before building and compiling, please reference the \ref QuickStart "Getting Started" page to ensure you have installed all required dependent libraries.

  The files needed to build and compile this tutorial are located in the directory "samples/context_selftest".  There is a "CMakeLists.txt" file that contains the information needed to build the project.  There is also the file "main.cpp" which contains the source code for the program that we wrote previously, and there is a directory called "build" which will be used to hold the files and folders for the current build of the code.  Note, however, that the build directory could be placed anywhere and have any name.

  To build the project, change into the build directory.  Next, use the "cmake" command to build the code.  The argument to the cmake command should be an absolute or relative path to the directory that contains the CMakeLists.txt file for the build.  Given the directory structure used in this project, the CMakeLists.txt file is up one directory, so the relative path to this directory is "..".  The following commands should build the project, assuming you are starting from the base Helios directory:

  ~~~~~~
  $ cd samples/context_selftest/build
  $ cmake ..
  ~~~~~~

 If all goes well, the command should output many lines of information, the last of which is

  ~~~~~~
  $ -- Build files have been written to: /path/to/Helios/samples/context_selftest/build
  ~~~~~~

 and there should be a file named "Makefile" now in the build directory.  Use this makefile to complile the code into an executable

  ~~~~~~
  $ make
  ~~~~~~

 This should produce an executable file named "context_selftest" that can be run:

  ~~~~~~
  $ ./context_selftest
  ~~~~~~

 which should produce the following output:

  ~~~~~~
  $ Running Context self-test...passed.
  ~~~~~~

 So what determines the name of the executable file (i.e., why is it called "context_selftest")?  This was specified in the CMakeLists.txt file.  If you open up the CMakeLists.txt file, you will find several inputs on the first couple of lines:

  ~~~~~~
  #-------- USER INPUTS ---------#

  #provide the path (relative or absolute) to Helios base directory
  set( BASE_DIRECTORY "../.." )
	
  #define the name of the executable to be created
  set( EXECUTABLE_NAME "context_selftest" )

  #provide name of source file(s) (separate multiple file names with semicolon)
  set( SOURCE_FILES "main.cpp" )

  #specify which plug-ins to use (separate plug-in names with semicolon)
  set( PLUGINS "" )
  ~~~~~~

 Notice the line where we have set the name of the executable to "context_selftest", which we could change to any name.  Notice also just below where we specify the name of the source code file ("main.cpp").  It is important to note that the path to the source files is relative to the directory where the CMakeLists.txt file is located.

 */

 ##################### TUTORIAL 1 #####################

/*! \page context_vectors_tutorial Tutorial 1: Helios Vector Types Tutorial

 There are several vector types commonly used in Helios, which are listed in the table below.  These are essentially C++ structures, that contain several data elements and functions to operate on that data.

 One example of these vector types is a vector of three values: \ref helios::vec3.  It contains three elements - x,y,z - and is commonly used to represent 3D coordinates in space.  When working with 3D vectors, there are operations that often need to be performed such as normalizing the vector to unit length, performing a dot product, or adding two vectors.  Thus, there are many built-in funcitons and operations associated with these vector types.

 In this simple tutorial, we will learn how to work with Helios vector types.

 <table>
   <tr><th>Type</th><th>Description</th><th>Data Fields</th><th>Member Functions</th><th>Creation Function</th></tr>
   <tr><td>\ref helios::vec2 "vec2"</td><td>2D vector of floats</td><td>\ref helios::vec2::x "x", \ref helios::vec2::y "y"</td><td>\ref helios::vec2::normalize() "normalize()", \ref helios::vec2::magnitude() "magnitude()"</td><td>\ref helios::make_vec2() "make_vec2()"</td></tr>
   <tr><td>\ref helios::vec3 "vec3"</td><td>3D vector of floats</td><td>\ref helios::vec3::x "x", \ref helios::vec3::y "y", \ref helios::vec3::z "z"</td><td>\ref helios::vec3::normalize() "normalize()", \ref helios::vec3::magnitude() "magnitude()"</td><td>\ref helios::make_vec3() "make_vec3()"</td></tr>
   <tr><td>\ref helios::vec4 "vec4"</td><td>4D vector of floats</td><td>\ref helios::vec4::x "x", \ref helios::vec4::y "y", \ref helios::vec4::z "z", \ref helios::vec4::w "w"</td><td>none</td><td>\ref helios::make_vec4() "make_vec4()"</td></tr>
   <tr><td>\ref helios::int2 "int2"</td><td>2D vector of integers</td><td>\ref helios::int2::x "x", \ref helios::int2::y "y"</td><td>none</td><td>\ref helios::make_int2() "make_int2()"</td></tr>
   <tr><td>\ref helios::int3 "int3"</td><td>3D vector of integers</td><td>\ref helios::int3::x "x", \ref helios::int3::y "y", \ref helios::int3::z "z"</td><td>none</td><td>\ref helios::make_int3() "make_int3()"</td></tr>
   <tr><td>\ref helios::int4 "int4"</td><td>4D vector of integers</td><td>\ref helios::int4::x "x", \ref helios::int4::y "y", \ref helios::int4::z "z", \ref helios::int4::w "w"</td><td>none</td><td>\ref helios::make_int4() "make_int4()"</td></tr>
   <tr><td>\ref helios::RGBcolor "RGBcolor"</td><td>red-green-blue color code</td><td>\ref helios::RGBcolor::r "r", \ref helios::RGBcolor::g "g", \ref helios::RGBcolor::b "b"</td><td>\ref helios::RGBcolor::scale() "scale()"</td><td>\ref helios::make_RGBcolor() "make_RGBcolor()"</td></tr>
   <tr>	<td>\ref helios::RGBAcolor "RGBAcolor"</td> <td>red-green-blue-alpha color code</td><td>\ref helios::RGBAcolor::r "r", \ref helios::RGBAcolor::g "g", \ref helios::RGBAcolor::b "b", \ref helios::RGBAcolor::a "a"</td><td>\ref helios::RGBAcolor::scale() "scale()", \ref helios::RGBAcolor::clamp() "clamp()"</td><td>\ref helios::make_RGBAcolor() "make_RGBAcolor()"</td> </tr>
   <tr>	<td>\ref helios::Time "Time"</td><td>Time of day</td><td>\ref helios::Time::second "second", \ref helios::Time::minute "minute", \ref helios::Time::hour "hour"</td><td>none</td><td>\ref helios::make_Time() "make_Time()"</td></tr>
   <tr>	<td>\ref helios::Date "Date"</td><td>Calendar date (MM,DD,YYYY)</td><td>\ref helios::Date::day "day", \ref helios::Date::month "month", \ref helios::Date::year "year"</td><td>\ref helios::Date::JulianDay() "JulianDay()"</td><td>\ref helios::make_Date() "make_Date()"</td></tr>
 </table> 

 \section int3tut Vector of Integers

 Vector types are available for a 2-element (\ref helios::int2 "int2") and 3-element (\ref helios::int3 "int3") vector of integers. An int2 has two elements: x and y, and and int3 has three elements: x, y, and z.  These values of the elements are set using either the \ref helios::make_int2() "make_int2()" or \ref helios::make_int3() "make_int3()" functions.

 In the code example below, we'll make an int3, and set is data values to x=1, y=2, and z=3.

  ~~~~~~{.cpp}
  #include "Context.h"

  using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names
     
  int main(){

     //Declare our int3, named 'a'
     int3 a;

     //Set the data values
     a = make_int3(1,2,3);

     //Alternatively, we could have initialized data values in the following equivalent ways
     int3 b(1,2,3);
     int3 b = make_int3(1,2,3);

  }
  ~~~~~~

 \section vec3tut Vector of Floats

 Vector types are also available for a 2-element (\ref helios::vec2 "vec2") and 3-element (\ref helios::vec3 "vec3") vector of floats. In addition to the similar elements and creation functions as for integers, we will also demonstrate several built-in funcions and operators.

  ~~~~~~{.cpp}
  #include "Context.h"

  using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names
     
  int main(){

     //Declare our vec3, named 'a' and set its values
     vec3 a = make_vec3(0,0.1,0.2);

     //Declare another vec3, named 'b' and set its values
     vec3 b = make_vec3(1.5,1.4,1.3);

     //Add a and b, and assign it to 'c'
     vec3 c = a + b; //result is c = (1.5,1.5,1.5)

     //Normalize 'c' to have unit length
     c.normalize(); //result is c = (0.577,0.577,0.577)

     //Compute the dot product of a and b, and assign it to 'd'
     float d = a * b; //result is d = 0.4

  }
  ~~~~~~

  \section RGBtut RGB Color Vector

  Colors in an image are typically represented using three channels: red, green, and blue (see <a href="https://en.wikipedia.org/wiki/RGB_color_space">this page</a> for more info).  For a given r-g-b color triple, red, green, and blue values range from 0 to 1.  A value of 0 means that particular channel does not contribute to the overall color, and a value of 1 means that channel fully contributes to the overall color.  For example, (r,g,b)=(0,0,0) produces the color black, (r,g,b)=(1,1,1) produces black, (r,g,b)=(1,0,0) produces red, (r,g,b)=(0,1,0) produces green, etc.  Additionally, an r-g-b-a color value can also be used to specify the transparency of the color, where 'a' is the alpha value.  A value of 'a' = 0 means the color is completely transparent, and 'a' = 1 means it is completely opaque.  For example, (r,g,b,a)=(1,0,0,0.5) would produce a red color that is semi-transparent. Note that defining a color using an r-g-b vector implicitly assumes that 'a' = 1 (opaque).

  The Helios vector type for representing an r-g-b color vector is \ref helios::RGBcolor "RGBcolor", and \ref helios::RGBAcolor "RGBAcolor" is used to represent an r-g-b-a vector. There are several constructors for r-g-b vectors (i.e., ways of initializing).  These are listed in the table below.

  <table>
   <tr><th>RGBcolor Constructor</th><th>RGBAcolor Constructor</th></tr>
   <tr><td>\ref helios::RGBcolor(void) "RGBcolor(void)"</td><td>\ref helios::RGBAcolor(void) "RGBAcolor(void)"</td></tr>
   <tr><td>\ref helios::RGBcolor( float r, float g, float b ) "RGBcolor( float r, float g, float b )"</td><td>\ref helios::RGBAcolor( float r, float g, float b, float a ) "RGBAcolor( float r, float g, float b, float a )"</td></tr>
   <tr><td>\ref helios::RGBcolor( float C[3] ) "RGBcolor( float C[3] )"</td><td>\ref helios::RGBAcolor( float C[4] ) "RGBAcolor( float C[4] )"</td></tr>
   <tr><td>\ref helios::RGBcolor( std::vector<float> C ) "RGBcolor( std::vector<float> C )"</td><td>\ref helios::RGBAcolor( std::vector<float> C ) "RGBAcolor( std::vector<float> C )"</td></tr>
   <tr><td>\ref helios::RGBcolor( helios::vec3 C ) "RGBcolor( helios::vec3 C )"</td><td>N/A</td></tr>
   </table>	

  After an r-g-b vector has already been initialized, channel values are changed using the functions \ref helios::make_RGBcolor() "make_RGBcolor()" and \ref helios::make_RGBAcolor() "make_RGBAcolor()".

  The code below gives several simple examples of using color vectors.

  ~~~~~~{.cpp}
  #include "Context.h"

  using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names
     
  int main(){

     RGBcolor color(1,0,0); //red color (opaque)
     RGBAcolor color_t(1,0,0,0.5); //red color (semi-transparent)

     color = make_RGBcolor(0,0,1); //change color to blue

  }
  ~~~~~~

  \section Timetut Time Vector

  The vector type \ref helios::Time "Time" is used to represent times of day.  This vector type has three data elements: 'hour' (0-23), 'minute' (0-59), and 'second' (0-59).  These element values are set in the usual way using the \ref helios::make_Time( int hour, int minute, int second ) "make_Time( int hour, int minute, int second )" function. 

  Example code is given below.

  ~~~~~~{.cpp}
  #include "Context.h"

  using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names
     
  int main(){

     Time time = make_Time(12,30,00); // time of 12:30:00

  }
  ~~~~~~

 \section Datetut Date Vector

 Dates are represented using a similar vector type \ref helios::Date "Date".  This vector type has three data elements: 'day' (1-31), 'month' (1-12), 'year' (YYYY).  These element values are set in the usual way using the \ref helios::make_Date( int day, int month, int year ) "make_Date( int day, int month, int year )" function. 

 It is often convenient to represent dates as a <a href="https://en.wikipedia.org/wiki/Julian_day">Julian day</a> of year.  There is a built-in member function that can compute the Julian day from a Date vector: \ref helios::Date::JulianDay() "Date::JulianDay()".  A Julian Day can also be converted back to a Date vectory using the function \ref helios::Julian2Calendar( int JulianDay, int year ) "Julian2Calendar( int JulianDay, int year )".

  ~~~~~~{.cpp}
  #include "Context.h"

  using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names
     
  int main(){

     Date date = make_Date(1,1,2000); //Jan 1, 2000

     //Convert to Julian day
     int JD = date.JulianDay();

     //Convert Julian day back to Date
     date = Julian2Calendar( JD, 2000 );

  }
  ~~~~~~
 
*/

##################### TUTORIAL 2 #####################

/*! \page context_primitives_tutorial Tutorial 2: Working with Context Geometry

\section context_primitives_overview Overview

 In this tutorial, you will gain experience working with model geometry or "primitives". There are several types of geometric elements, which can be used to make up virtually any shape/object. Available primitives are given in the table below.

 <table>
   <tr>	<th>Primitive</th><th>Description</th></tr>
   <tr> <td>\ref helios::Patch "Patch"</td> <td>Rectangular polygon with coplanar vertices.  A patch is specified by the (x,y,z) coordinate of its center and by the lengths of its sides in the x- and y-directions.  The default orientation of a patch is horizontal (i.e., it's normal is in the +z direction).</td> </tr>
   <tr>	<td>\ref helios::Triangle "Triangle"</td> <td>Triangular polygon specified by its three vertices.</td> </tr>
   <tr>	<td>\ref helios::Voxel "Voxel"</td> <td>Parallelpiped or rectangular prism.  A voxel is specified by the (x,y,z) coordinate of its center and by the lengths of its sides in the x-, y-, and z-directions.  The default orientation of a voxel is axis-aligned.</td> </tr>
 </table> 

 There are functions to add each of these primitive types defined in the Context. For example, a Patch can be added via the \ref Context::addPatch( vec3, vec2 ) function. Note that these functions to add primitives are usually <a href="http://www.cplusplus.com/doc/tutorial/functions2/">"overloaded"</a>, which means there are multiple definitions of the functions.

 \section AddPatch Adding a Patch to the Context
    
 Let's write a program that adds a Patch to the Context. We will begin with a blank program that includes the Context.h header (provides context definitions), and declares the Context. We then want to write the code to add a Patch.

  ~~~~~~{.cpp}
  #include "Context.h"

  using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names
     
  int main(){

     Context context; //Declare the "Context" class

     //Write code here to add a Patch to the Context

  }
  ~~~~~~

 We will then call the \ref helios::Context::addPatch( const vec3& position, const vec2& size ) "addPatch( vec3 position, vec2 size )" function to add a patch to the Context. Note that member functions (e.g., addPatch) of a class (e.g., Context) are called using a ".". We will pass two arguments to the addPatch function: the (x,y,z) position of the Patch center point, and the length and width (size) of the Patch. The position argument is a \ref helios::vec3 "vec3", and the size argument is a \ref helios::vec2 "vec2". We will create variables "position" and "size" with types of vec3 and vec2, respectively.  We will initialize position with the coordinate (0,0,0) and size with (1,1). There are other optional arguments to the addPatch command such as arguments that specify a Patch rotation or color, but we'll worry about that later. Example code is given below. Note that we have added a few lines of code in order to be able to visualize the results using the Visualizer plug-in. Use of the visualizer will be explained in more depth in a later tutorial.

  ~~~~~~{.cpp}
  #include "Visualizer.h" //don't need to include Context.h because it's included in Visualizer.h

  using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names
     
  int main(){

     Context context;  //Declare the "Context" class

     vec3 position(0,0,0); //(x,y,z) position of patch center
     vec2 size(1,1); //length and width of patch

     context.addPatch( position, size );

     //Visualizer code
     Visualizer vis(800); //our Visualizer window will be 800 pixels wide
     vis.buildContextGeometry(&context);
     vis.plotInteractive();

  }
  ~~~~~~

 \section AddPatch_UUIDs Unique Universal Identifiers (UUIDs)

 The addPatch function and other functions to add primitives return a "Unique Universal Identifier" or UUID for that particular primitive. In the example above, we ignored the returned UUID, but in this example we will assign the UUID to a variable and use it to modify attributes of the primitive.

 UUIDs are of type "unsigned int" or "uint" for short, which is the return type for addPatch, addTriangle, etc. Functions that add multiple primitives at once return a vector of UUIDs (uints). The code below does the same thing as the previous example, except that it stores the UUID for the Patch.

  ~~~~~~{.cpp}
  #include "Visualizer.h"

  using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names
     
  int main(){

     Context context;  //Declare the "Context" class

     vec3 position(0,0,0); //(x,y,z) position of patch center
     vec2 size(1,1); //length and width of patch

     uint UUID; //declare the UUID variable
     
     UUID = context.addPatch( position, size ); //this will assign the UUID for this patch to the UUID variable

     //Visualizer code
     Visualizer vis(800); //our Visualizer window will be 800 pixels wide
     vis.buildContextGeometry(&context);
     vis.plotInteractive();

  }
  ~~~~~~

*/

<!--
##################### TUTORIAL 3 #####################

/*! \page context_timeseries_tutorial Tutorial 3: Data Timeseries

*/

##################### TUTORIAL 4 #####################

/*! \page context_fileio_tutorial Tutorial 4: File I/O

*/
-->

 ##################### TUTORIAL 5 #####################

/*! \page context_primdata_tutorial Tutorial 5: Primitive Data

 \section context_primdata_intro Introduction to Primitive Data

 Primitive data is information associated with a given primitive. This may be a physical propeerty of a primitive (e.g., reflectivity, roughness) or a the output of a model calculation (e.g., radiative flux, temperature). A few properites of primitive data is listed below:

 - Primitive data can be defined for some primitives but not others.
 - Primitive data can have types of float, double, int, uint, vec2, vec3, vec4, int2, int3, int4, and std::string.
 - Primitive data can have variable length.

 A graphical depiction of primitive data (green boxes) is given in the figure below.

 \image html images/Context_sketch.png 
 
 \section context_primdata_scalar Creating Primitive Data (Scalars)

 Adding primitive data that is a single (scalar) value can be accomplished using the \ref Context::addPrimitiveData() "addPrimitiveData()" function. We simply need to pass this function the UUID of a primitive, the name for this piece of data which the user can choose, and a piece of data with type float, double, int, uint, vec2, vec3, vec4, int2, int3, int4, or std::string. An example is given below where we add some data for a primitive called "my_data". We will add a sphere, which is comprised of many triangles, and add primitive data for one or more of these triangles. 

  ~~~~~~{.cpp}
  #include "Context.h"

  using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names
     
  int main(){

     Context context;  //Declare the "Context" class

     vec3 center(0,0,0); //(x,y,z) position of sphere center
     float r = 1; //radius of sphere

     std::vector<uint> UUIDs; //vector to store UUIDs of sphere 

     UUIDs = context.addSphere( 10, center, r ); //add a sphere to the Context
     
     float data = 10;

     context.setPrimitiveData(UUIDs.at(0),"my_data",data); //add primitive data called my_data to only the first primitive with a value of 10

     context.setPrimitiveData(UUIDs,"my_data",data); //we could also set the value of all primitives at once
	 
 }
 ~~~~~~

 To retrieve the primitive value we set, we can use the \ref Context::getPrimitiveData() "getPrimitiveData()" function as illustrated below.

  ~~~~~~{.cpp}
  #include "Context.h"

  using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names
     
  int main(){

     Context context;  //Declare the "Context" class

     vec3 center(0,0,0); //(x,y,z) position of sphere center
     float r = 1; //radius of sphere

     std::vector<uint> UUIDs; //vector to store UUIDs of sphere 

     UUIDs = context.addSphere( 10, center, r ); //add a sphere to the Context
     
     float data = 10;

     context.setPrimitiveData(UUIDs.at(0),"my_data",data); //add primitive data called my_data to only the first primitive with a value of 10

     float data_new;

     context.getPrimitiveData(UUIDs.at(0),"my_data",data_new); //get the primitive data and assign it to 'data_new'
	 
 }
 ~~~~~~

 \section context_primdata_arrays Creating Primitive Data (Arrays)

 Adding primitive data that has length greater than one (array) requires a little extra information, namely the type of the data to be added and the length of the data array. The type is specified by one of the enumerations given in the table below;

 <table>
   <tr>	<th>Data type</th> <th>Enumeration (HeliosDataType)</th> </tr>
   <tr>	<td>int</td><td>\ref helios::HELIOS_TYPE_INT "HELIOS_TYPE_INT"</td></tr>
   <tr>	<td>uint</td> <td>\ref helios::HELIOS_TYPE_UINT "HELIOS_TYPE_UINT"</td></tr>
   <tr>	<td>float</td> <td>\ref helios::HELIOS_TYPE_FLOAT "HELIOS_TYPE_FLOAT"</td> </tr>
   <tr>	<td>double</td><td>\ref helios::HELIOS_TYPE_DOUBLE "HELIOS_TYPE_DOUBLE"</td> </tr>
   <tr>	<td>vec2</td><td>\ref helios::HELIOS_TYPE_VEC2 "HELIOS_TYPE_VEC2"</td></tr>
   <tr>	<td>vec3</td><td>\ref helios::HELIOS_TYPE_VEC3 "HELIOS_TYPE_VEC3"</td></tr>
   <tr>	<td>vec4</td> <td>\ref helios::HELIOS_TYPE_VEC4 "HELIOS_TYPE_VEC4"</td></tr>
   <tr>	<td>int2</td> <td>\ref helios::HELIOS_TYPE_INT2 "HELIOS_TYPE_INT2"</td> </tr>
   <tr>	<td>int3</td> <td>\ref helios::HELIOS_TYPE_INT3 "HELIOS_TYPE_INT3"</td></tr>
   <tr>	<td>int4</td><td>\ref helios::HELIOS_TYPE_INT4 "HELIOS_TYPE_INT4"</td></tr>
   <tr>	<td>std::string</td><td>\ref helios::HELIOS_TYPE_STRING "HELIOS_TYPE_STRING"</td></tr>
 </table>

  ~~~~~~{.cpp}
  #include "Context.h"

  using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names
     
  int main(){

     Context context;  //Declare the "Context" class

     vec3 center(0,0,0); //(x,y,z) position of sphere center
     float r = 1; //radius of sphere

     std::vector<uint> UUIDs; //vector to store UUIDs of sphere 

     UUIDs = context.addSphere( 10, center, r ); //add a sphere to the Context
     
     float data[5] = {10, 11, 12, 13, 14};

     context.setPrimitiveData(UUIDs.at(0),"my_data",HELIOS_TYPE_FLOAT,5,&data); //add primitive data called my_data to only the first primitive

     std::vector<float> data_new;

     context.getPrimitiveData(UUIDs.at(0),"my_data",data_new); //get the primitive data and assign it to 'data_new'
	 
 }
 ~~~~~~
 
*/

##################### TUTORIAL 6 #####################

/*! \page context_globaldata_tutorial Tutorial 6: Global Data

 \section context_globaldata_intro Introduction to Global Data

 Using global data is very similar to using primitive data (see \ref context_primdata), with the only notable difference being that global data is not defined for every primitive, but rather there exists only one instance of particular global data.

 A graphical depiction of global data (right box) and primitive data (green boxes) is given in the figure below.

 \image html images/Context_sketch.png 
 
 \section context_globaldata_scalar Creating Global Data (Scalars)

 Adding global data that is a single (scalar) value is essentially the same as adding scalar primitive data except that we do not pass the function a UUID (since global data does not correspond to any given primitive). To add/set global data, we use the \ref Context::addGlobalData() "addGlobalData()" function. We simply need to pass this function the name for this piece of data which the user can choose, and a piece of data with type float, double, int, uint, vec2, vec3, vec4, int2, int3, int4, or string. An example is given below where we add some global data called "my_data". 

  ~~~~~~{.cpp}
  #include "Context.h"

  using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names
     
  int main(){

     Context context;  //Declare the "Context" class

     context.setGlobalData("my_data",10.0); //add global data called my_data with a value of 10
	 
 }
 ~~~~~~

 \section context_globaldata_arrays Creating Global Data (Arrays)
 
 Adding global data that has length greater than one (array) requires a little extra information, namely the type of the data to be added and the length of the data array. The type is specified by one of the enumerations given in the table below.

 <table>
   <tr>	<th>Data type</th> <th>Enumeration (HeliosDataType)</th> </tr>
   <tr>	<td>int</td><td>\ref helios::HELIOS_TYPE_INT "HELIOS_TYPE_INT"</td></tr>
   <tr>	<td>uint</td> <td>\ref helios::HELIOS_TYPE_UINT "HELIOS_TYPE_UINT"</td></tr>
   <tr>	<td>float</td> <td>\ref helios::HELIOS_TYPE_FLOAT "HELIOS_TYPE_FLOAT"</td> </tr>
   <tr>	<td>double</td><td>\ref helios::HELIOS_TYPE_DOUBLE "HELIOS_TYPE_DOUBLE"</td> </tr>
   <tr>	<td>vec2</td><td>\ref helios::HELIOS_TYPE_VEC2 "HELIOS_TYPE_VEC2"</td></tr>
   <tr>	<td>vec3</td><td>\ref helios::HELIOS_TYPE_VEC3 "HELIOS_TYPE_VEC3"</td></tr>
   <tr>	<td>vec4</td> <td>\ref helios::HELIOS_TYPE_VEC4 "HELIOS_TYPE_VEC4"</td></tr>
   <tr>	<td>int2</td> <td>\ref helios::HELIOS_TYPE_INT2 "HELIOS_TYPE_INT2"</td> </tr>
   <tr>	<td>int3</td> <td>\ref helios::HELIOS_TYPE_INT3 "HELIOS_TYPE_INT3"</td></tr>
   <tr>	<td>int4</td><td>\ref helios::HELIOS_TYPE_INT4 "HELIOS_TYPE_INT4"</td></tr>
   <tr>	<td>std::string</td><td>\ref helios::HELIOS_TYPE_STRING "HELIOS_TYPE_STRING"</td></tr>
 </table>

  ~~~~~~{.cpp}
  #include "Context.h"

  using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names
     
  int main(){

     Context context;  //Declare the "Context" class

     float data[5] = {10, 11, 12, 13, 14};

     context.setGlobalData("my_data",HELIOS_TYPE_FLOAT,5,&data); //add global data called my_data to only the first primitive

     std::vector<float> data_new;

     context.getGlobalData("my_data",data_new); //get the global data and assign it to 'data_new'
	 
 }
 ~~~~~~

*/

##################### TUTORIAL 7 #####################

/*! \page visualizer_basics_tutorial Tutorial 7: %Visualizer Basics

 In this tutorial, we will explain in more depth the use of the Visualizer plug-in functions that were shown in previous tutorials. Users are strongly encouraged to read through the detailed \ref VisualizerDoc.

 Using the Visualizer typically consists of four steps:

 1. Declare and initialize the %Visualizer class.
 2. Add geometry to the %Visualizer.
 3. Modify %Visualizer options.
 4. Plot the result.

 Each of these steps will be detailed in depth below. The purpose of the Visualizer is to provide a graphical representation of geometry and associated data.

 \section vis_step1 Step 1. Declare and initialize the Visualizer class

 To begin using the Visualizer, we must first declare the \ref Visualizer class. Note that the "Visualizer.h" header file must be included in our program, and the "PLUGINS" variable in our project's CMakeLists.txt file must include "visualizer".

 The Visualizer constructor takes one or two arguments that specifies the size of the graphics window in pixels. If only one argument is provided (see \ref Visualizer( uint Wdisplay )), the argument is an integer that specifies the width of the diplay window in pixels, with the hight of the window specified according to the default aspect ratio. If two arguments are provided (see \ref Visualizer( uint Wdisplay, uint Hdisplay )), the two arguments correspond respectively to the width and height of the display window in pixels. Example code is given below.

  ~~~~~~{.cpp}
  #include "Visualizer.h"

  using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names
     
  int main(){
     
     Visualizer vis(800); //creates a display window 800 pixels wide

  }
  ~~~~~~


 \section vis_step2 Step 2. Add geometry to the Visualizer

 There are a variety of ways to add geometry to the Visualizer. Primitives can be manually added to the Visualizer in a similar manner as primitives are added to the Context, with several notable differences. First, there are additional primitive types available in the Visualizer such as lines and points. Second, there are additional arguments that must be specified when adding primitives to the Visualizer, namely the graphics layer associated with the primitive (see \ref Layer) and the coordinate system to be used (see \ref coord).

 Most commonly, we do not wish to manually add geometry to the Visualizer, but rather we simply want to visualize geometry in the Context. There is a simple command that will automatically add all geometry in the Context to the Visualizer: \ref Visualizer::buildContextGeometry(). This function takes a pointer to the Context, which is used to import all geometry. There are other variations on the buildContextGeometry() command that allow for the placement of Context geometry on any layer or to add only a subset of the geometry in the Context (see \ref ContextGeom). In the example below, we add all geometry in the Context to the default layer (layer 0).

  ~~~~~~{.cpp}
  #include "Visualizer.h"

  using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names
     
  int main(){

     Context context;  //Declare the "Context" class

     vec3 position(0,0,0); //(x,y,z) position of patch center
     vec2 size(1,1); //length and width of patch

     context.addPatch( position, size ); //add the patch to Context

     Visualizer vis(800); //creates a display window 800 pixels wide

     vis.buildContextGeometry( &context ); //add all geometry in the context to the visualizer

  }
  ~~~~~~

 Note that in the above example, we've given our Visualizer class the name of "vis", which is the name that should be used to reference it.
 
 \section vis_step3 Step 3. Modify Visualizer options

 Additional options for the Visualizer are set by calling the appropriate member functions in the Visualizer class. Various options may be changing the lighting model, changing the default camera view configuration, changing data used to color primitives, etc.
 Consult the \ref VisualizerDoc for more details on available options. In this tutorial, we'll just use the default options (by not setting any options explicitly).
 
 \section vis_step4 Step 4. Plot the result

 Finally, we'll want to actually plot the result to the graphics window. There are two primary functions to do so.  One is \ref Visualizer::plotInteractive(), which generates an interactive plot in which the user can interactively modify the camera configuation via keystrokes. In this case, the graphics window will stay open until the user closes it, and the program will pause until the window is closed.

 Another method is to simply update the graphics window and move on with the program using the function \ref Visualizer::plotUpdate(). This is typically used when the graphics window is to be printed to file using the Visualizer::printWindow() function.

 In the example below, we'll first update the window, move on in the program where we'll print the graphics window to an image file, then we'll open an interactive plot window. Note that all file paths in Helios should either be absolute paths, or relative to the build directory where the executable file is being run. So in the example below, the image file will be located in the build directory.

  ~~~~~~{.cpp}
  #include "Visualizer.h"

  using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names
     
  int main(){

     Context context;  //Declare the "Context" class

     vec3 position(0,0,0); //(x,y,z) position of patch center
     vec2 size(1,1); //length and width of patch

     context.addPatch( position, size ); //add the patch to Context

     Visualizer vis(800); //creates a display window 800 pixels wide

     vis.buildContextGeometry( &context ); //add all geometry in the context to the visualizer

     vis.plotUpdate(); //update the graphics window and move on
     vis.printWindow( "patch.jpeg" ); //print window to JPEG file
     
     vis.plotInteractive(); //open an interactive graphics window
   
  }
  ~~~~~~

*/

##################### TUTORIAL 8 #####################

/*! \page visualizer_pdata_tutorial Tutorial 8: Visualizing primitive data values

 This tutorial will illustrate how to use the Helios visualizer to visualize primitive data based on a pseudocolor mapping. The code below gives a main.cpp file that loads in a 3D model, sets primitive data for each primitive in the model, and creates a pseudocolor mapping to visualize the primitive data distribution.

 \subsection Tutorial8_geom Model geometry

 The first step is to declare the Context class in the usual way, then add some geometry to the Context. In this case, we'll load in a 3D model of the well-known <a href="https://en.wikipedia.org/wiki/Stanford_bunny">Stanford Bunny</a> from a <a href="https://en.wikipedia.org/wiki/PLY_(file_format)">PLY file</a>. This file is located in the "PLY" directory found in the base Helios code directory. It is important to either give an absolute path to this file, or a path relative to the build directory. Since this tutorial is build in the directory "Helios/samples/tutorial8/build", the relative path to the PLY file is "../../../PLY/StanfordBunny.ply".

 We can then use the \ref helios::Context::loadPLY() function to load the model. In addition to the relative file path, we need to specify the base (x,y,z) position to place the model, the height to which we want to scale the model, a spherical rotation (if applicable) and the default color of the model primitives. In the example below, we'll place the model at the position (0,0,0), scale it to a height of 2, apply no rotation, and assign a default color of black. Note that if you specify a scaling factor of 0, no scaling will be applied. This function returns a vector of UUIDs, one for each primitive loaded in the model.

 Next, we will specify some primitive data that we'll visualize later. We will create a primitive data called "height" that corresponds to the z-coordinate of each primitive in the 3D model. To do this, we first loop over the UUID vector returned from the \ref helios::Context::loadPLY() function we called previously. For each UUID, we get the vertices of the corresponding primitive. The Stanford Bunny model contains only triangles, so the \ref helios::Context::getPrimitiveVertices() function returns a 3-element vector of vec3's, with each index of the vector corresponding to each of the 3 (x,y,z) vertex coordinates. As a simple approximation, we'll use only the first vertex in the triangle to determine the height of the primitive. Thus, we can index the vertex vector at element 0 to get the (x,y,z) coordinate of the first vertex. Getting the .z member of the vertex coordinate (which has type vec3) gets us the z-coordinate or height.

 Once we have the height of the primitive, we can create and set primitive data called "height" (or whatever name you choose) using the \ref helios::Context::setPrimitiveData().

 \subsection Tutorial8_vis Visualization

 Finally, we just need to visualize the result. We set up the Visualizer in a similar way as before, but if we add a call to \ref Visualizer::colorContextPrimitivesByData(), it will color the primitives based on a pseudocolor mapping of primitive data values. This means that it will map the data values to colors in a colormap (array of colors) to determine its color. The argument to this function is the name of the primitive data created previously. If the primitive data does not exist for one or more primitives, they will be assigned a value of 0. You can also call this function with an optional argument of a UUID vector, which will only perform the pseudocolor mapping for the primitives referenced in the UUID vector.

 Details of the colormap and colorbar can be modified through a number of functions. Here' we've changed the colormap from the default of "HOT" to "PARULA". Available colormaps are listed in the \ref VisualizerDoc "Visualizer documentation page", as well as how to make custom colormaps. We've also added a title to the colorbar.

  ~~~~~~{.cpp}
  #include "Visualizer.h"

  using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names

  int main(){

   Context context;   //Declare the "Context" class

   // Load 3D model "Stanford Bunny" with a base position of (0,0,0) and scaled to a height of 2
   std::vector<uint> UUIDs = context.loadPLY( "../../../PLY/StanfordBunny.ply", make_vec3(0,0,0), 2, nullrotation, RGB::black );

   // Assign primitive data called "height" which gives the primitive z-coordinate
   for( uint UUID : UUIDs ){ //looping over primitive UUIDs
     std::vector<vec3> vertices = context.getPrimitiveVertices(UUID);  //get a vector containing the (x,y,z) position of each primitive vertex
     vec3 vertex = vertices.at(0);  //get the first vertex
     float z = vertex.z;   //get the vertex z-coordinate
     context.setPrimitiveData(UUID,"height",z);  //set this primitive's primitive data "height" equal to the value of "z"
   }

   // Visualize the result
   Visualizer visualizer(800);

   visualizer.buildContextGeometry(&context);

   visualizer.colorContextPrimitivesByData( "height" ); //color primitives based on a pseudocolor mapping of primitive data "height"

   visualizer.setColormap( Visualizer::COLORMAP_PARULA );  //change the colormap to "parula"
   visualizer.setColorbarTitle("Height" ); //give our colorbar a title

   visualizer.plotInteractive();

   return 0;
  }
  ~~~~~~

 The code above should produce the visualization shown below. You can rotate the view using the arrow keys on your keyboard to better view the model.

 \image html images/Tutorial8_bunny.png

*/

##################### TUTORIAL 9 #####################

<!--
/*! \page visualizer_custom_tutorial Tutorial 9: Customizing visualizations


*/
-->

##################### TUTORIAL 10 #####################

/*! \page radiation_basics_tutorial Tutorial 10: Radiation model basics - tree light interception

 This tutorial will illustrate how to simulate and calculate photosynthetically active radiation (PAR) interception of a tree canopy using the radiation model plug-in.

 \subsection Tutorial10_geom 1. Model geometry creation

 The first step is to declare the Context class in the usual way, then add some geometry to the Context. In this case, we'll load in a 3D model of a tree from a <a href="https://en.wikipedia.org/wiki/PLY_(file_format)">PLY file</a>. This file is located in the "PLY" directory found in the base Helios code directory. It is important to either give an absolute path to this file, or a path relative to the build directory. Since this tutorial is build in the directory "Helios/samples/tutorial10/build", the relative path to the PLY file is "../../../PLY/Tree.ply".

 We can then use the \ref helios::Context::loadPLY() function to load the model. In addition to the relative file path, we need to specify the base (x,y,z) position to place the model, the height to which we want to scale the model, a spherical rotation (if applicable) and the default color of the model primitives. In the example below, we'll place the model at the position (0,0,0), scale it to a height of 5, apply no rotation, and assign a default color of black. Note that if you specify a scaling factor of 0, no scaling will be applied. This function returns a vector of UUIDs, one for each primitive loaded in the model.

 Next, we'll add a ground surface consisting of tiled patches. The ground will be centered at the point (0,0,0), and be divided into 50x50 patch tiles with total size of plant_spacing x row_spacing. The \ref helios::Context::addTile() function returns a vector of UUIDs, one UUID for each patch primitive in the tile.

\subsection Tutorial10_rad 2. Radiation model set-up

 We can then declare and initialize the \ref RadiationModel class. It's constructor takes a pointer to the \ref Context as an argument, so that it can get model geometry and data, and write calculated values to primitive data.

 We'll then add a "sun sphere" radiation source in the model using \ref RadiationModel::addSunSphereRadiationSource(). This creates a spherical radiation source with size and distance of the sun, and thus includes penumbral effects. This function with no arguments sets the sun position as vertical, but we'll pass it a \ref helios::SphericalCoord that sets the sun elevation at 60 degrees and azimuth at 45 degrees. The function returns a uint value that gives an ID of the source that we'll use to reference it later.

 The \ref RadiationModel::addRadiationBand() function is then used to add a radiation band called "PAR". We can call the band anything we want, this is simply a label we'll use to refer to it later. We want to disable primitive emission for this band, since terrestrial objects don't emit radiation in the PAR band. We then set the flux of the radiation source (sun) to a value of 500 W/m<sup>2</sup>, and set the diffuse (ambient) flux to be 50 W/m<sup>2</sup>. By default, it is assume that diffuse radiation is isotropic, but this can be changed using the \ref RadiationModel::setDiffuseRadiationExtinctionCoeff() function (see \ref RadiationDoc "documentation" for details). For this exercise, we will assume that leaves and branches absorb all incoming PAR (default behavior), so we don't need to turn on scattering.

 By default, primitives absorb and emit radiation from both sides. This is the behavior we want for leaves, but for the ground, we don't want it to receive diffuse radiation from below. We can set the primitive data "twosided_flag" to a value of 0 to disable radiation absorption and emission from the back face. Note that "twosided_flag" needs to have a type of uint, as specified in the \ref RadiationDoc "radiation model documentation".

 A periodic lateral boundary will allow for simulation of an infinitely repeating canopy of trees. This is enabled using the \ref RadiationModel::enforcePeriodicBoundary() with the argument "xy". This function will determine a bounding box for all primitives, and create a periodic boundary at the box face(s). If the domain has a ground surface, it is very important that no primitives extend past the ground. Otherwise, the domain bounding box will extend past the ground surface, and there will effectively be a gap between the ground and the periodic boundary. If there is a chance that you might have primitives extending past the ground, you can use the \ref helios::Context::cropDomain() function to crop the lateral domain extent to that of the ground surface. Example code for doing this is provided in the radiation model documentation (see \ref RadPeriodic).

 The final step before running the model is always to update geometry in the radiation model based on geometry currently in the Context. The \ref RadiationModel::updateGeometry() function should be called any time the Context geometry or primitive data relevant to the radiation model are changed.

 \subsection Tutorial10_run 3. Run the model and calculate PAR interception

 Radiation model calculations are performed when the \ref RadiationModel::runBand() function is called. This function should be called for every radiation band that was created. Absorbed radiation fluxes for each primitive and each band are calculated and written to the primitive data "radiation_flux_[*]", where [*] is the name of the radiation band that you chose.

 To calculate the fraction of PAR intercepted by the canopy, we can sum the total energy absorbed by the canopy and divide it by the sum of the total energy absorbed by the canopy and ground. The radiation model calculates radiative fluxes in W/m<sup>2</sup>, so we need to multiply by the primitive surface area to get energy rate in Watts (i.e., the sum of absorbed fluxes should be area-weighted). There are a number of functions in the Context for aggregating primitive data values, including the \ref helios::Context::calculatePrimitiveDataAreaWeightedSum(). The arguments to this function are a vector of UUIDs for primitives to include in the sum, the label of primitive data, and the variable in which to store the result. The type of the result variable should match the type of the primitive data.

 The fraction of PAR intercepted by the canopy is the area-weighted sum of PAR fluxes for the canopy divided by the area-weighted sum of ground plus canopy fluxes. We then print the result to the standard output.

 ~~~~~~{.cpp}
 #include "Visualizer.h"
 #include "RadiationModel.h"

 using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names

 int main(){

   // *** 1. Model geometry creation *** //

   float row_spacing = 5;    //spacing between tree rows
   float plant_spacing = 3;  //spacing between trees within a row

   Context context;   //Declare the "Context" class

   // Load 3D model "Tree.ply" with a base position of (0,0,0) and scaled to a height of 5
   std::vector<uint> UUIDs_tree = context.loadPLY( "../../../PLY/Tree.ply", make_vec3(0,0,0), 5, nullrotation, RGB::black );

   // Add a ground surface with a center position of (0,0,0) and size of row_spacing x plant_spacing
   std::vector<uint> UUIDs_ground = context.addTile(make_vec3(0, 0, 0), make_vec2(row_spacing, plant_spacing), nullrotation, make_int2(50, 50));

   // *** 2. Radiation model set-up *** //

   // Declare and initialize the radiation model class
   RadiationModel radiation(&context);

   // Add a sun radiation source with elevation angle of 60 degrees and an azimuth of 45 degrees (note that we need to convert to radians)
   uint sourceID = radiation.addSunSphereRadiationSource( make_SphericalCoord( deg2rad(60), deg2rad(45) ));

   // Add a shortwave radiation band called "PAR" (you can call it anything you want, just be consistent)
   radiation.addRadiationBand("PAR");
   radiation.disableEmission("PAR");   //turn off emission, no emission of primitives in solar bands
   radiation.setSourceFlux( sourceID, "PAR", 500.f );   //set solar flux perpendicular to sun direction of 500 W/m^2
   radiation.setDiffuseRadiationFlux("PAR", 50.f);   //set diffuse (ambient) solar radiation flux of 50 W/m^2

   // We only want the ground to absorb radiation from the top. If we left the default "twosided_flag=1", our ground would absorb diffuse radiation from below
   context.setPrimitiveData(UUIDs_ground, "twosided_flag", uint(0));

   radiation.enforcePeriodicBoundary("xy");  //Use periodic lateral boundaries so we have repeating trees

   radiation.updateGeometry(); //tell the radiation model to load all the geometry in the Context

   // *** 3. Run the model and calculate PAR interception *** //

   radiation.runBand("PAR"); //run the radiation calculations for this band

   // Calculate PAR interception
   float PAR_tree;
   context.calculatePrimitiveDataAreaWeightedSum( UUIDs_tree, "radiation_flux_PAR", PAR_tree ); //sum up absorbed PAR flux for each tree primitive and weight by primitive surface area.
   float PAR_ground;
   context.calculatePrimitiveDataAreaWeightedSum( UUIDs_ground, "radiation_flux_PAR", PAR_ground );  //sum up absorbed PAR flux for each ground primitive and weight by primitive surface area.

   float fPAR = PAR_tree/(PAR_tree+PAR_ground);

   std::cout << "Fraction of intercepted PAR is " << fPAR << std::endl;

   return 0;
 }
 ~~~~~~

 It is generally a good idea to visualize the result to verify that the distribution of values generally makes sense. Code is provided below that can be added to this sample code to visualize the absorbed PAR flux distribution.

 ~~~~~~{.cpp}
 Visualizer visualizer(800);

 visualizer.buildContextGeometry(&context);

 visualizer.colorContextPrimitivesByData( "radiation_flux_PAR" ); //color primitives based on a pseudocolor mapping of primitive data "radiation_flux_PAR" (this is the output primitive data from the radiation model)

 visualizer.setColorbarTitle("PAR flux [W/m^2]" ); //give our colorbar a title

 visualizer.plotInteractive();
 ~~~~~~

 <br>

 \image html Tutorial10_treePAR.png

*/

##################### TUTORIAL 11 #####################

/*! \page radiation_BeersLaw_tutorial Tutorial 11: Light interception and fraction of sunlit/shaded leaf area for a homogeneous canopy

 In this tutorial, we will consider radiation transfer in a homogeneous, horizontally infinite canopy. This canonical canopy case will allow for comparison against theoretical values computed from Beer's law. Our goal will be to simulate the fraction of photosynthetically active radiation (PAR) absorbed by the canopy and the fraction of sunlit/shaded leaf area, and compare the 3D simulated values against Beer's law. This tutorial will integrate the \ref CanopyGeneratorDoc "Canopy Generator" plug-in to create the canopy geometry, and the \ref VoxelIntersectionDoc "Voxel Intersection" plug-in to slice leaves that lie on the canopy boundary.

 \subsection tutorial11_theory 0. Theory

 Beer's law describes the probability that a collimated bean of radiation propagating through a homogeneous medium of particulates is intercepted. For a canopy of leaves, Beer's law can be written as

 \f[\dfrac{R}{R_0}=\left[1-\mathrm{exp}\left(-\dfrac{G\,LAI}{\mathrm{cos}\,\theta_s}\right)\right],\f]

 where \f$R\f$ is the average radiation flux absorbed by the canopy, \f$R_0\f$ is the above-canopy radiation flux on a horizontal surface, \f$R/R_0\f$ is the fraction of absorbed radiation, \f$G\f$ is the fraction of leaf area projected in the direction of the sun, \f$LAI\f$ is the one-sided canopy leaf area per unit ground area, and \f$\theta_s\f$ is the solar zenith angle. The following are the assumptions used to derive this equation: 1) the leaf dimension is "much" smaller than the depth of the canopy layer, 2) the leaf angle distribution is azimuthally isotropic, 3) leaf position is spatially uniform, 4) the canopy extends infinitely in the lateral directions, 5) solar radiation is collimated (i.e., beams are parallel), and 6) leaves absorb all incident radiation.

 Operating under similar assumptions, Beer's law can be integrated to determine the fraction of sunlit leaf area

 \f[f_{sun}=\dfrac{\mathrm{cos}\,\theta_s}{G\,LAI}\left[1-\mathrm{exp}\left(-\dfrac{G\,LAI}{\mathrm{cos}\,\theta_s}\right)\right].\f]

 \subsection tutorial11_geom 1. Model geometry creation

 We will use the \ref CanopyGeneratorDoc "Canopy Generator" plug-in to create a canopy that matches the assumptions inherent in Beer's law described above. This will be a homogeneous canopy with azimuthally isotropic leaf angle distribution that extends infinitely in the horizontal (via applying periodic boundary conditions).

 We start by defining a few variables that will be used later, including parameters specifying the canopy geometry. We'll use a spherical leaf angle distribution, although others are available (also uniform, planophile, erectophile, plagiophile, extremophile). The canopy has an LAI of 1.5 and a height of 1 m. The canopy extends 3x3 m<sup>2</sup> in the horizontal (but will be infinitely extended through periodic boundaries).

 The Context is declared in the usual way. The \ref CanopyGenerator class is then declared and initialized by passing a pointer to the Context. It's job is to add canopy geometry to the Context. The CanopyGenerator::HomogeneousCanopyParameters structure is declared, which is what is used to set the canopy variables. The leaf_angle_distribution, canopy_extent, canopy_height, and leaf_area_index are straight-forward and set based on the variables we declared above (reference the \ref CGenHomogeneous "canopy generator documentation" for the list and meaning of all possible variables).

 The variables "buffer" and "leaf_subdivisions" are both important and less intuitive. We don't want the canopy to extend further than the horizontal extent we've specified (or the ground). This can be dealt with in two ways. One is to add a "buffer" of a half leaf width from the canopy boundaries such that no leaves lie on the boundaries. This is not ideal because it will result in a canopy that is not perfectly periodic. Alternatively, we could add no buffer and crop the canopy exactly to the canopy boundaries, which is what we'll do below. In that case, specify the buffer as "none".

 The "leaf_subdivisions" variable specifies how many sub-patches (rectangles) should be used to represent each leaf. This does not matter much for computing total canopy absorbed radiation, but it is important to have adequate leaf sub-patch resolution to accurately compute the fraction of sunlit leaf area since we need to resolve shadows on leaves. See the references <a href="https://doi.org/10.1029/2020JG005796">Kent and Bailey (2021)</a> and <a href="https://doi.org/10.1093/insilicoplants/diab023">Bailey and Kent (2021)</a> for a detailed investigation. We'll use 5x5=25 sub-patches as a compromise.

 The canopy is built using the \ref CanopyGenerator::buildCanopy() function, which takes the parameter structure we created earlier. UUIDs of leaf primitives in the canopy can be queried using the \ref CanopyGenerator::getLeafUUIDs() function, which we'll store for use in the next step.

 \subsection tutorial11_slice 2. Slicing and cropping primitives on the boundaries

 As introduced above, we have not applied a "buffer" at the canopy boundaries, and thus we have some primitives that extend beyond the intended boundaries. We'll use the \ref VoxelIntersectionDoc "Voxel Intersection" plug-in to crop leaves to the exact location of the boundary, and then use the \ref helios::Context::cropDomain() function to remove remaining leaf segments beyond the boundaries.

 The VoxelIntersection class is declared and initialized in a similar way as other plug-ins by passing a pointer to the Context. It's job will be to slice any primitives lying on the canopy boundaries, which creates two or more triangle primitives with a break along the slicing plane. Two variables are defined that give the (x,y,z) coordinates of the canopy center location and the width of the canopy in the x-, y-, and z-directions:

 ~~~~~~{.cpp}
 vec3 slice_box_center(0,0,0.5f*canopy_height);
 vec3 slice_box_size(canopy_extent.x,canopy_extent.y,canopy_height);
 ~~~~~~

 By default, the canopy is centered at the location (0, 0, 0.5*canopy_height), and as we specified before the dimensions of the canopy are (canopy_extent.x, canopy_extent.y, canopy_height).

 The slicing is performed using the function \ref VoxelIntersection::slicePrimitivesUsingGrid(). This function has the potential to slice based on a sub-divided voxelized grid, but since we only want to slice on the boundaries we'll specify the grid subdivisions as (1, 1, 1) (i.e., not subdivided).

 The \ref helios::Context::cropDomain() function is then used to crop the domain to the canopy boundaries, which will remove leaf segments outside of the specified boundaries. Some of the primitives the Canopy Generator created may no longer exist if the were sliced and/or cropped, and thus the "UUIDs_leaves" contains UUIDs referencing primitives that no longer exist. We can use the helios::Context::getAllUUIDs() function to get all the UUIDs currently in the Context, which at this point only contains leaves.

 Finally, we add a ground surface using the helios::Context::addTile() function. For this particular tutorial, a ground is not explicitly needed because we have no diffuse/scattered radiation that could emanate from below.

 \subsection tutorial11_rad 3. Radiation model set-up

 The set-up of the radiation model is very similar to the \ref radiation_basics "previous tutorial", except for two main differences: 1) we add a collimated radiation source rather than a "sun sphere" to match the assumptions of Beer's law, 2) the solar flux is set to a normalize value of 1.0 since we only compute absorption fractions. A variable defining the sun direction was defined at the beginning of the main() function, which is used to set the direction of the collimated source. It is important to note that the solar flux value of 1.0 that we set for the source is the flux perpendicular to the sun direction, and needs to be multiplied by the cosine of the solar zenith angle to get the flux on a horizontal surface.

 \subsection tutorial11_run 4. Run model and process results

 Radiation model calculations are performed when the \ref RadiationModel::runBand() function is called.

 \subsubsection tutorial11_G 4a. Calculate G(theta)

 In order to apply Beer's law, we need to calculate the G-function (fraction of leaf area projected in the direction of the sun). In this example, we used a spherical leaf angle distribution, in which case G = 0.5 regardless of sun direction. However, if a different leaf angle distribution was used, G would vary with sun angle. Either way, it is a good exercise to calculate this important parameter.

 The G-function is simply the average dot product (absolute value) between the leaf normal and the sun direction. In this example, each leaf element has the same area, but in general this may not be the case, and the average should be area-weighted to avoid biasing toward small primitives. Functions are available to perform each of the necessary operations: a) the \ref helios::Context::getPrimitiveNormal() function returns a unit vector pointing in the direction of the primitive normal, b) the \ref helios::Context::getPrimitiveArea() function returns the primitive surface area, and c) the '*' operator when applied to two vec3's will calculate the dot product.

 Calculation of the G-function based on the 3D geometry can be written as

 \f[G = \sum\limits_i |\vec{n}_i \cdot \vec{n}_s |A_i/\sum\limits_i A_i,\f]

 where \f$\vec{n}_i\f$ is the normal of the i<sup>th</sup> leaf primitive (unit length), \f$\vec{n}_s\f$ is a unit vector pointing in the direction of the sun, and \f$A_i\f$ is the area of the i<sup>th</sup> leaf primitive.

 \subsubsection tutorial11_abs 4b. Calculate radiation flux absorbed by the canopy on a ground area basis

 Beer's law gives the radiation flux absorbed by the canopy on a ground area basis, so we will need to calculate this flux based on the 3D model result. It is important to note that the 3D model gives fluxes on a leaf area basis, which can be converted to ground area basis by multiplying the LAI.

 The flux absorbed by the canopy \f$R\f$ is simply the area-weighted average leaf PAR flux multiplied by the LAI, which can be written as

 \f[R = LAI\sum\limits_i R_i A_i / \sum\limits_i A_i,\f]

 where \f$R_i\f$ is the absorbed PAR flux of the i<sup>th</sup> leaf primitive. The \ref helios::Context::calculatePrimitiveDataAreaWeightedMean() function can be used to easily calculate the area-weighted average of the primitive data "radiation_flux_PAR".

 \subsubsection tutorial11_absBeer 4c. Calculate the theoretical absorbed PAR flux using Beer's law

 The theoretical absorbed PAR flux can be calculated by substituting appropriate values into the equation for Beer's law given above. One important thing to remember is that the radiation flux specified in Helios is the flux on the surface perpendicular to the sun direction, whereas the source flux specified in Beer's law is the flux on a horizontal surface. Thus, the source flux specified in Helios needs to be multiplied by \f$\mathrm{cos}\,\theta_s\f$ to get the flux on a horizontal surface. The \ref helios::cart2sphere() function is used to convert our Cartesian vector specifying the sun direction into a spherical coordinate, from which we can get the zenith angle.

 \subsubsection tutorial11_fsun 4d. Calculate the sunlit leaf area fraction from the simulation

 In order to calculate the fraction of sunlit leaf area for the canopy, we need to determine whether each leaf element is sunlit or shaded. This is tricky because 1) the fully sunlit PAR flux for a given leaf depends on its angle relative to the sun, and 2) many leaves will neither be 100% sunlit or 100% shaded, but somewhere in between. To deal with the first issue, we first calculate what the fully sunlit flux should be for each leaf based on its angle, which is

 \f[R_{sun} = R_{source}|\vec{n} \cdot \vec{n}_s|,\f]

 where \f$R_{source}\f$ is the PAR flux on a plane perpendicular to the sun, and other symbols are as defined above. We then define a "sunlit" leaf as a leaf whose actual absorbed flux is greater than 50% of \f$R_{sun}\f$. We then identify which leaves are "sunlit" according to this definition, and sum their areas. The fraction of sunlit leaf area is then the area of sunlit leaves divided by the total leaf area.

 \subsubsection tutorial11_fsunBeer 4e. Calculate the theoretical sunlit area fraction

 Calculation of the theoretical fraction of sunlit leaf area is simply a matter of plugging values into the equation for \f$f_{sun}\f$ above.

  ~~~~~~{.cpp}
  #include "RadiationModel.h"
  #include "CanopyGenerator.h"
  #include "VoxelIntersection.h"

  using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names

  int main(){

     // !!!!!!!!! Inputs for this example study !!!!!!!!! //

     vec3 sun_direction(1,0,1);                              //Cartesian unit vector pointing in the direction of (toward) the sun
     sun_direction.normalize();

     std::string leaf_angle_dist = "spherical";              //name of leaf angle distribution for the canopy - (spherical, uniform, planophile, erectophile, plagiophile, extremophile)

     float LAI = 1.5f;                                       //one-sided leaf area index of the canopy

     vec2 canopy_extent(3,3);                                //dimension of the canopy in the x- and y-directions (horizontal)
     float canopy_height = 1.f;                              //vertical dimension of the canopy

     // *** 1. Model geometry creation *** //

     Context context;                                        //declare the Context class

     CanopyGenerator cgen(&context);                        //declare the Canopy Generator class and pass it the Context so it can add geometry

     HomogeneousCanopyParameters params;                    //structure containing parameters for homogeneous canopy
     params.buffer = "none";                                 //no buffer on the canopy edges - we will slice along border
     params.leaf_angle_distribution = leaf_angle_dist;       //set the leaf angle distribution based on the variable we set above
     params.canopy_extent = canopy_extent;                   //set the lateral canopy extent based on the variable we set above
     params.canopy_height = canopy_height;                   //set the canopy height based on the variable we set above
     params.leaf_area_index = LAI;                           //set the canopy LAI based on the variable we set above

     params.leaf_subdivisions = make_int2(5,5);              //set the number of subdivisions per leaf to be 5x5=25 primitives

     cgen.buildCanopy(params);                               //build the homogeneous canopy

     std::vector<uint> UUIDs_leaves = cgen.getLeafUUIDs();   //get UUIDs for all leaves in the canopy

     // *** 2. Slicing and cropping primitives on the boundaries *** //

     // slice and primitives that lie on the canopy boundaries (imagine taking a knife and perfectly cutting along the edges of the canopy)
     VoxelIntersection vslice(&context);

     // define variables that give the center (x,y,z) coordinate of the canopy and the overall canopy dimensions
     vec3 slice_box_center(0,0,0.5f*canopy_height);
     vec3 slice_box_size(canopy_extent.x,canopy_extent.y,canopy_height);

     // do the slicing
     vslice.slicePrimitivesUsingGrid( UUIDs_leaves, slice_box_center, slice_box_size, make_int3(1,1,1) );

     // delete any leaf slices that fall outside of the slicing volume
     context.cropDomain( make_vec2(-0.5f*canopy_extent.x,0.5f*canopy_extent.x), make_vec2(-0.5f*canopy_extent.y,0.5f*canopy_extent.y), make_vec2(0,canopy_height) );

     // our UUID vector now contains some primitives that have been deleted. We can just get all the primitives currently in the Context and store them in a vector
     UUIDs_leaves = context.getAllUUIDs();

     //make a ground
     std::vector<uint> UUIDs_ground = context.addTile(make_vec3(0, 0, 0), canopy_extent, nullrotation,make_int2(10, 10));

     // *** 3. Radiation model set-up *** //

     RadiationModel radiation(&context);                      //declare and initialize the radiation model class

     // add a sun source. We'll assume collimated radiation since that is what is assumed in Beer's law
     uint sourceID = radiation.addCollimatedRadiationSource( sun_direction );

     // set up the PAR band. We'll use separate direct and diffuse bands to keep them separate for post-processing (normally you would combine them)
     radiation.addRadiationBand("PAR");
     radiation.disableEmission("PAR");
     radiation.setSourceFlux(sourceID, "PAR", 1.f);  //set a flux of 1.0 W/m^2 to simplify calculations
     radiation.setDiffuseRadiationFlux("PAR", 0.f);      //no diffuse radiation this band

     radiation.enforcePeriodicBoundary("xy");      //use periodic boundary conditions in the horizontal to simulate an infinite canopy

     context.setPrimitiveData(UUIDs_ground, "twosided_flag",uint(0)); //only want ground to intercept/emit radiation from the top

     radiation.updateGeometry();                            //update the geometry in the radiation model

     // 4. Run model and process results //

     //Run the radiation model calculations
     radiation.runBand("PAR");

     // 4a. Calculate G(theta)
     float Gtheta = 0;
     float area_total = 0;
     for( auto UUID : UUIDs_leaves ){
       vec3 normal = context.getPrimitiveNormal(UUID);
       float area = context.getPrimitiveArea(UUID);
       Gtheta += std::abs( sun_direction*normal )*area;
       area_total += area;
     }
     Gtheta = Gtheta/area_total;  //normalize

     std::cout << "G(theta) = " << Gtheta << std::endl;

     // 4b. Calculate radiation flux absorbed by the canopy on a ground area basis - this will end up just being the area-weighted average PAR flux multiplied by LAI.

     float PAR_abs_dir;
     context.calculatePrimitiveDataAreaWeightedMean( UUIDs_leaves, "radiation_flux_PAR", PAR_abs_dir ); //recall that the output primitive data from the radiation model has the form "radiation_flux_[*band_name*]"
     PAR_abs_dir = PAR_abs_dir*LAI; //converts between leaf area basis to ground area basis

     // 4c. Calculate the theoretical absorbed PAR flux using Beer's law

     float theta_s = cart2sphere(sun_direction).zenith;  //calculate the solar zenith angle

     float R0 = cos(theta_s); //PAR flux on horizontal surface
     float intercepted_theoretical_direct = R0*(1.f-exp(-Gtheta*LAI/cos(theta_s)));  //Beer's law

     std::cout << "Calculated interception: " << PAR_abs_dir << std::endl;
     std::cout << "Theoretical interception: " << intercepted_theoretical_direct << std::endl;
     std::cout << "Error of interception: " << std::abs(PAR_abs_dir-intercepted_theoretical_direct)/intercepted_theoretical_direct*100.f << " %" << std::endl;

     // 4d. Calculate the sunlit leaf area fraction from the simulation

     float sunlit_area = 0;
     float total_area = 0;
     for( auto UUID : UUIDs_leaves ){ //looping over all leaf elements

       vec3 normal = context.getPrimitiveNormal(UUID);

       float PARmax = std::abs( normal*sun_direction );  //this is the PAR flux of a leaf with the same normal that is fully sunlit

       float PAR;
       context.getPrimitiveData( UUID, "radiation_flux_PAR", PAR ); //get this leaf's PAR flux

       float fsun_leaf = PAR/PARmax;  //PAR flux as a fraction of the fully sunlit flux

       float area = context.getPrimitiveArea(UUID);

       if( fsun_leaf>0.5 ){ //if fsun is greater than 0.5, we'll call this leaf "sunlit"
         sunlit_area += area;
       }
       total_area += area;

     }

     float fsun = sunlit_area/total_area;

     // 4e. Calculate the theoretical sunlit area fraction

     float fsun_theoretical = cos(theta_s)/(Gtheta*LAI)*(1-exp(-Gtheta*LAI/cos(theta_s)));

     std::cout << "Calculated sunlit fraction: " << fsun << std::endl;
     std::cout << "Theoretical sunlit fraction: " << fsun_theoretical << std::endl;
     std::cout << "Error of sunlit fraction: " << std::abs(fsun-fsun_theoretical)/fsun_theoretical*100.f << " %" << std::endl;

     return 0;
  }
  ~~~~~~

*/

##################### TUTORIAL 12 #####################

/*! \page canopy_WUE_tutorial Tutorial 12: Water-use efficiency (photosyntheses per unit transpiration) for a canopy of spherical crowns

 In this tutorial, we will combine several plugins in order to calculate the water use efficiency (WUE) of a plant canopy. We will calculate WUE at an hourly timestep, updating environmental and radiation inputs as we progress through the day.

 \subsection tutorial12_plugins 1. Loading Plug-ins

 The first thing that we need to do is to specify the plugins that will be included in the simulation framework. For this example, we will use the CanopyGenerator, RadiationModel, EnergyBalanceModel, PhotosynthesisModel, StomatalConductanceModel, SolarPosition, and Visualizer plugins. Make sure that all of these plugins are all included in your CMakeLists.txt file under set( PLUGINS), and that they are also included at the top of your main.cpp file using the #include command.

 \subsection tutorial12_context 2.	Defining the Context

 Now we will need to declare the Context of our simulation. We will also want to define several inputs that will remain constant through subsequent loops, including the date, latitude, longitude, and UTC offset. These values play an important role in determining the position of the sun in our SolarPosition plugin. We will also assign assumed values for atmospheric pressure and turbidity of the air, which will help us to define radiation fluxes later on. For the sake of this Tutorial, we will be assuming that our canopy is located in Davis, CA, and that our simulation takes place on 6/20/2024.

 \subsection tutorial12_geometry 3.	Creating Our Model Geometry

 Next, we will construct a canopy. In this tutorial we will use the CanopyGenerator plugin to create a canopy of ellipsoidal crowns composed of rectangular leaf elements. It is worth noting, however, that there are many ways to construct a canopy. For example, if you want to work with more complicated and/or realistic crowns, you can load in predefined geometries using .xml or .ply files, or you can use the PlantArchitecture model to generate crowns.

 After initializing the plugin, we need to define a number of parameters which will define the geometry of our ellipsoidal crowns. The SphericalCrownsCanopyParameters parameter grouping inside of the canopy generator plugin requires a 3-input vector of float values to define the 3D (x, y, z) dimensions of our crowns using the crown_radius parameter. We will assume that the crowns each have a circular footprint, with the same x  and y dimensions, so will define a single ‘radius’ value that will be used for both of these, but will define a different z dimension ‘height radius’ value. We also need to define the spacing between each of our crowns in both the x and y direction in a 2-input vector of float values using the plant_spacing parameter, so we will define a ‘row spacing’ value, as well as a ‘plant spacing’ value, which will correspond to the x and y dimensions, respectively. For the purposes of this tutorial, we will assume that crowns are immediately next to one another with no extra spacing between them. Since the spacing values are defined going from the center of one crown to the center of its neighbors, we will set these values equal to 2 times the crown radius values that we previously defined. However, if you wished to create greater spacing in either direction, you could easily do so by altering these values. Next, we need to determine the number of rows (in the x dimension) and number of plants per row ( in the y dimension) that we will simulate. For our purposes we will make a 3 x 3 grid of crowns, which will be input as a 2-input vector of integer values using the plant_count parameter. We will also define the size of our leaf elements using a 2-input vector of float values giving the length and width of our leaves using the leaf_size parameter, as well as the number of subdivisions that will be present on each leaf in order to give our models greater resolution in the x and y dimensions of each leaf primitive using a 2-input vector of integer values using the leaf_subdivisions parameter. Finally, we will also define the leaf area density of our crowns (e.g. the m2 leaf area per m3 crown volume).

 We will then use the CanopyGenerator::buildCanopy() function with our parameter inputs to construct our 3x3 grid of ellipsoidal crowns. We will also need to define a vector containing all of our leaf UUIDs, with 1 unique UUID per leaf primitive that we have constructed. In order to do this, we can loop through each of the 9 crowns that we have created, and add all of their leaf UUIDs into a single vector.

 We will also create a ground object, using the CanopyGenerator::buildGround() function. We need to define the ground’s origin (a vec3 3D locator, centered at 0,0,0 in this case), its size (a vec2 x/y extent indicator, which will have an x length = our row spacing multiplied by the number of rows that we have, and a y length = our plant spacing multiplied by the number of plants per row that we have), as well as a number of ground patches (which we will set equal to the number of crowns) and the number of subpatches that we will have on our ground object, each as a vec2 of integer values.

 \subsection tutorial12_solarposition 4. Setting Up the Solar Position Model

  Now that we have defined our environmental conditions for the current hour, we can begin setting up the plugin models. We will start with the SolarPosition model. The position of the sun will automatically be determined when we initialize the plugin by calling the SolarPosition class with inputs of our predefined UTC offset, latitude, longitude, and a pointer to the context, which will call the time value which was set during the previous step.

  We will also separate our total radiation flux out into three bands: 1) longwave (LW), which can be determined using the SolarPosition::getAmbientLongwaveFlux() function with inputs of air temperature and relative humidity, and 2) photosynthetically active radiation (PAR) and 3) near-infrared radiation (NIR), both of which can be determined with inputs of atmospheric pressure, air temperature, relative humidity, and turbidity using the SolarPosition::getSolarFluxPAR() and SolarPosition::getSolarFluxNIR() functions, respectively.

  For these latter two bands, we will also calculate the fraction of incoming radiation which will come from diffuse environmental sources, rather than direct radiation from the sun source.

  \subsection tutorial12_radiation 5. Setting Up the Radiation Model

  Now that we have the solar position and flux values for each of our radiation bands, we can initialize the RadiationModel class.

  We will then create the sun source in our simulation using the solar position value that we determined in the previous step as a pointer in the RadiationModel::addsolar_positionSphereRadiationSource() function. We will also add in the three bands that we previously defined using RadiationModel::addRadiationBand(). For the PAR and NIR bands we will disable emission because terrestrial objects do not emit radiation in these bands. We will set the total flux coming from the sun and from diffuse radiation separately for these bands using RadiationModel::setSourceFlux() and RadiationModel::setDiffuseRadiationFlux(), respectively, and will use RadiationModel::setScatteringDepth() equal to 3 in order to track each ray through reflection and transmission after it has intercepted with 3 surfaces in the context geometry.

  Next, we will call RadiationModel::enforcePeriodicBoundary("xy"), which will treat the context geometry as though it repeats infinitely in x and y dimensions (e.g. the canopy geometry that we created will be surrounded on all sides by an identical canopy). We will then set the radiation properties of the primitives in our geometry. We will set the reflectivity and transmissivity radiation in both PAR and NIR bands for leaf UUIDs. Ground UUIDs need only have reflectivity set, as they will not transmit light. We will also set the ground UUIDs “twosided_flag” to 0 because atmospheric radiation will only be intercepted on the top.

  We will also call RadiationModel::updateGeometry() in order to make sure that the radiation model fully accounts for the primitive geometry that we have constructed in the context. Note that unless the geometry changes, we only need to call this once. This function is very computationally heavy, so calling it unnecessarily (such as within a loop) will make the code slow.

  \subsection tutorial12_energybalance 6. Setting Up the Energy Balance Model

  Now we need to initialize the EnergyBalanceModel, and add each of the three radiation bands that we created in the previous steps using the EnergyBalanceModel::addRadiationBand() function.

  \subsection tutorial12_gs 7.Setting Up the Stomatal Conductance Model

  Now we will initialize the stomatal conductance model plugin, which will allow us to define the way that stomatal conductance will vary with environmental inputs. There are a number of different models that we can choose from, as described in the documentation, but for our purposes we will use the Buckley, Mott, and Farquhar model by calling BMFcoefficients. This requires 4 parameter inputs, which vary with your species of interest. Here we will use the default parameter values, which are fitted to almond stomatal conductance measurements.

  \subsection tutorial12_photosynthesis 8. Setting Up the Photosynthesis Model

  Finally, we need to initialize the photosynthesis model plugin, which will allow us to find the carbon assimilated during each timestep in our simulation. Again, there are a number of different models that can be chosen from, but we will use the Farquhar model in this instance.

 \subsection tutorial12_timeseries 9. Reading in Our Timeseries Data

 Now we need to define the environmental conditions present in the canopy at each hour. We will use an .xml file with air temperature, relative humidity, and windspeed data pulled from the Davis CIMIS station.

 We will be calculating WUE during each hour in the day and will need to run all of our plugins iteratively during each hour, so we will now set up a for-loop to iterate through the day at an hourly timestep.

 Next, during each hour within the for-loop, we will set the time within the context of our simulation and will query our .xml file to find the air temperature, relative humidity, and windspeed.

 \subsection tutorial12_run 10.	Running the Model Calculations

 Now that all of the plugins have been set up, we can run the models. We will start by running each of our three radiation bands using RadiationModel::runBand(). Next, we can run the stomatal conductance plugin using StomatalConductanceModel::run() for all of our leaf UUIDs, followed by running the energy balance plugin using EnergyBalanceModel::run(). It should be noted at this point that the stomatal conductance and energy balance plugins will be run using the default primitive temperature values, so we should re-run our longwave band, the stomatal conductance model, and the energy balance model in order to get more accurate temperature values updated based on the environmental data and its interactions with latent heat from transpiration and the overall energy balance. This could be done several times if desired, but we will only repeat once for our purposes here.

 Finally, we can run the photosynthesis plugin using PhotosynthesisModel::run() for all of our leaf UUIDs.

 \subsection tutorial12_WUE 11.	Calculating WUE

 Now that we have run all of our plugins, we can recover our outputs for the timestep. For water use efficiency, we will need to get an overall transpiration value canopy as well as an overall carbon assimilation value.  In order to do so, we can loop over each of the leaf UUIDs in our context and retrieve ‘latent flux’ and ‘net photosynthesis’ values for each primitive using context::getPrimitiveData(). We can find the overall canopy values for each by multiplying each leaf’s value by the leaf area and then summing all of the leaves’ values together. To convert our retrieved latent flux value from W/m2 to mol H2O / second we can divide the latent flux by 44000, and then can multiply that value by 1000 to get mmol H2O / second.
 We can also calculate WUE for individual leaf elements by dividing our leaf primitive assimilation rate by our leaf primitive transpiration rate in order to get the WUE in μmol CO2 / mmol H2O. We can assign this value as new primitive data for each of the leaf elements using context::setPrimitiveData() so that we can make a visualization showing variation of WUE throughout the canopy later on.

 Once we have completed our loop, we can divide our overall canopy assimilation rate by our canopy transpiration rate in order to get the WUE in μmol CO2 / mmol H2O. This will give us the overall canopy WUE for each hour.

 \subsection tutorial12_visualization 12. Visualization

 We can wrap up by creating an hourly visualization that will show the 3D variation of WUE throughout our canopy using the visualizer plugin. After initializing the plugin, we just need to set the Visualizer::setContextPrimitivesByData() function to the WUE primitive data that we assigned during the previous step.

 \subsection tutorial12_code Code

 The code below gives a full example of the above steps. Note that this code requires the input XML file '6_20_2024_CIMIS.xml'. The code below assumes that it is located in a sub-folder of the project directory called 'xml'. Modify the code as needed depending on where you place the file. It can be downloaded here: <a href="https://baileylab.ucdavis.edu/software/tutorialfiles/6_20_2024_CIMIS.xml">right-click and select "Download Linked File" or "Save As"</a>.

 ~~~~~{.cpp}

 // *** Step 1: Loading Plugins *** //

 #include "CanopyGenerator.h"
 #include "RadiationModel.h"
 #include "EnergyBalanceModel.h"
 #include "PhotosynthesisModel.h"
 #include "StomatalConductanceModel.h"
 #include "SolarPosition.h"
 #include "BoundaryLayerConductanceModel.h"
 #include "Visualizer.h"

 using namespace helios;

 int main() {

     // *** Step 2: Defining the Context *** //

     Context context;

     //Set Date
     Date date(20, 6, 2024);
     context.setDate(date);

     //Define location and timezone
     float latitude = 38.535694;
     float longitude = 121.776360;
     int UTC = 7;

     //Atmospheric Constants
     float pressure = 101300; //Atmospheric Pressure, Pa
     float turbidity = 0.05;

     // *** Step 3: Creating Our Model Geometry *** //

     // Build the Canopy //
     CanopyGenerator canopygenerator(&context);

     std::vector<uint> leaf_UUIDs;

     float crown_radius = 1.5; //meters
     float crown_height_radius = 3.; //meters

     float spacing_row = 2 * crown_radius;
     float spacing_plant = 2 * crown_radius;

     int row_number = 3; //number of rows
     int plant_number = 3; //number of plants per row

     float l_leaf = 0.075; //leaf length
     float w_leaf = 0.05; //leaf width

     //Leaf and canopy parameters
     SphericalCrownsCanopyParameters params;
     params.crown_radius = make_vec3(crown_radius, crown_radius, crown_height_radius);
     params.plant_spacing = make_vec2(spacing_row, spacing_plant);
     params.plant_count = make_int2(row_number, plant_number);
     params.leaf_size = make_vec2(l_leaf, w_leaf);
     params.leaf_subdivisions = make_int2(3, 3);
     params.leaf_area_density = 1.f;

     //Create the crowns
     canopygenerator.buildCanopy(params);

     //Get the UUID numbers for all of the leaves
     leaf_UUIDs = canopygenerator.getLeafUUIDs();

     //ground parameters
     float x_ground = spacing_row*row_number;
     float y_ground = spacing_plant*plant_number;
     vec2 size_ground = make_vec2(x_ground, y_ground);

     //Make the Ground
     canopygenerator.buildGround(make_vec3(0,0,0), size_ground, make_int2(row_number,plant_number), make_int2(3,3), "plugins/canopygenerator/textures/dirt.jpg");

     //Ground UUIDs
     std::vector<uint> ground_UUIDs = canopygenerator.getGroundUUIDs();
     //UUIDs of all primitives in the context
     std::vector<uint> all_UUIDs = context.getAllUUIDs();

     // *** Step 4: Setting Up the Solar Position Model *** //

     SolarPosition solar_position(UTC, latitude, longitude, &context);

     // *** Step 5: Setting Up the Radiation Model *** //
     RadiationModel radiation(&context);

     uint SunSource = radiation.addSunSphereRadiationSource();

     radiation.addRadiationBand("PAR");
     radiation.disableEmission("PAR");
     radiation.setScatteringDepth("PAR", 3);

     radiation.addRadiationBand("NIR");
     radiation.disableEmission("NIR");
     radiation.setScatteringDepth("NIR", 3);

     radiation.addRadiationBand("LW");

     radiation.enforcePeriodicBoundary("xy");

     //Set leaf radiative properties
     context.setPrimitiveData(leaf_UUIDs, "reflectivity_PAR", 0.10f);
     context.setPrimitiveData(leaf_UUIDs, "transmissivity_PAR", 0.05f);
     context.setPrimitiveData(leaf_UUIDs, "reflectivity_NIR", 0.45f);
     context.setPrimitiveData(leaf_UUIDs, "transmissivity_NIR", 0.4f);

     context.setPrimitiveData(ground_UUIDs, "reflectivity_PAR", 0.15f);
     context.setPrimitiveData(ground_UUIDs, "reflectivity_NIR", 0.4f);

     //Make sure that the ground is only able to intercept radiation from the top
     context.setPrimitiveData(ground_UUIDs, "twosided_flag", uint(0));

     radiation.updateGeometry();

     //*** Step 6: Setting Up the Energy Balance Model ***//

     EnergyBalanceModel energybalance(&context);

     energybalance.addRadiationBand("PAR");
     energybalance.addRadiationBand("NIR");
     energybalance.addRadiationBand("LW");

     BLConductanceModel boundarylayerconductance(&context);

     boundarylayerconductance.setBoundaryLayerModel( ground_UUIDs, "Ground" );
     boundarylayerconductance.setBoundaryLayerModel( leaf_UUIDs, "Pohlhausen" );

     //*** Step 7: Setting Up the Stomatal Conductance Model ***//

     StomatalConductanceModel stomatalconductance(&context);

     BMFcoefficients bmfc;
     stomatalconductance.setModelCoefficients(bmfc);

     //*** Step 8: Setting Up Photosynthesis Model ***//

     PhotosynthesisModel photosynthesis(&context);

     FarquharModelCoefficients photoparams;
     photosynthesis.setModelCoefficients(photoparams);
     photosynthesis.setModelType_Farquhar();

     // *** Step 9: Reading in Our Timeseries Data *** //

     context.loadXML("../xml/6_20_2024_CIMIS.xml");

     for( int hour = 7; hour<18; hour++){

         Time time(hour, 0, 0);
         context.setTime(time);

         // this will query these timseries variables based on the date and time set in the Context
         float air_temperature = context.queryTimeseriesData("air_temperature"); // degrees C
         float air_humidity = context.queryTimeseriesData("humidity"); // Percent
         float wind_speed = context.queryTimeseriesData("wind_speed"); // m/s

         // update our primitive data values on each timestep based on timeseries data
         context.setPrimitiveData(all_UUIDs, "air_temperature", air_temperature);
         context.setPrimitiveData(all_UUIDs, "air_humidity", air_humidity);
         context.setPrimitiveData(all_UUIDs, "wind_speed", wind_speed);

         float LW = solar_position.getAmbientLongwaveFlux(air_temperature, air_humidity);
         float PAR = solar_position.getSolarFluxPAR(pressure, air_temperature, air_humidity, turbidity);
         float NIR = solar_position.getSolarFluxNIR(pressure, air_temperature, air_humidity, turbidity);
         float f_diff = solar_position.getDiffuseFraction(pressure, air_temperature, air_humidity, turbidity);

         radiation.setSourceFlux(SunSource, "NIR", NIR * (1.f - f_diff));
         radiation.setDiffuseRadiationFlux("NIR", NIR * f_diff);
         radiation.setSourceFlux(SunSource, "PAR", PAR * (1.f - f_diff));
         radiation.setDiffuseRadiationFlux("PAR", PAR * f_diff);
         radiation.setDiffuseRadiationFlux("LW", LW);

         radiation.setSourcePosition( SunSource, solar_position.getSunDirectionVector() );

         boundarylayerconductance.run();

         // *** Step 10: Running the Model *** //

         radiation.runBand({"PAR","NIR","LW"});

         stomatalconductance.run(leaf_UUIDs);
         energybalance.run();

         //Run the longwave band, stomatal conductance plugin, and energy balance plugin again to update primitive temperature values
         radiation.runBand("LW");
         stomatalconductance.run(leaf_UUIDs);
         energybalance.run();

         photosynthesis.run(leaf_UUIDs); // always run this last, since nothing depends on it

         // *** Step 11: Calculating WUE ***//

         float A_canopy = 0;
         float E_canopy = 0;
         for (uint UUID : leaf_UUIDs) {
             float E, A, WUE;
             context.getPrimitiveData(UUID, "latent_flux", E);
             context.getPrimitiveData(UUID, "net_photosynthesis", A);
             E_canopy += E / 44000 * 1000; // mmol H2O / m^2 / sec
             A_canopy += A;  //umol CO2 / m^2 / sec

             WUE = A / (E / 44000 * 1000); //umol CO2/mmol H2O
             context.setPrimitiveData(UUID, "WUE", WUE);

         }
         float WUE_canopy = A_canopy / E_canopy; //umol CO2/mmol H2O

         std::cout << "WUE of the canopy = " << WUE_canopy << " umol CO2/mmol H2O" << std::endl;

         // *** Step 12: Visualization *** //
         // This will open the visualizer window for each time step. Close it to proceed to the next time step.
         Visualizer visualizer(1000);
         visualizer.buildContextGeometry(&context);
         visualizer.colorContextPrimitivesByData( "WUE" );
         visualizer.setColorbarTitle("WUE (umol CO2/mmol H2O)");;
         visualizer.setColorbarRange(0.f,15.f);
         visualizer.setColorbarPosition(make_vec3(0.75, 0.9, 0) );
         char time_string[6];
         sprintf(time_string, "%02d:%02d", time.hour, time.minute);
         visualizer.addTextboxByCenter( time_string, make_vec3(0.5,0.9,0), nullrotation, RGB::black, 16, "Arial", Visualizer::COORDINATES_WINDOW_NORMALIZED );
         visualizer.plotInteractive(); // !!! Close the window to advance to the next time step

     }

     return 0;
 }

 ~~~~~

*/