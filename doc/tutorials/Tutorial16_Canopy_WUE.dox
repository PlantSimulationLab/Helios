/*! \page canopy_WUE_tutorial Tutorial 16: Water-use efficiency (photosyntheses per unit transpiration) for a canopy of spherical crowns

 In this tutorial, we will combine several plugins in order to calculate the water use efficiency (WUE) of a plant canopy. We will calculate WUE at an hourly timestep, updating environmental and radiation inputs as we progress through the day.

 \section tutorial16_plugins 1. Loading Plug-ins

 The first thing that we need to do is to specify the plugins that will be included in the simulation framework. For this example, we will use the CanopyGenerator, RadiationModel, EnergyBalanceModel, PhotosynthesisModel, StomatalConductanceModel, SolarPosition, and Visualizer plugins. Make sure that all of these plugins are all included in your CMakeLists.txt file under set( PLUGINS), and that they are also included at the top of your main.cpp file using the #include command.

 \section tutorial16_context 2.	Defining the Context

 Now we will need to declare the Context of our simulation. We will also want to define several inputs that will remain constant through subsequent loops, including the date, latitude, longitude, and UTC offset. These values play an important role in determining the position of the sun in our SolarPosition plugin. We will also assign assumed values for atmospheric pressure and turbidity of the air, which will help us to define radiation fluxes later on. For the sake of this Tutorial, we will be assuming that our canopy is located in Davis, CA, and that our simulation takes place on 6/20/2024.

 \section tutorial16_geometry 3.	Creating Our Model Geometry

 Next, we will construct a canopy. In this tutorial we will use the CanopyGenerator plugin to create a canopy of ellipsoidal crowns composed of rectangular leaf elements. It is worth noting, however, that there are many ways to construct a canopy. For example, if you want to work with more complicated and/or realistic crowns, you can load in predefined geometries using .xml or .ply files, or you can use the PlantArchitecture model to generate crowns.

 After initializing the plugin, we need to define a number of parameters which will define the geometry of our ellipsoidal crowns. The SphericalCrownsCanopyParameters parameter grouping inside of the canopy generator plugin requires a 3-input vector of float values to define the 3D (x, y, z) dimensions of our crowns using the crown_radius parameter. We will assume that the crowns each have a circular footprint, with the same x  and y dimensions, so will define a single ‘radius’ value that will be used for both of these, but will define a different z dimension ‘height radius’ value. We also need to define the spacing between each of our crowns in both the x and y direction in a 2-input vector of float values using the plant_spacing parameter, so we will define a ‘row spacing’ value, as well as a ‘plant spacing’ value, which will correspond to the x and y dimensions, respectively. For the purposes of this tutorial, we will assume that crowns are immediately next to one another with no extra spacing between them. Since the spacing values are defined going from the center of one crown to the center of its neighbors, we will set these values equal to 2 times the crown radius values that we previously defined. However, if you wished to create greater spacing in either direction, you could easily do so by altering these values. Next, we need to determine the number of rows (in the x dimension) and number of plants per row ( in the y dimension) that we will simulate. For our purposes we will make a 3 x 3 grid of crowns, which will be input as a 2-input vector of integer values using the plant_count parameter. We will also define the size of our leaf elements using a 2-input vector of float values giving the length and width of our leaves using the leaf_size parameter, as well as the number of subdivisions that will be present on each leaf in order to give our models greater resolution in the x and y dimensions of each leaf primitive using a 2-input vector of integer values using the leaf_subdivisions parameter. Finally, we will also define the leaf area density of our crowns (e.g. the m2 leaf area per m3 crown volume).

 We will then use the CanopyGenerator::buildCanopy() function with our parameter inputs to construct our 3x3 grid of ellipsoidal crowns. We will also need to define a vector containing all of our leaf UUIDs, with 1 unique UUID per leaf primitive that we have constructed. In order to do this, we can loop through each of the 9 crowns that we have created, and add all of their leaf UUIDs into a single vector.

 We will also create a ground object, using the CanopyGenerator::buildGround() function. We need to define the ground’s origin (a vec3 3D locator, centered at 0,0,0 in this case), its size (a vec2 x/y extent indicator, which will have an x length = our row spacing multiplied by the number of rows that we have, and a y length = our plant spacing multiplied by the number of plants per row that we have), as well as a number of ground patches (which we will set equal to the number of crowns) and the number of subpatches that we will have on our ground object, each as a vec2 of integer values.

 \section tutorial16_solarposition 4. Setting Up the Solar Position Model

  Now that we have defined our environmental conditions for the current hour, we can begin setting up the plugin models. We will start with the SolarPosition model. The position of the sun will automatically be determined when we initialize the plugin by calling the SolarPosition class with inputs of our predefined UTC offset, latitude, longitude, and a pointer to the context, which will call the time value which was set during the previous step.

  We will also separate our total radiation flux out into three bands: 1) longwave (LW), which can be determined using the SolarPosition::getAmbientLongwaveFlux() function with inputs of air temperature and relative humidity, and 2) photosynthetically active radiation (PAR) and 3) near-infrared radiation (NIR), both of which can be determined with inputs of atmospheric pressure, air temperature, relative humidity, and turbidity using the SolarPosition::getSolarFluxPAR() and SolarPosition::getSolarFluxNIR() functions, respectively.

  For these latter two bands, we will also calculate the fraction of incoming radiation which will come from diffuse environmental sources, rather than direct radiation from the sun source.

  \section tutorial16_radiation 5. Setting Up the Radiation Model

  Now that we have the solar position and flux values for each of our radiation bands, we can initialize the RadiationModel class.

  We will then create the sun source in our simulation using the solar position value that we determined in the previous step as a pointer in the RadiationModel::addsolar_positionSphereRadiationSource() function. We will also add in the three bands that we previously defined using RadiationModel::addRadiationBand(). For the PAR and NIR bands we will disable emission because terrestrial objects do not emit radiation in these bands. We will set the total flux coming from the sun and from diffuse radiation separately for these bands using RadiationModel::setSourceFlux() and RadiationModel::setDiffuseRadiationFlux(), respectively, and will use RadiationModel::setScatteringDepth() equal to 3 in order to track each ray through reflection and transmission after it has intercepted with 3 surfaces in the context geometry.

  Next, we will call RadiationModel::enforcePeriodicBoundary("xy"), which will treat the context geometry as though it repeats infinitely in x and y dimensions (e.g. the canopy geometry that we created will be surrounded on all sides by an identical canopy). We will then set the radiation properties of the primitives in our geometry. We will set the reflectivity and transmissivity radiation in both PAR and NIR bands for leaf UUIDs. Ground UUIDs need only have reflectivity set, as they will not transmit light. We will also set the ground UUIDs “twosided_flag” to 0 because atmospheric radiation will only be intercepted on the top.

  We will also call RadiationModel::updateGeometry() in order to make sure that the radiation model fully accounts for the primitive geometry that we have constructed in the context. Note that unless the geometry changes, we only need to call this once. This function is very computationally heavy, so calling it unnecessarily (such as within a loop) will make the code slow.

  \section tutorial16_energybalance 6. Setting Up the Energy Balance Model

  Now we need to initialize the EnergyBalanceModel, and add each of the three radiation bands that we created in the previous steps using the EnergyBalanceModel::addRadiationBand() function.

  \section tutorial16_gs 7.Setting Up the Stomatal Conductance Model

  Now we will initialize the stomatal conductance model plugin, which will allow us to define the way that stomatal conductance will vary with environmental inputs. There are a number of different models that we can choose from, as described in the documentation, but for our purposes we will use the Buckley, Mott, and Farquhar model by calling BMFcoefficients. This requires 4 parameter inputs, which vary with your species of interest. Here we will use the default parameter values, which are fitted to almond stomatal conductance measurements.

  \section tutorial16_photosynthesis 8. Setting Up the Photosynthesis Model

  Finally, we need to initialize the photosynthesis model plugin, which will allow us to find the carbon assimilated during each timestep in our simulation. Again, there are a number of different models that can be chosen from, but we will use the Farquhar model in this instance.

 \section tutorial16_timeseries 9. Reading in Our Timeseries Data

 Now we need to define the environmental conditions present in the canopy at each hour. We will use an .xml file with air temperature, relative humidity, and windspeed data pulled from the Davis CIMIS station.

 We will be calculating WUE during each hour in the day and will need to run all of our plugins iteratively during each hour, so we will now set up a for-loop to iterate through the day at an hourly timestep.

 Next, during each hour within the for-loop, we will set the time within the context of our simulation and will query our .xml file to find the air temperature, relative humidity, and windspeed.

 \section tutorial16_run 10.	Running the Model Calculations

 Now that all of the plugins have been set up, we can run the models. We will start by running each of our three radiation bands using RadiationModel::runBand(). Next, we can run the stomatal conductance plugin using StomatalConductanceModel::run() for all of our leaf UUIDs, followed by running the energy balance plugin using EnergyBalanceModel::run(). It should be noted at this point that the stomatal conductance and energy balance plugins will be run using the default primitive temperature values, so we should re-run our longwave band, the stomatal conductance model, and the energy balance model in order to get more accurate temperature values updated based on the environmental data and its interactions with latent heat from transpiration and the overall energy balance. This could be done several times if desired, but we will only repeat once for our purposes here.

 Finally, we can run the photosynthesis plugin using PhotosynthesisModel::run() for all of our leaf UUIDs.

 \section tutorial16_WUE 11.	Calculating WUE

 Now that we have run all of our plugins, we can recover our outputs for the timestep. For water use efficiency, we will need to get an overall transpiration value canopy as well as an overall carbon assimilation value.  In order to do so, we can loop over each of the leaf UUIDs in our context and retrieve ‘latent flux’ and ‘net photosynthesis’ values for each primitive using context::getPrimitiveData(). We can find the overall canopy values for each by multiplying each leaf’s value by the leaf area and then summing all of the leaves’ values together. To convert our retrieved latent flux value from W/m2 to mol H2O / second we can divide the latent flux by 44000, and then can multiply that value by 1000 to get mmol H2O / second.
 We can also calculate WUE for individual leaf elements by dividing our leaf primitive assimilation rate by our leaf primitive transpiration rate in order to get the WUE in μmol CO2 / mmol H2O. We can assign this value as new primitive data for each of the leaf elements using context::setPrimitiveData() so that we can make a visualization showing variation of WUE throughout the canopy later on.

 Once we have completed our loop, we can divide our overall canopy assimilation rate by our canopy transpiration rate in order to get the WUE in μmol CO2 / mmol H2O. This will give us the overall canopy WUE for each hour.

 \section tutorial16_visualization 12. Visualization

 We can wrap up by creating an hourly visualization that will show the 3D variation of WUE throughout our canopy using the visualizer plugin. After initializing the plugin, we just need to set the Visualizer::setContextPrimitivesByData() function to the WUE primitive data that we assigned during the previous step.

 \section tutorial16_code Code

 The code below gives a full example of the above steps. Note that this code requires the input XML file '6_20_2024_CIMIS.xml'. The code below assumes that it is located in a sub-folder of the project directory called 'xml'. Modify the code as needed depending on where you place the file. It can be downloaded here: <a href="https://baileylab.ucdavis.edu/software/tutorialfiles/6_20_2024_CIMIS.xml">right-click and select "Download Linked File" or "Save As"</a>.

 ~~~~~{.cpp}

 // *** Step 1: Loading Plugins *** //

 #include "CanopyGenerator.h"
 #include "RadiationModel.h"
 #include "EnergyBalanceModel.h"
 #include "PhotosynthesisModel.h"
 #include "StomatalConductanceModel.h"
 #include "SolarPosition.h"
 #include "BoundaryLayerConductanceModel.h"
 #include "Visualizer.h"

 using namespace helios;

 int main() {

     // *** Step 2: Defining the Context *** //

     Context context;

     //Set Date
     Date date(20, 6, 2024);
     context.setDate(date);

     //Define location and timezone
     float latitude = 38.535694;
     float longitude = 121.776360;
     int UTC = 7;

     //Atmospheric Constants
     float pressure = 101300; //Atmospheric Pressure, Pa
     float turbidity = 0.05;

     // *** Step 3: Creating Our Model Geometry *** //

     // Build the Canopy //
     CanopyGenerator canopygenerator(&context);

     std::vector<uint> leaf_UUIDs;

     float crown_radius = 1.5; //meters
     float crown_height_radius = 3.; //meters

     float spacing_row = 2 * crown_radius;
     float spacing_plant = 2 * crown_radius;

     int row_number = 3; //number of rows
     int plant_number = 3; //number of plants per row

     float l_leaf = 0.075; //leaf length
     float w_leaf = 0.05; //leaf width

     //Leaf and canopy parameters
     SphericalCrownsCanopyParameters params;
     params.crown_radius = make_vec3(crown_radius, crown_radius, crown_height_radius);
     params.plant_spacing = make_vec2(spacing_row, spacing_plant);
     params.plant_count = make_int2(row_number, plant_number);
     params.leaf_size = make_vec2(l_leaf, w_leaf);
     params.leaf_subdivisions = make_int2(3, 3);
     params.leaf_area_density = 1.f;

     //Create the crowns
     canopygenerator.buildCanopy(params);

     //Get the UUID numbers for all of the leaves
     leaf_UUIDs = canopygenerator.getLeafUUIDs();

     //ground parameters
     float x_ground = spacing_row*row_number;
     float y_ground = spacing_plant*plant_number;
     vec2 size_ground = make_vec2(x_ground, y_ground);

     //Make the Ground
     canopygenerator.buildGround(make_vec3(0,0,0), size_ground, make_int2(row_number,plant_number), make_int2(3,3), "plugins/canopygenerator/textures/dirt.jpg");

     //Ground UUIDs
     std::vector<uint> ground_UUIDs = canopygenerator.getGroundUUIDs();
     //UUIDs of all primitives in the context
     std::vector<uint> all_UUIDs = context.getAllUUIDs();

     // *** Step 4: Setting Up the Solar Position Model *** //

     SolarPosition solar_position(UTC, latitude, longitude, &context);

     // *** Step 5: Setting Up the Radiation Model *** //
     RadiationModel radiation(&context);

     uint SunSource = radiation.addSunSphereRadiationSource();

     radiation.addRadiationBand("PAR");
     radiation.disableEmission("PAR");
     radiation.setScatteringDepth("PAR", 3);

     radiation.addRadiationBand("NIR");
     radiation.disableEmission("NIR");
     radiation.setScatteringDepth("NIR", 3);

     radiation.addRadiationBand("LW");

     radiation.enforcePeriodicBoundary("xy");

     //Set leaf radiative properties
     context.setPrimitiveData(leaf_UUIDs, "reflectivity_PAR", 0.10f);
     context.setPrimitiveData(leaf_UUIDs, "transmissivity_PAR", 0.05f);
     context.setPrimitiveData(leaf_UUIDs, "reflectivity_NIR", 0.45f);
     context.setPrimitiveData(leaf_UUIDs, "transmissivity_NIR", 0.4f);

     context.setPrimitiveData(ground_UUIDs, "reflectivity_PAR", 0.15f);
     context.setPrimitiveData(ground_UUIDs, "reflectivity_NIR", 0.4f);

     //Make sure that the ground is only able to intercept radiation from the top
     context.setPrimitiveData(ground_UUIDs, "twosided_flag", uint(0));

     radiation.updateGeometry();

     //*** Step 6: Setting Up the Energy Balance Model ***//

     EnergyBalanceModel energybalance(&context);

     energybalance.addRadiationBand("PAR");
     energybalance.addRadiationBand("NIR");
     energybalance.addRadiationBand("LW");

     BLConductanceModel boundarylayerconductance(&context);

     boundarylayerconductance.setBoundaryLayerModel( ground_UUIDs, "Ground" );
     boundarylayerconductance.setBoundaryLayerModel( leaf_UUIDs, "Pohlhausen" );

     //*** Step 7: Setting Up the Stomatal Conductance Model ***//

     StomatalConductanceModel stomatalconductance(&context);

     BMFcoefficients bmfc;
     stomatalconductance.setModelCoefficients(bmfc);

     //*** Step 8: Setting Up Photosynthesis Model ***//

     PhotosynthesisModel photosynthesis(&context);

     FarquharModelCoefficients photoparams;
     photosynthesis.setModelCoefficients(photoparams);
     photosynthesis.setModelType_Farquhar();

     // *** Step 9: Reading in Our Timeseries Data *** //

     context.loadXML("../xml/6_20_2024_CIMIS.xml");

     for( int hour = 7; hour<18; hour++){

         Time time(hour, 0, 0);
         context.setTime(time);

         // this will query these timseries variables based on the date and time set in the Context
         float air_temperature = context.queryTimeseriesData("air_temperature"); // degrees C
         float air_humidity = context.queryTimeseriesData("humidity"); // Percent
         float wind_speed = context.queryTimeseriesData("wind_speed"); // m/s

         // update our primitive data values on each timestep based on timeseries data
         context.setPrimitiveData(all_UUIDs, "air_temperature", air_temperature);
         context.setPrimitiveData(all_UUIDs, "air_humidity", air_humidity);
         context.setPrimitiveData(all_UUIDs, "wind_speed", wind_speed);

         float LW = solar_position.getAmbientLongwaveFlux(air_temperature, air_humidity);
         float PAR = solar_position.getSolarFluxPAR(pressure, air_temperature, air_humidity, turbidity);
         float NIR = solar_position.getSolarFluxNIR(pressure, air_temperature, air_humidity, turbidity);
         float f_diff = solar_position.getDiffuseFraction(pressure, air_temperature, air_humidity, turbidity);

         radiation.setSourceFlux(SunSource, "NIR", NIR * (1.f - f_diff));
         radiation.setDiffuseRadiationFlux("NIR", NIR * f_diff);
         radiation.setSourceFlux(SunSource, "PAR", PAR * (1.f - f_diff));
         radiation.setDiffuseRadiationFlux("PAR", PAR * f_diff);
         radiation.setDiffuseRadiationFlux("LW", LW);

         radiation.setSourcePosition( SunSource, solar_position.getSunDirectionVector() );

         boundarylayerconductance.run();

         // *** Step 10: Running the Model *** //

         radiation.runBand({"PAR","NIR","LW"});

         stomatalconductance.run(leaf_UUIDs);
         energybalance.run();

         //Run the longwave band, stomatal conductance plugin, and energy balance plugin again to update primitive temperature values
         radiation.runBand("LW");
         stomatalconductance.run(leaf_UUIDs);
         energybalance.run();

         photosynthesis.run(leaf_UUIDs); // always run this last, since nothing depends on it

         // *** Step 11: Calculating WUE ***//

         float A_canopy = 0;
         float E_canopy = 0;
         for (uint UUID : leaf_UUIDs) {
             float E, A, WUE;
             context.getPrimitiveData(UUID, "latent_flux", E);
             context.getPrimitiveData(UUID, "net_photosynthesis", A);
             E_canopy += E / 44000 * 1000; // mmol H2O / m^2 / sec
             A_canopy += A;  //umol CO2 / m^2 / sec

             WUE = A / (E / 44000 * 1000); //umol CO2/mmol H2O
             context.setPrimitiveData(UUID, "WUE", WUE);

         }
         float WUE_canopy = A_canopy / E_canopy; //umol CO2/mmol H2O

         std::cout << "WUE of the canopy = " << WUE_canopy << " umol CO2/mmol H2O" << std::endl;

         // *** Step 12: Visualization *** //
         // This will open the visualizer window for each time step. Close it to proceed to the next time step.
         Visualizer visualizer(1000);
         visualizer.buildContextGeometry(&context);
         visualizer.colorContextPrimitivesByData( "WUE" );
         visualizer.setColorbarTitle("WUE (umol CO2/mmol H2O)");;
         visualizer.setColorbarRange(0.f,15.f);
         visualizer.setColorbarPosition(make_vec3(0.75, 0.9, 0) );
         char time_string[6];
         sprintf(time_string, "%02d:%02d", time.hour, time.minute);
         visualizer.addTextboxByCenter( time_string, make_vec3(0.5,0.9,0), nullrotation, RGB::black, 16, "Arial", Visualizer::COORDINATES_WINDOW_NORMALIZED );
         visualizer.plotInteractive(); // !!! Close the window to advance to the next time step

     }

     return 0;
 }

 ~~~~~

*/