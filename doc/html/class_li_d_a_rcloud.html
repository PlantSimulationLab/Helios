<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Helios: LiDARcloud Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph_link.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
  DoxygenAwesomeParagraphLink.init()
  DoxygenAwesomeTabs.init()
  DoxygenAwesomeInteractiveToc.init()
</script>
<script>
    try {
        // Remove the stored “last visited page” so the tree always starts fresh
        Cookie.eraseSetting('navpath');
        localStorage.removeItem('navpath');
        // Older Doxygen versions might use this key:
        localStorage.removeItem('nav-sync-path');
        // Force panel synchronization on by default
        localStorage.setItem('navsync', 'true');
        // (fallback for some older builds)
        localStorage.setItem('nav-sync', 'true');
    } catch(e) {
        /* storage unavailable? ignore */
    }
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-93BB4673PE"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-93BB4673PE');
</script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3F0Y5Z6543"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-3F0Y5Z6543');
</script>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="5">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Helios_logo_small.png"></td>
  <td id="projectalign">
   <div id="projectname">
       <span id="projectnumber">&#160;v1.3.36</span>
   </div>
  </td>
     <td id="searchbox-container">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_li_d_a_rcloud.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">LiDARcloud Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Primary class for terrestrial LiDAR scan.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_li_d_a_r_8h_source.html">LiDAR.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1c946f80a3431e82e48fc54c611dca2c" id="r_a1c946f80a3431e82e48fc54c611dca2c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c946f80a3431e82e48fc54c611dca2c">LiDARcloud</a> ()</td></tr>
<tr class="memdesc:a1c946f80a3431e82e48fc54c611dca2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">LiDAR point cloud constructor.  <br /></td></tr>
<tr class="separator:a1c946f80a3431e82e48fc54c611dca2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849627f4e1cd43c49ab21757e812ca68" id="r_a849627f4e1cd43c49ab21757e812ca68"><td class="memItemLeft" align="right" valign="top"><a id="a849627f4e1cd43c49ab21757e812ca68" name="a849627f4e1cd43c49ab21757e812ca68"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~LiDARcloud</b> ()</td></tr>
<tr class="memdesc:a849627f4e1cd43c49ab21757e812ca68"><td class="mdescLeft">&#160;</td><td class="mdescRight">LiDAR point cloud destructor. <br /></td></tr>
<tr class="separator:a849627f4e1cd43c49ab21757e812ca68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2f35f02a65d4a7a731c4989dd9aa36" id="r_aaa2f35f02a65d4a7a731c4989dd9aa36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa2f35f02a65d4a7a731c4989dd9aa36">selfTest</a> ()</td></tr>
<tr class="memdesc:aaa2f35f02a65d4a7a731c4989dd9aa36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-test (unit test) function.  <br /></td></tr>
<tr class="separator:aaa2f35f02a65d4a7a731c4989dd9aa36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b07c5c073025eeedc5cbade19c2e8d4" id="r_a5b07c5c073025eeedc5cbade19c2e8d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b07c5c073025eeedc5cbade19c2e8d4">validateRayDirections</a> ()</td></tr>
<tr class="separator:a5b07c5c073025eeedc5cbade19c2e8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d0590b160e7069826c52eeeb4e0129" id="r_af5d0590b160e7069826c52eeeb4e0129"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5d0590b160e7069826c52eeeb4e0129">disableMessages</a> ()</td></tr>
<tr class="memdesc:af5d0590b160e7069826c52eeeb4e0129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable all print messages to the screen except for fatal error messages.  <br /></td></tr>
<tr class="separator:af5d0590b160e7069826c52eeeb4e0129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e87dc18538155b35368ff27ed6a1504" id="r_a2e87dc18538155b35368ff27ed6a1504"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e87dc18538155b35368ff27ed6a1504">enableMessages</a> ()</td></tr>
<tr class="memdesc:a2e87dc18538155b35368ff27ed6a1504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable all print messages to the screen.  <br /></td></tr>
<tr class="separator:a2e87dc18538155b35368ff27ed6a1504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa463ea1aaebb03abd8c3ec87091291a" id="r_aaa463ea1aaebb03abd8c3ec87091291a"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa463ea1aaebb03abd8c3ec87091291a">getScanCount</a> ()</td></tr>
<tr class="memdesc:aaa463ea1aaebb03abd8c3ec87091291a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of scans in point cloud.  <br /></td></tr>
<tr class="separator:aaa463ea1aaebb03abd8c3ec87091291a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe448db446aa64f5ce5a923c597eae8" id="r_abbe448db446aa64f5ce5a923c597eae8"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbe448db446aa64f5ce5a923c597eae8">addScan</a> (<a class="el" href="struct_scan_metadata.html">ScanMetadata</a> &amp;newscan)</td></tr>
<tr class="memdesc:abbe448db446aa64f5ce5a923c597eae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a LiDAR scan to the point cloud.  <br /></td></tr>
<tr class="separator:abbe448db446aa64f5ce5a923c597eae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f01d5c6bdab78ee7bc08c90ba5f2217" id="r_a6f01d5c6bdab78ee7bc08c90ba5f2217"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f01d5c6bdab78ee7bc08c90ba5f2217">addHitPoint</a> (uint scanID, const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;xyz, const <a class="el" href="structhelios_1_1_spherical_coord.html">helios::SphericalCoord</a> &amp;direction)</td></tr>
<tr class="memdesc:a6f01d5c6bdab78ee7bc08c90ba5f2217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a scan point as a hit by providing the (x,y,z) coordinates and scan ray direction.  <br /></td></tr>
<tr class="separator:a6f01d5c6bdab78ee7bc08c90ba5f2217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1955f2181dab90400fcabedb8997c71" id="r_ae1955f2181dab90400fcabedb8997c71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1955f2181dab90400fcabedb8997c71">addHitPoint</a> (uint scanID, const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;xyz, const <a class="el" href="structhelios_1_1_spherical_coord.html">helios::SphericalCoord</a> &amp;direction, const <a class="el" href="structhelios_1_1_r_g_bcolor.html">helios::RGBcolor</a> &amp;color)</td></tr>
<tr class="memdesc:ae1955f2181dab90400fcabedb8997c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a scan point as a hit by providing the (x,y,z) coordinates and scan ray direction.  <br /></td></tr>
<tr class="separator:ae1955f2181dab90400fcabedb8997c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed09112c241e9d60aea781c9684a2633" id="r_aed09112c241e9d60aea781c9684a2633"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed09112c241e9d60aea781c9684a2633">addHitPoint</a> (uint scanID, const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;xyz, const <a class="el" href="structhelios_1_1_spherical_coord.html">helios::SphericalCoord</a> &amp;direction, const std::map&lt; std::string, double &gt; &amp;data)</td></tr>
<tr class="memdesc:aed09112c241e9d60aea781c9684a2633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a scan point as a hit by providing the (x,y,z) coordinates and scan ray direction.  <br /></td></tr>
<tr class="separator:aed09112c241e9d60aea781c9684a2633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794f9370ba56a29651a95709c528a6a4" id="r_a794f9370ba56a29651a95709c528a6a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a794f9370ba56a29651a95709c528a6a4">addHitPoint</a> (uint scanID, const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;xyz, const <a class="el" href="structhelios_1_1_spherical_coord.html">helios::SphericalCoord</a> &amp;direction, const <a class="el" href="structhelios_1_1_r_g_bcolor.html">helios::RGBcolor</a> &amp;color, const std::map&lt; std::string, double &gt; &amp;data)</td></tr>
<tr class="memdesc:a794f9370ba56a29651a95709c528a6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a scan point as a hit by providing the (x,y,z) coordinates and scan ray direction.  <br /></td></tr>
<tr class="separator:a794f9370ba56a29651a95709c528a6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244a1de12e8f6a3518b8715086c28e46" id="r_a244a1de12e8f6a3518b8715086c28e46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a244a1de12e8f6a3518b8715086c28e46">addHitPoint</a> (uint scanID, const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;xyz, const <a class="el" href="structhelios_1_1int2.html">helios::int2</a> &amp;row_column, const <a class="el" href="structhelios_1_1_r_g_bcolor.html">helios::RGBcolor</a> &amp;color, const std::map&lt; std::string, double &gt; &amp;data)</td></tr>
<tr class="memdesc:a244a1de12e8f6a3518b8715086c28e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify a scan point as a hit by providing the (x,y,z) coordinates and row,column in scan table.  <br /></td></tr>
<tr class="separator:a244a1de12e8f6a3518b8715086c28e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf5ec6015b0b68c89716ffff1a016bb" id="r_accf5ec6015b0b68c89716ffff1a016bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accf5ec6015b0b68c89716ffff1a016bb">deleteHitPoint</a> (uint index)</td></tr>
<tr class="memdesc:accf5ec6015b0b68c89716ffff1a016bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a hit point in the scan.  <br /></td></tr>
<tr class="separator:accf5ec6015b0b68c89716ffff1a016bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691fd3bbd1262d80e10a674c82c6f568" id="r_a691fd3bbd1262d80e10a674c82c6f568"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a691fd3bbd1262d80e10a674c82c6f568">getHitCount</a> () const</td></tr>
<tr class="memdesc:a691fd3bbd1262d80e10a674c82c6f568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of hit points in the point cloud.  <br /></td></tr>
<tr class="separator:a691fd3bbd1262d80e10a674c82c6f568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa657ed32a8831ebf4f2e4a9203b683ef" id="r_aa657ed32a8831ebf4f2e4a9203b683ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhelios_1_1vec3.html">helios::vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa657ed32a8831ebf4f2e4a9203b683ef">getScanOrigin</a> (uint scanID) const</td></tr>
<tr class="memdesc:aa657ed32a8831ebf4f2e4a9203b683ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (x,y,z) scan origin.  <br /></td></tr>
<tr class="separator:aa657ed32a8831ebf4f2e4a9203b683ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40809c7a709a6c9ccb4beddca21f8ac9" id="r_a40809c7a709a6c9ccb4beddca21f8ac9"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40809c7a709a6c9ccb4beddca21f8ac9">getScanSizeTheta</a> (uint scanID) const</td></tr>
<tr class="memdesc:a40809c7a709a6c9ccb4beddca21f8ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of scan points in the theta (zenithal) direction.  <br /></td></tr>
<tr class="separator:a40809c7a709a6c9ccb4beddca21f8ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf04cd04c2b1bc162106a0e47cff6d29" id="r_aaf04cd04c2b1bc162106a0e47cff6d29"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf04cd04c2b1bc162106a0e47cff6d29">getScanSizePhi</a> (uint scanID) const</td></tr>
<tr class="memdesc:aaf04cd04c2b1bc162106a0e47cff6d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of scan points in the phi (azimuthal) direction.  <br /></td></tr>
<tr class="separator:aaf04cd04c2b1bc162106a0e47cff6d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0237a83da6997e973fde9939440979" id="r_a7f0237a83da6997e973fde9939440979"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhelios_1_1vec2.html">helios::vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f0237a83da6997e973fde9939440979">getScanRangeTheta</a> (uint scanID) const</td></tr>
<tr class="memdesc:a7f0237a83da6997e973fde9939440979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the range of scan directions in the theta (zenithal) direction.  <br /></td></tr>
<tr class="separator:a7f0237a83da6997e973fde9939440979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab314aac88834eb3938fc2f37e34807e3" id="r_ab314aac88834eb3938fc2f37e34807e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhelios_1_1vec2.html">helios::vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab314aac88834eb3938fc2f37e34807e3">getScanRangePhi</a> (uint scanID) const</td></tr>
<tr class="memdesc:ab314aac88834eb3938fc2f37e34807e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the range of scan directions in the phi (azimuthal) direction.  <br /></td></tr>
<tr class="separator:ab314aac88834eb3938fc2f37e34807e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab6b81a3d96226a766cc2450993407f" id="r_abab6b81a3d96226a766cc2450993407f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abab6b81a3d96226a766cc2450993407f">getScanBeamExitDiameter</a> (uint scanID) const</td></tr>
<tr class="memdesc:abab6b81a3d96226a766cc2450993407f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the diameter of the laser beam at exit from the instrument.  <br /></td></tr>
<tr class="separator:abab6b81a3d96226a766cc2450993407f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe892f01508dc69bcc5b28bea5472bf" id="r_abbe892f01508dc69bcc5b28bea5472bf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbe892f01508dc69bcc5b28bea5472bf">getScanColumnFormat</a> (uint scanID) const</td></tr>
<tr class="memdesc:abbe892f01508dc69bcc5b28bea5472bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the labels for columns in ASCII input/output file.  <br /></td></tr>
<tr class="separator:abbe892f01508dc69bcc5b28bea5472bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d93e6cd9decccf271fbf3fbd5c74a5a" id="r_a9d93e6cd9decccf271fbf3fbd5c74a5a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d93e6cd9decccf271fbf3fbd5c74a5a">getScanBeamDivergence</a> (uint scanID) const</td></tr>
<tr class="memdesc:a9d93e6cd9decccf271fbf3fbd5c74a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divergence angle of the laser beam in radians.  <br /></td></tr>
<tr class="separator:a9d93e6cd9decccf271fbf3fbd5c74a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f234b6200419f10fe82c9abe409cbd" id="r_ac5f234b6200419f10fe82c9abe409cbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhelios_1_1vec3.html">helios::vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5f234b6200419f10fe82c9abe409cbd">getHitXYZ</a> (uint index) const</td></tr>
<tr class="memdesc:ac5f234b6200419f10fe82c9abe409cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get (x,y,z) coordinate of hit point by index.  <br /></td></tr>
<tr class="separator:ac5f234b6200419f10fe82c9abe409cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91258bd97d6fcacd3313d8b55cceed4" id="r_aa91258bd97d6fcacd3313d8b55cceed4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhelios_1_1_spherical_coord.html">helios::SphericalCoord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa91258bd97d6fcacd3313d8b55cceed4">getHitRaydir</a> (uint index) const</td></tr>
<tr class="memdesc:aa91258bd97d6fcacd3313d8b55cceed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ray direction of hit point in the scan based on its index.  <br /></td></tr>
<tr class="separator:aa91258bd97d6fcacd3313d8b55cceed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274ef68850afa3f288bb648d9fd6a59a" id="r_a274ef68850afa3f288bb648d9fd6a59a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a274ef68850afa3f288bb648d9fd6a59a">getHitData</a> (uint index, const char *label) const</td></tr>
<tr class="memdesc:a274ef68850afa3f288bb648d9fd6a59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get floating point data value associated with a hit point.  <br /></td></tr>
<tr class="separator:a274ef68850afa3f288bb648d9fd6a59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad8b12380a24f48ecfbae0ad6b5cfaa" id="r_a4ad8b12380a24f48ecfbae0ad6b5cfaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ad8b12380a24f48ecfbae0ad6b5cfaa">setHitData</a> (uint index, const char *label, double value)</td></tr>
<tr class="memdesc:a4ad8b12380a24f48ecfbae0ad6b5cfaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set floating point data value associated with a hit point.  <br /></td></tr>
<tr class="separator:a4ad8b12380a24f48ecfbae0ad6b5cfaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb8d404b7f3fa00d8281cb6b74f90c0" id="r_aabb8d404b7f3fa00d8281cb6b74f90c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabb8d404b7f3fa00d8281cb6b74f90c0">doesHitDataExist</a> (uint index, const char *label) const</td></tr>
<tr class="memdesc:aabb8d404b7f3fa00d8281cb6b74f90c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if scalar data exists for a hit point.  <br /></td></tr>
<tr class="separator:aabb8d404b7f3fa00d8281cb6b74f90c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafafed9102966992d3cfb3772fa2ada1" id="r_aafafed9102966992d3cfb3772fa2ada1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhelios_1_1_r_g_bcolor.html">helios::RGBcolor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafafed9102966992d3cfb3772fa2ada1">getHitColor</a> (uint index) const</td></tr>
<tr class="memdesc:aafafed9102966992d3cfb3772fa2ada1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get color of hit point.  <br /></td></tr>
<tr class="separator:aafafed9102966992d3cfb3772fa2ada1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5510b2a0d0a878930e9f11331494bf41" id="r_a5510b2a0d0a878930e9f11331494bf41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5510b2a0d0a878930e9f11331494bf41">getHitScanID</a> (uint index) const</td></tr>
<tr class="memdesc:a5510b2a0d0a878930e9f11331494bf41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scan with which a hit is associated.  <br /></td></tr>
<tr class="separator:a5510b2a0d0a878930e9f11331494bf41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34eee980f365fdd5469a0cc6ee3a36f5" id="r_a34eee980f365fdd5469a0cc6ee3a36f5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34eee980f365fdd5469a0cc6ee3a36f5">getHitIndex</a> (uint scanID, uint row, uint column) const</td></tr>
<tr class="memdesc:a34eee980f365fdd5469a0cc6ee3a36f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a scan point based on its row and column in the hit table.  <br /></td></tr>
<tr class="separator:a34eee980f365fdd5469a0cc6ee3a36f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251c4f3bbefdd07212cd8fe1037dc0d7" id="r_a251c4f3bbefdd07212cd8fe1037dc0d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a251c4f3bbefdd07212cd8fe1037dc0d7">getHitGridCell</a> (uint index) const</td></tr>
<tr class="memdesc:a251c4f3bbefdd07212cd8fe1037dc0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the grid cell in which the hit point resides.  <br /></td></tr>
<tr class="separator:a251c4f3bbefdd07212cd8fe1037dc0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122b1716c42af6a07d48ad23b5acb427" id="r_a122b1716c42af6a07d48ad23b5acb427"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a122b1716c42af6a07d48ad23b5acb427">setHitGridCell</a> (uint index, int cell)</td></tr>
<tr class="memdesc:a122b1716c42af6a07d48ad23b5acb427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the grid cell in which the hit point resides.  <br /></td></tr>
<tr class="separator:a122b1716c42af6a07d48ad23b5acb427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bc752975f8783ad8b1710cefa1d2a9" id="r_a72bc752975f8783ad8b1710cefa1d2a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72bc752975f8783ad8b1710cefa1d2a9">coordinateShift</a> (const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;shift)</td></tr>
<tr class="memdesc:a72bc752975f8783ad8b1710cefa1d2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a translation to all points in the point cloud.  <br /></td></tr>
<tr class="separator:a72bc752975f8783ad8b1710cefa1d2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37566564d8e421a123c8b1b8cdb2347" id="r_ab37566564d8e421a123c8b1b8cdb2347"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab37566564d8e421a123c8b1b8cdb2347">coordinateShift</a> (uint scanID, const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;shift)</td></tr>
<tr class="memdesc:ab37566564d8e421a123c8b1b8cdb2347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a translation to all points in a given scan.  <br /></td></tr>
<tr class="separator:ab37566564d8e421a123c8b1b8cdb2347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263717159dde05f5b98ae4133dec3d5e" id="r_a263717159dde05f5b98ae4133dec3d5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a263717159dde05f5b98ae4133dec3d5e">coordinateRotation</a> (const <a class="el" href="structhelios_1_1_spherical_coord.html">helios::SphericalCoord</a> &amp;rotation)</td></tr>
<tr class="memdesc:a263717159dde05f5b98ae4133dec3d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate all points in the point cloud about the origin.  <br /></td></tr>
<tr class="separator:a263717159dde05f5b98ae4133dec3d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae9aaa404a67082f849e1c8d56579e5" id="r_aeae9aaa404a67082f849e1c8d56579e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeae9aaa404a67082f849e1c8d56579e5">coordinateRotation</a> (uint scanID, const <a class="el" href="structhelios_1_1_spherical_coord.html">helios::SphericalCoord</a> &amp;rotation)</td></tr>
<tr class="memdesc:aeae9aaa404a67082f849e1c8d56579e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate all points in the point cloud about the origin.  <br /></td></tr>
<tr class="separator:aeae9aaa404a67082f849e1c8d56579e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2f7677b1a92cba5b51ad0336e3743e" id="r_abf2f7677b1a92cba5b51ad0336e3743e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf2f7677b1a92cba5b51ad0336e3743e">coordinateRotation</a> (float rotation, const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;line_base, const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;line_direction)</td></tr>
<tr class="memdesc:abf2f7677b1a92cba5b51ad0336e3743e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate all points in the point cloud about an arbitrary line.  <br /></td></tr>
<tr class="separator:abf2f7677b1a92cba5b51ad0336e3743e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdbf834959379a189a60efed41f3e52" id="r_abcdbf834959379a189a60efed41f3e52"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcdbf834959379a189a60efed41f3e52">getTriangleCount</a> () const</td></tr>
<tr class="memdesc:abcdbf834959379a189a60efed41f3e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of triangles formed by the triangulation.  <br /></td></tr>
<tr class="separator:abcdbf834959379a189a60efed41f3e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a1af5eea22185e59c267c8e4d94c9e" id="r_aa1a1af5eea22185e59c267c8e4d94c9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_triangulation.html">Triangulation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1a1af5eea22185e59c267c8e4d94c9e">getTriangle</a> (uint index) const</td></tr>
<tr class="memdesc:aa1a1af5eea22185e59c267c8e4d94c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get hit point corresponding to first vertex of triangle.  <br /></td></tr>
<tr class="separator:aa1a1af5eea22185e59c267c8e4d94c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd7e1839d1a6ecb738233b20b93f1f7" id="r_a6bd7e1839d1a6ecb738233b20b93f1f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bd7e1839d1a6ecb738233b20b93f1f7">loadXML</a> (const char *filename)</td></tr>
<tr class="memdesc:a6bd7e1839d1a6ecb738233b20b93f1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an XML file containing scan information.  <br /></td></tr>
<tr class="separator:a6bd7e1839d1a6ecb738233b20b93f1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac966b0aae37889c288277b950b2fd30a" id="r_ac966b0aae37889c288277b950b2fd30a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac966b0aae37889c288277b950b2fd30a">loadXML</a> (const char *filename, bool load_grid_only)</td></tr>
<tr class="memdesc:ac966b0aae37889c288277b950b2fd30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an XML file containing scan information.  <br /></td></tr>
<tr class="separator:ac966b0aae37889c288277b950b2fd30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad030fdddcfa669d6af513eb66a9cbd1a" id="r_ad030fdddcfa669d6af513eb66a9cbd1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad030fdddcfa669d6af513eb66a9cbd1a">exportTriangleNormals</a> (const char *filename)</td></tr>
<tr class="memdesc:ad030fdddcfa669d6af513eb66a9cbd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export to file the normal vectors (nx,ny,nz) for all triangles formed.  <br /></td></tr>
<tr class="separator:ad030fdddcfa669d6af513eb66a9cbd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8376ce652d2e95e886d4d60d321c274" id="r_aa8376ce652d2e95e886d4d60d321c274"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8376ce652d2e95e886d4d60d321c274">exportTriangleNormals</a> (const char *filename, int gridcell)</td></tr>
<tr class="memdesc:aa8376ce652d2e95e886d4d60d321c274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export to file the normal vectors (nx,ny,nz) for triangles formed within a single gridcell.  <br /></td></tr>
<tr class="separator:aa8376ce652d2e95e886d4d60d321c274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416638f486c4fd2572a9589b69605fe7" id="r_a416638f486c4fd2572a9589b69605fe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a416638f486c4fd2572a9589b69605fe7">exportTriangleAreas</a> (const char *filename)</td></tr>
<tr class="memdesc:a416638f486c4fd2572a9589b69605fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export to file the area of all triangles formed.  <br /></td></tr>
<tr class="separator:a416638f486c4fd2572a9589b69605fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb93e3a16abc8100b2e5dac956c6cc3e" id="r_adb93e3a16abc8100b2e5dac956c6cc3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb93e3a16abc8100b2e5dac956c6cc3e">exportTriangleAreas</a> (const char *filename, int gridcell)</td></tr>
<tr class="memdesc:adb93e3a16abc8100b2e5dac956c6cc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export to file the area of all triangles formed within a single grid cell.  <br /></td></tr>
<tr class="separator:adb93e3a16abc8100b2e5dac956c6cc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadeb8297b74a75fd003f6c96fe378043" id="r_aadeb8297b74a75fd003f6c96fe378043"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aadeb8297b74a75fd003f6c96fe378043">exportTriangleInclinationDistribution</a> (const char *filename, uint Nbins)</td></tr>
<tr class="memdesc:aadeb8297b74a75fd003f6c96fe378043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export to file discrete area-weighted inclination angle probability distribution based on the triangulation. Inclination angles are between 0 and 90 degrees. The probability distribution is normalized such that the sine-weighted integral over all angles is 1. The value of each bin is written as a column in the output file; lines correspond to each voxel grid cell.  <br /></td></tr>
<tr class="separator:aadeb8297b74a75fd003f6c96fe378043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a33b5d05470e8e0362de352fc09bf1" id="r_ab9a33b5d05470e8e0362de352fc09bf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9a33b5d05470e8e0362de352fc09bf1">exportTriangleAzimuthDistribution</a> (const char *filename, uint Nbins)</td></tr>
<tr class="memdesc:ab9a33b5d05470e8e0362de352fc09bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export to file discrete azimuthal angle probability distribution based on the triangulation. Azimuthal angles are between 0 and 360 degrees. The probability distribution is normalized such that the integral over all angles is 1. The value of each bin is written as a column in the output file; lines correspond to each voxel grid cell.  <br /></td></tr>
<tr class="separator:ab9a33b5d05470e8e0362de352fc09bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8bd43bf3b2c107994fee402c41240f" id="r_a8e8bd43bf3b2c107994fee402c41240f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e8bd43bf3b2c107994fee402c41240f">exportLeafAreas</a> (const char *filename)</td></tr>
<tr class="memdesc:a8e8bd43bf3b2c107994fee402c41240f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export to file the leaf area within each grid cell. Lines of the file correspond to each grid cell.  <br /></td></tr>
<tr class="separator:a8e8bd43bf3b2c107994fee402c41240f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e438fd60af7f54f4d1c09ac64fd7338" id="r_a6e438fd60af7f54f4d1c09ac64fd7338"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e438fd60af7f54f4d1c09ac64fd7338">exportLeafAreaDensities</a> (const char *filename)</td></tr>
<tr class="memdesc:a6e438fd60af7f54f4d1c09ac64fd7338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export to file the leaf area density within each grid cell. Lines of the file correspond to each grid cell.  <br /></td></tr>
<tr class="separator:a6e438fd60af7f54f4d1c09ac64fd7338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af680cbb9eb0c1ebf49f71f0062d18c0c" id="r_af680cbb9eb0c1ebf49f71f0062d18c0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af680cbb9eb0c1ebf49f71f0062d18c0c">exportGtheta</a> (const char *filename)</td></tr>
<tr class="memdesc:af680cbb9eb0c1ebf49f71f0062d18c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export to file the G(theta) value within each grid cell. Lines of the file correspond to each grid cell.  <br /></td></tr>
<tr class="separator:af680cbb9eb0c1ebf49f71f0062d18c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0c11c6d8001171269232ff5d7f6322" id="r_a2d0c11c6d8001171269232ff5d7f6322"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d0c11c6d8001171269232ff5d7f6322">exportPointCloud</a> (const char *filename)</td></tr>
<tr class="memdesc:a2d0c11c6d8001171269232ff5d7f6322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export to file all points in the point cloud to an ASCII text file following the column format specified by the &lt;ASCII_format&gt;&lt;/ASCII_format&gt; tag in the scan XML file.  <br /></td></tr>
<tr class="separator:a2d0c11c6d8001171269232ff5d7f6322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9910fa1aae6b8b077d57417c130e753" id="r_ae9910fa1aae6b8b077d57417c130e753"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9910fa1aae6b8b077d57417c130e753">exportPointCloud</a> (const char *filename, uint scanID)</td></tr>
<tr class="memdesc:ae9910fa1aae6b8b077d57417c130e753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export to file all points from a given scan to an ASCII text file following the column format specified by the &lt;ASCII_format&gt;&lt;/ASCII_format&gt; tag in the scan XML file.  <br /></td></tr>
<tr class="separator:ae9910fa1aae6b8b077d57417c130e753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48fe9018f26664dd9abd8c100fccaa6" id="r_ac48fe9018f26664dd9abd8c100fccaa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac48fe9018f26664dd9abd8c100fccaa6">exportPointCloudPTX</a> (const char *filename, uint scanID)</td></tr>
<tr class="memdesc:ac48fe9018f26664dd9abd8c100fccaa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export to file all points from a given scan to PTX file.  <br /></td></tr>
<tr class="separator:ac48fe9018f26664dd9abd8c100fccaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2102dd4711658414cca10fd40a66af18" id="r_a2102dd4711658414cca10fd40a66af18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2102dd4711658414cca10fd40a66af18">addHitsToVisualizer</a> (<a class="el" href="class_visualizer.html">Visualizer</a> *visualizer, uint pointsize) const</td></tr>
<tr class="memdesc:a2102dd4711658414cca10fd40a66af18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all hit points to the visualizer plug-in, and color them by their r-g-b color.  <br /></td></tr>
<tr class="separator:a2102dd4711658414cca10fd40a66af18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6292d1b6fce7638a256e090608c8c309" id="r_a6292d1b6fce7638a256e090608c8c309"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6292d1b6fce7638a256e090608c8c309">addHitsToVisualizer</a> (<a class="el" href="class_visualizer.html">Visualizer</a> *visualizer, uint pointsize, const char *color_value) const</td></tr>
<tr class="memdesc:a6292d1b6fce7638a256e090608c8c309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all hit points to the visualizer plug-in, and color them by a hit scalar data value.  <br /></td></tr>
<tr class="separator:a6292d1b6fce7638a256e090608c8c309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7b76c26d6dd976bf37c0595b761507" id="r_a2b7b76c26d6dd976bf37c0595b761507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b7b76c26d6dd976bf37c0595b761507">addGridToVisualizer</a> (<a class="el" href="class_visualizer.html">Visualizer</a> *visualizer) const</td></tr>
<tr class="memdesc:a2b7b76c26d6dd976bf37c0595b761507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all grid cells to the visualizer plug-in.  <br /></td></tr>
<tr class="separator:a2b7b76c26d6dd976bf37c0595b761507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c99daa924206b8172bb3bb1657e251" id="r_af8c99daa924206b8172bb3bb1657e251"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8c99daa924206b8172bb3bb1657e251">addGridWireFrametoVisualizer</a> (<a class="el" href="class_visualizer.html">Visualizer</a> *visualizer) const</td></tr>
<tr class="memdesc:af8c99daa924206b8172bb3bb1657e251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add wire frame of the grid to the visualizer plug-in.  <br /></td></tr>
<tr class="separator:af8c99daa924206b8172bb3bb1657e251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755ab5b665c80e30a49450ccfa1592d1" id="r_a755ab5b665c80e30a49450ccfa1592d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a755ab5b665c80e30a49450ccfa1592d1">addGrid</a> (const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;center, const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;size, const <a class="el" href="structhelios_1_1int3.html">helios::int3</a> &amp;ndiv, float rotation)</td></tr>
<tr class="memdesc:a755ab5b665c80e30a49450ccfa1592d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a grid to point cloud instead of reading in from an xml file.  <br /></td></tr>
<tr class="separator:a755ab5b665c80e30a49450ccfa1592d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d8d20197aa909080d70954c97395e6" id="r_a11d8d20197aa909080d70954c97395e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11d8d20197aa909080d70954c97395e6">addTrianglesToVisualizer</a> (<a class="el" href="class_visualizer.html">Visualizer</a> *visualizer) const</td></tr>
<tr class="memdesc:a11d8d20197aa909080d70954c97395e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all triangles to the visualizer plug-in, and color them by their r-g-b color.  <br /></td></tr>
<tr class="separator:a11d8d20197aa909080d70954c97395e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d1d5c311e4cfa45fa47f36ac875e7f" id="r_a55d1d5c311e4cfa45fa47f36ac875e7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55d1d5c311e4cfa45fa47f36ac875e7f">addTrianglesToVisualizer</a> (<a class="el" href="class_visualizer.html">Visualizer</a> *visualizer, uint gridcell) const</td></tr>
<tr class="memdesc:a55d1d5c311e4cfa45fa47f36ac875e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add triangles within a given grid cell to the visualizer plug-in, and color them by their r-g-b color.  <br /></td></tr>
<tr class="separator:a55d1d5c311e4cfa45fa47f36ac875e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9cff3d1f5a68814ff2121d3b12d9b8" id="r_a9c9cff3d1f5a68814ff2121d3b12d9b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c9cff3d1f5a68814ff2121d3b12d9b8">addLeafReconstructionToVisualizer</a> (<a class="el" href="class_visualizer.html">Visualizer</a> *visualizer) const</td></tr>
<tr class="memdesc:a9c9cff3d1f5a68814ff2121d3b12d9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add reconstructed leaves (triangles or alpha masks) to the visualizer plug-in.  <br /></td></tr>
<tr class="separator:a9c9cff3d1f5a68814ff2121d3b12d9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23c198a2c7492b8b6c865a42971a93d" id="r_aa23c198a2c7492b8b6c865a42971a93d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa23c198a2c7492b8b6c865a42971a93d">addTrunkReconstructionToVisualizer</a> (<a class="el" href="class_visualizer.html">Visualizer</a> *visualizer) const</td></tr>
<tr class="memdesc:aa23c198a2c7492b8b6c865a42971a93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add trunk reconstruction to the visualizer plug-in. Colors reconstructed triangles by hit point color.  <br /></td></tr>
<tr class="separator:aa23c198a2c7492b8b6c865a42971a93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa20f56e1dbb38de35a48a599cda711" id="r_a9fa20f56e1dbb38de35a48a599cda711"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fa20f56e1dbb38de35a48a599cda711">addTrunkReconstructionToVisualizer</a> (<a class="el" href="class_visualizer.html">Visualizer</a> *visualizer, const <a class="el" href="structhelios_1_1_r_g_bcolor.html">helios::RGBcolor</a> &amp;trunk_color) const</td></tr>
<tr class="memdesc:a9fa20f56e1dbb38de35a48a599cda711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add trunk reconstruction to the visualizer plug-in.  <br /></td></tr>
<tr class="separator:a9fa20f56e1dbb38de35a48a599cda711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca8578d8b5ecbc92fa669c612196f8c" id="r_aeca8578d8b5ecbc92fa669c612196f8c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeca8578d8b5ecbc92fa669c612196f8c">addLeafReconstructionToContext</a> (<a class="el" href="classhelios_1_1_context.html">helios::Context</a> *context) const</td></tr>
<tr class="memdesc:aeca8578d8b5ecbc92fa669c612196f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add reconstructed leaves (texture-masked patches) to the Context.  <br /></td></tr>
<tr class="separator:aeca8578d8b5ecbc92fa669c612196f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b1545809e3537b4e7e803acc8c13c1" id="r_ab2b1545809e3537b4e7e803acc8c13c1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2b1545809e3537b4e7e803acc8c13c1">addLeafReconstructionToContext</a> (<a class="el" href="classhelios_1_1_context.html">helios::Context</a> *context, const <a class="el" href="structhelios_1_1int2.html">helios::int2</a> &amp;subpatches) const</td></tr>
<tr class="memdesc:ab2b1545809e3537b4e7e803acc8c13c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add reconstructed leaves (texture-masked patches) to the Context with leaves divided into sub-patches (tiled)  <br /></td></tr>
<tr class="separator:ab2b1545809e3537b4e7e803acc8c13c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503c74fc549e5c3b25a5f5bf2d6a8955" id="r_a503c74fc549e5c3b25a5f5bf2d6a8955"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a503c74fc549e5c3b25a5f5bf2d6a8955">addReconstructedTriangleGroupsToContext</a> (<a class="el" href="classhelios_1_1_context.html">helios::Context</a> *context) const</td></tr>
<tr class="memdesc:a503c74fc549e5c3b25a5f5bf2d6a8955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add triangle groups used in the direct reconstruction to the Context.  <br /></td></tr>
<tr class="separator:a503c74fc549e5c3b25a5f5bf2d6a8955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af78b2f167575f641e867f0f0688dd1" id="r_a4af78b2f167575f641e867f0f0688dd1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4af78b2f167575f641e867f0f0688dd1">addTrunkReconstructionToContext</a> (<a class="el" href="classhelios_1_1_context.html">helios::Context</a> *context) const</td></tr>
<tr class="memdesc:a4af78b2f167575f641e867f0f0688dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add reconstructed trunk triangles to the Context.  <br /></td></tr>
<tr class="separator:a4af78b2f167575f641e867f0f0688dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bc37a4d26eb74a944c594a7f3cb54b" id="r_a45bc37a4d26eb74a944c594a7f3cb54b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45bc37a4d26eb74a944c594a7f3cb54b">getHitBoundingBox</a> (<a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;boxmin, <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;boxmax) const</td></tr>
<tr class="memdesc:a45bc37a4d26eb74a944c594a7f3cb54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Form an axis-aligned bounding box for all hit points in the point cloud.  <br /></td></tr>
<tr class="separator:a45bc37a4d26eb74a944c594a7f3cb54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041ac4ba388c407a35b7f895029038e6" id="r_a041ac4ba388c407a35b7f895029038e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a041ac4ba388c407a35b7f895029038e6">getGridBoundingBox</a> (<a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;boxmin, <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;boxmax) const</td></tr>
<tr class="memdesc:a041ac4ba388c407a35b7f895029038e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Form an axis-aligned bounding box for all grid cells in the point cloud.  <br /></td></tr>
<tr class="separator:a041ac4ba388c407a35b7f895029038e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21b843806f22fb9bc80e7ef370aee1d" id="r_af21b843806f22fb9bc80e7ef370aee1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af21b843806f22fb9bc80e7ef370aee1d">distanceFilter</a> (float maxdistance)</td></tr>
<tr class="memdesc:af21b843806f22fb9bc80e7ef370aee1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter scan by imposing a maximum distance from the scanner.  <br /></td></tr>
<tr class="separator:af21b843806f22fb9bc80e7ef370aee1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17ca020e2f2fd4f1ce91ef5101353d0" id="r_ac17ca020e2f2fd4f1ce91ef5101353d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac17ca020e2f2fd4f1ce91ef5101353d0">xyzFilter</a> (float xmin, float xmax, float ymin, float ymax, float zmin, float zmax)</td></tr>
<tr class="memdesc:ac17ca020e2f2fd4f1ce91ef5101353d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">overloaded version of xyzFilter that defaults to deleting points outside the provided bounding box  <br /></td></tr>
<tr class="separator:ac17ca020e2f2fd4f1ce91ef5101353d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ee72fba222c399c256adf577ae860d" id="r_a56ee72fba222c399c256adf577ae860d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56ee72fba222c399c256adf577ae860d">xyzFilter</a> (float xmin, float xmax, float ymin, float ymax, float zmin, float zmax, bool deleteOutside)</td></tr>
<tr class="memdesc:a56ee72fba222c399c256adf577ae860d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter scan with a bounding box.  <br /></td></tr>
<tr class="separator:a56ee72fba222c399c256adf577ae860d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2d9ef2301fd7fdee97e2adc0947dd3" id="r_adf2d9ef2301fd7fdee97e2adc0947dd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf2d9ef2301fd7fdee97e2adc0947dd3">reflectanceFilter</a> (float minreflectance)</td></tr>
<tr class="memdesc:adf2d9ef2301fd7fdee97e2adc0947dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter scan by imposing a minimum reflectance value.  <br /></td></tr>
<tr class="separator:adf2d9ef2301fd7fdee97e2adc0947dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ea59f063b3c951a1e58af9e4ddfd7e" id="r_aa2ea59f063b3c951a1e58af9e4ddfd7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2ea59f063b3c951a1e58af9e4ddfd7e">scalarFilter</a> (const char *scalar_field, float threshold, const char *comparator)</td></tr>
<tr class="memdesc:aa2ea59f063b3c951a1e58af9e4ddfd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter hit points based on a scalar field given by a column in the ASCII data.  <br /></td></tr>
<tr class="separator:aa2ea59f063b3c951a1e58af9e4ddfd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c2bd82b67b3e84069090d75ed2973d" id="r_aa5c2bd82b67b3e84069090d75ed2973d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5c2bd82b67b3e84069090d75ed2973d">maxPulseFilter</a> (const char *scalar)</td></tr>
<tr class="memdesc:aa5c2bd82b67b3e84069090d75ed2973d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter full-waveform data according to the maximum scalar value along each pulse. Any scalar value can be used, provided it is a field in the hit point data file. The resulting point cloud will have only one hit point per laser pulse.  <br /></td></tr>
<tr class="separator:aa5c2bd82b67b3e84069090d75ed2973d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530582b532eb13ca938d5e843d902327" id="r_a530582b532eb13ca938d5e843d902327"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a530582b532eb13ca938d5e843d902327">minPulseFilter</a> (const char *scalar)</td></tr>
<tr class="memdesc:a530582b532eb13ca938d5e843d902327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter full-waveform data according to the minimum scalar value along each pulse. Any scalar value can be used, provided it is a field in the hit point data file. The resulting point cloud will have only one hit point per laser pulse.  <br /></td></tr>
<tr class="separator:a530582b532eb13ca938d5e843d902327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869540860f4cace62dbd2fb54353bd33" id="r_a869540860f4cace62dbd2fb54353bd33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a869540860f4cace62dbd2fb54353bd33">firstHitFilter</a> ()</td></tr>
<tr class="memdesc:a869540860f4cace62dbd2fb54353bd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter full-waveform data to include only the first hit per laser pulse. The resulting point cloud will have only one hit point per laser pulse (first hits).  <br /></td></tr>
<tr class="separator:a869540860f4cace62dbd2fb54353bd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab812d48fd5d81a8cc382bf0d1214496d" id="r_ab812d48fd5d81a8cc382bf0d1214496d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab812d48fd5d81a8cc382bf0d1214496d">lastHitFilter</a> ()</td></tr>
<tr class="memdesc:ab812d48fd5d81a8cc382bf0d1214496d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter full-waveform data to include only the last hit per laser pulse. The resulting point cloud will have only one hit point per laser pulse (last hits).  <br /></td></tr>
<tr class="separator:ab812d48fd5d81a8cc382bf0d1214496d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac495385c9dc7cc7773819ce77175242a" id="r_ac495385c9dc7cc7773819ce77175242a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac495385c9dc7cc7773819ce77175242a">triangulateHitPoints</a> (float Lmax, float max_aspect_ratio)</td></tr>
<tr class="memdesc:ac495385c9dc7cc7773819ce77175242a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform triangulation on all hit points in point cloud.  <br /></td></tr>
<tr class="separator:ac495385c9dc7cc7773819ce77175242a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2d9ac728f839b64cedb20582d77d48" id="r_a2e2d9ac728f839b64cedb20582d77d48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e2d9ac728f839b64cedb20582d77d48">triangulateHitPoints</a> (float Lmax, float max_aspect_ratio, const char *scalar_field, float threshold, const char *comparator)</td></tr>
<tr class="memdesc:a2e2d9ac728f839b64cedb20582d77d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform triangulation on hit points in point cloud that meet some filtering criteria based on scalar data.  <br /></td></tr>
<tr class="separator:a2e2d9ac728f839b64cedb20582d77d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c36191d1f0f82b77ebd2ffa2fe3821" id="r_a65c36191d1f0f82b77ebd2ffa2fe3821"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65c36191d1f0f82b77ebd2ffa2fe3821">addTrianglesToContext</a> (<a class="el" href="classhelios_1_1_context.html">helios::Context</a> *context) const</td></tr>
<tr class="memdesc:a65c36191d1f0f82b77ebd2ffa2fe3821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add triangle geometry to Helios context.  <br /></td></tr>
<tr class="separator:a65c36191d1f0f82b77ebd2ffa2fe3821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28297a71becd69b30820d69b110fcc90" id="r_a28297a71becd69b30820d69b110fcc90"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28297a71becd69b30820d69b110fcc90">getGridCellCount</a> () const</td></tr>
<tr class="memdesc:a28297a71becd69b30820d69b110fcc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of cells in the grid.  <br /></td></tr>
<tr class="separator:a28297a71becd69b30820d69b110fcc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac850f71f86e2872a78d8ff9bc6df6d08" id="r_ac850f71f86e2872a78d8ff9bc6df6d08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac850f71f86e2872a78d8ff9bc6df6d08">addGridCell</a> (const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;center, const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;size, float rotation)</td></tr>
<tr class="memdesc:ac850f71f86e2872a78d8ff9bc6df6d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a cell to the grid.  <br /></td></tr>
<tr class="separator:ac850f71f86e2872a78d8ff9bc6df6d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a1e6e5eeb76df93e99c0bbaa971b93" id="r_a60a1e6e5eeb76df93e99c0bbaa971b93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60a1e6e5eeb76df93e99c0bbaa971b93">addGridCell</a> (const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;center, const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;global_anchor, const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;size, const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;global_size, float rotation, const <a class="el" href="structhelios_1_1int3.html">helios::int3</a> &amp;global_ijk, const <a class="el" href="structhelios_1_1int3.html">helios::int3</a> &amp;global_count)</td></tr>
<tr class="memdesc:a60a1e6e5eeb76df93e99c0bbaa971b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a cell to the grid, where the cell is part of a larger global rectangular grid.  <br /></td></tr>
<tr class="separator:a60a1e6e5eeb76df93e99c0bbaa971b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2ce01abb33cc0f80b2aa653ac6a445" id="r_a6e2ce01abb33cc0f80b2aa653ac6a445"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhelios_1_1vec3.html">helios::vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e2ce01abb33cc0f80b2aa653ac6a445">getCellCenter</a> (uint index) const</td></tr>
<tr class="memdesc:a6e2ce01abb33cc0f80b2aa653ac6a445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (x,y,z) coordinate of a grid cell by its index.  <br /></td></tr>
<tr class="separator:a6e2ce01abb33cc0f80b2aa653ac6a445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ad4f851b5b7fcbf5b088b161aed83e" id="r_ad1ad4f851b5b7fcbf5b088b161aed83e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhelios_1_1vec3.html">helios::vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1ad4f851b5b7fcbf5b088b161aed83e">getCellGlobalAnchor</a> (uint index) const</td></tr>
<tr class="memdesc:ad1ad4f851b5b7fcbf5b088b161aed83e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (x,y,z) coordinate of a grid global anchor by its index.  <br /></td></tr>
<tr class="separator:ad1ad4f851b5b7fcbf5b088b161aed83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6662330b95ee7ee77ea6647871695c55" id="r_a6662330b95ee7ee77ea6647871695c55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhelios_1_1vec3.html">helios::vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6662330b95ee7ee77ea6647871695c55">getCellSize</a> (uint index) const</td></tr>
<tr class="memdesc:a6662330b95ee7ee77ea6647871695c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a grid cell by its index.  <br /></td></tr>
<tr class="separator:a6662330b95ee7ee77ea6647871695c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cba1d0bcd9a2ae35d9a5be03832efc" id="r_aa2cba1d0bcd9a2ae35d9a5be03832efc"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2cba1d0bcd9a2ae35d9a5be03832efc">getCellRotation</a> (uint index) const</td></tr>
<tr class="memdesc:aa2cba1d0bcd9a2ae35d9a5be03832efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of a grid cell by its index.  <br /></td></tr>
<tr class="separator:aa2cba1d0bcd9a2ae35d9a5be03832efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16514fff6766e89b91409077daf35fc" id="r_ab16514fff6766e89b91409077daf35fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab16514fff6766e89b91409077daf35fc">calculateHitGridCellGPU</a> ()</td></tr>
<tr class="memdesc:ab16514fff6766e89b91409077daf35fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the grid cell in which each hit point resides for the whole point cloud - GPU accelerated version *&zwj;/.  <br /></td></tr>
<tr class="separator:ab16514fff6766e89b91409077daf35fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5cafa2281f9d479f2bb56be0780e31" id="r_aac5cafa2281f9d479f2bb56be0780e31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac5cafa2281f9d479f2bb56be0780e31">syntheticScan</a> (<a class="el" href="classhelios_1_1_context.html">helios::Context</a> *context)</td></tr>
<tr class="memdesc:aac5cafa2281f9d479f2bb56be0780e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a discrete return synthetic LiDAR scan based on scan parameters given in an XML file (returns only one laser hit per pulse)  <br /></td></tr>
<tr class="separator:aac5cafa2281f9d479f2bb56be0780e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027d03054878ad27a705a839c36ba0cf" id="r_a027d03054878ad27a705a839c36ba0cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a027d03054878ad27a705a839c36ba0cf">syntheticScan</a> (<a class="el" href="classhelios_1_1_context.html">helios::Context</a> *context, bool scan_grid_only, bool record_misses)</td></tr>
<tr class="memdesc:a027d03054878ad27a705a839c36ba0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a discrete return synthetic LiDAR scan based on scan parameters given in an XML file (returns only one laser hit per pulse)  <br /></td></tr>
<tr class="separator:a027d03054878ad27a705a839c36ba0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2bef5f45b9c7f65e04952ed1551f25" id="r_aca2bef5f45b9c7f65e04952ed1551f25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca2bef5f45b9c7f65e04952ed1551f25">syntheticScan</a> (<a class="el" href="classhelios_1_1_context.html">helios::Context</a> *context, int rays_per_pulse, float pulse_distance_threshold)</td></tr>
<tr class="memdesc:aca2bef5f45b9c7f65e04952ed1551f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a full-waveform synthetic LiDAR scan based on scan parameters given in an XML file (returns multiple laser hits per pulse)  <br /></td></tr>
<tr class="separator:aca2bef5f45b9c7f65e04952ed1551f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4118588bb1a17e5d855a18ffbde299" id="r_a0a4118588bb1a17e5d855a18ffbde299"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a4118588bb1a17e5d855a18ffbde299">syntheticScan</a> (<a class="el" href="classhelios_1_1_context.html">helios::Context</a> *context, int rays_per_pulse, float pulse_distance_threshold, bool scan_grid_only, bool record_misses)</td></tr>
<tr class="memdesc:a0a4118588bb1a17e5d855a18ffbde299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a full-waveform synthetic LiDAR scan based on scan parameters given in an XML file (returns multiple laser hits per pulse)  <br /></td></tr>
<tr class="separator:a0a4118588bb1a17e5d855a18ffbde299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f9c93700be5e5a808b97ecca6752fe" id="r_a22f9c93700be5e5a808b97ecca6752fe"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22f9c93700be5e5a808b97ecca6752fe">calculateSyntheticLeafArea</a> (<a class="el" href="classhelios_1_1_context.html">helios::Context</a> *context)</td></tr>
<tr class="memdesc:a22f9c93700be5e5a808b97ecca6752fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the surface area of all primitives in the context.  <br /></td></tr>
<tr class="separator:a22f9c93700be5e5a808b97ecca6752fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fe14aa32343dc25e366fe2ad7dfdfd" id="r_a94fe14aa32343dc25e366fe2ad7dfdfd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94fe14aa32343dc25e366fe2ad7dfdfd">calculateSyntheticGtheta</a> (<a class="el" href="classhelios_1_1_context.html">helios::Context</a> *context)</td></tr>
<tr class="memdesc:a94fe14aa32343dc25e366fe2ad7dfdfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the G(theta) of all primitives in the context.  <br /></td></tr>
<tr class="separator:a94fe14aa32343dc25e366fe2ad7dfdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32643f365dda44670b5b132c4eee8442" id="r_a32643f365dda44670b5b132c4eee8442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32643f365dda44670b5b132c4eee8442">setCellLeafArea</a> (float area, uint index)</td></tr>
<tr class="memdesc:a32643f365dda44670b5b132c4eee8442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the leaf area of a grid cell in m^2.  <br /></td></tr>
<tr class="separator:a32643f365dda44670b5b132c4eee8442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d20a35bdb7ee2d45490ac1cd520117" id="r_ac9d20a35bdb7ee2d45490ac1cd520117"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9d20a35bdb7ee2d45490ac1cd520117">getCellLeafArea</a> (uint index) const</td></tr>
<tr class="memdesc:ac9d20a35bdb7ee2d45490ac1cd520117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the leaf area of a grid cell in m^2.  <br /></td></tr>
<tr class="separator:ac9d20a35bdb7ee2d45490ac1cd520117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1744984481f9629dc1371291fa397e" id="r_a3c1744984481f9629dc1371291fa397e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c1744984481f9629dc1371291fa397e">getCellLeafAreaDensity</a> (uint index) const</td></tr>
<tr class="memdesc:a3c1744984481f9629dc1371291fa397e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the leaf area density of a grid cell in 1/m.  <br /></td></tr>
<tr class="separator:a3c1744984481f9629dc1371291fa397e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8d55452f2423ddf8b77effbf443075" id="r_a4c8d55452f2423ddf8b77effbf443075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c8d55452f2423ddf8b77effbf443075">setCellGtheta</a> (float Gtheta, uint index)</td></tr>
<tr class="memdesc:a4c8d55452f2423ddf8b77effbf443075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the average G(theta) value of a grid cell.  <br /></td></tr>
<tr class="separator:a4c8d55452f2423ddf8b77effbf443075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54351e18e3f4155e9d55eb02bd63c722" id="r_a54351e18e3f4155e9d55eb02bd63c722"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54351e18e3f4155e9d55eb02bd63c722">getCellGtheta</a> (uint index) const</td></tr>
<tr class="memdesc:a54351e18e3f4155e9d55eb02bd63c722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the G(theta) of a grid cell.  <br /></td></tr>
<tr class="separator:a54351e18e3f4155e9d55eb02bd63c722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b80def6bff07231b8d2b10eb3e0330" id="r_a53b80def6bff07231b8d2b10eb3e0330"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53b80def6bff07231b8d2b10eb3e0330">gapfillMisses</a> ()</td></tr>
<tr class="memdesc:a53b80def6bff07231b8d2b10eb3e0330"><td class="mdescLeft">&#160;</td><td class="mdescRight">For scans that are missing points (e.g., sky points), this function will attempt to fill in missing points for all scans. This increases the accuracy of LAD calculations because it makes sure all pulses are accounted for.  <br /></td></tr>
<tr class="separator:a53b80def6bff07231b8d2b10eb3e0330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544384a19e7d060c85eb5a8daa1aeef4" id="r_a544384a19e7d060c85eb5a8daa1aeef4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a544384a19e7d060c85eb5a8daa1aeef4">gapfillMisses</a> (uint scanID)</td></tr>
<tr class="memdesc:a544384a19e7d060c85eb5a8daa1aeef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">For scans that are missing points (e.g., sky points), this function will attempt to fill in missing points. This increases the accuracy of LAD calculations because it makes sure all pulses are accounted for.  <br /></td></tr>
<tr class="separator:a544384a19e7d060c85eb5a8daa1aeef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70d9c9fb6ca8c20a818c2bc68d39077" id="r_aa70d9c9fb6ca8c20a818c2bc68d39077"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa70d9c9fb6ca8c20a818c2bc68d39077">gapfillMisses</a> (uint scanID, const bool gapfill_grid_only, const bool add_flags)</td></tr>
<tr class="memdesc:aa70d9c9fb6ca8c20a818c2bc68d39077"><td class="mdescLeft">&#160;</td><td class="mdescRight">For scans that are missing points (e.g., sky points), this function will attempt to fill in missing points. This increases the accuracy of LAD calculations because it makes sure all pulses are accounted for.  <br /></td></tr>
<tr class="separator:aa70d9c9fb6ca8c20a818c2bc68d39077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9aeedaa500516d1c227e5161fb599a" id="r_aff9aeedaa500516d1c227e5161fb599a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff9aeedaa500516d1c227e5161fb599a">calculateLeafAreaGPU</a> ()</td></tr>
<tr class="memdesc:aff9aeedaa500516d1c227e5161fb599a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the leaf area for each grid volume.  <br /></td></tr>
<tr class="separator:aff9aeedaa500516d1c227e5161fb599a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865b46e46b3f20d879a0122b2ec21b7c" id="r_a865b46e46b3f20d879a0122b2ec21b7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a865b46e46b3f20d879a0122b2ec21b7c">calculateLeafAreaGPU</a> (int min_voxel_hits)</td></tr>
<tr class="memdesc:a865b46e46b3f20d879a0122b2ec21b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the leaf area for each grid volume.  <br /></td></tr>
<tr class="separator:a865b46e46b3f20d879a0122b2ec21b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6640bd0d26f6cd8e5b8225fe14eaa4d" id="r_aa6640bd0d26f6cd8e5b8225fe14eaa4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6640bd0d26f6cd8e5b8225fe14eaa4d">calculateLeafAreaGPU_testing</a> (int min_voxel_hits)</td></tr>
<tr class="memdesc:aa6640bd0d26f6cd8e5b8225fe14eaa4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the leaf area for each grid volume.  <br /></td></tr>
<tr class="separator:aa6640bd0d26f6cd8e5b8225fe14eaa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6824b871a54f9a25c0c6d1725cb4ee0" id="r_ac6824b871a54f9a25c0c6d1725cb4ee0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6824b871a54f9a25c0c6d1725cb4ee0">calculateLeafAreaGPU_synthetic</a> (<a class="el" href="classhelios_1_1_context.html">helios::Context</a> *context, bool beamoutput, bool fillAnalytic)</td></tr>
<tr class="memdesc:ac6824b871a54f9a25c0c6d1725cb4ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the leaf area for each grid volume in a synthetic scan using several different method for estimating P.  <br /></td></tr>
<tr class="separator:ac6824b871a54f9a25c0c6d1725cb4ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b23ba7fb6a900ff86d7957fcaa89f83" id="r_a7b23ba7fb6a900ff86d7957fcaa89f83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b23ba7fb6a900ff86d7957fcaa89f83">calculateLeafAreaGPU_equal_weighting</a> (bool beamoutput, bool fillAnalytic)</td></tr>
<tr class="memdesc:a7b23ba7fb6a900ff86d7957fcaa89f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the leaf area for each grid volume using equal weighting method.  <br /></td></tr>
<tr class="separator:a7b23ba7fb6a900ff86d7957fcaa89f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5751d6482bc6747b3b0e8d4566b46ca2" id="r_a5751d6482bc6747b3b0e8d4566b46ca2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5751d6482bc6747b3b0e8d4566b46ca2">calculateLeafAreaGPU_equal_weighting</a> (bool beamoutput, bool fillAnalytic, std::vector&lt; float &gt; constant_G)</td></tr>
<tr class="memdesc:a5751d6482bc6747b3b0e8d4566b46ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the leaf area for each grid volume using equal weighting method.  <br /></td></tr>
<tr class="separator:a5751d6482bc6747b3b0e8d4566b46ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba102c6c5036ffb99b105fb2b4850935" id="r_aba102c6c5036ffb99b105fb2b4850935"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba102c6c5036ffb99b105fb2b4850935">leafReconstructionAlphaMask</a> (float minimum_leaf_group_area, float maximum_leaf_group_area, float leaf_aspect_ratio, const char *mask_file)</td></tr>
<tr class="memdesc:aba102c6c5036ffb99b105fb2b4850935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a leaf reconstruction based on texture-masked Patches within each gridcell. The reconstruction produces Patches for each reconstructed leaf surface, with leaf size automatically estimated algorithmically.  <br /></td></tr>
<tr class="separator:aba102c6c5036ffb99b105fb2b4850935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c80f96188fb83f444e7e08cbf888690" id="r_a0c80f96188fb83f444e7e08cbf888690"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c80f96188fb83f444e7e08cbf888690">leafReconstructionAlphaMask</a> (float minimum_leaf_group_area, float maximum_leaf_group_area, float leaf_aspect_ratio, float leaf_length_constant, const char *mask_file)</td></tr>
<tr class="memdesc:a0c80f96188fb83f444e7e08cbf888690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a leaf reconstruction based on texture-masked Patches within each gridcell. The reconstruction produces Patches for each reconstructed leaf surface, with leaf size set to a constant value.  <br /></td></tr>
<tr class="separator:a0c80f96188fb83f444e7e08cbf888690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d6abb997267bce460c48cf02dc3545" id="r_aa7d6abb997267bce460c48cf02dc3545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7d6abb997267bce460c48cf02dc3545">trunkReconstruction</a> (const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;box_center, const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;box_size, float Lmax, float max_aspect_ratio)</td></tr>
<tr class="memdesc:aa7d6abb997267bce460c48cf02dc3545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstruct the trunk of the tree. In order to do this, you must specify the center and size of a rectangular box that encompasses the tree trunk. This routine will then try to find the largest continuous triangle group, which is assumed to correspond to the trunk.  <br /></td></tr>
<tr class="separator:aa7d6abb997267bce460c48cf02dc3545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e1a7d8dc2df6eba9b798bb2a456473" id="r_a85e1a7d8dc2df6eba9b798bb2a456473"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85e1a7d8dc2df6eba9b798bb2a456473">cropBeamsToGridAngleRange</a> (uint source)</td></tr>
<tr class="memdesc:a85e1a7d8dc2df6eba9b798bb2a456473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete hitpoints that do not pass through / intersect the voxel grid.  <br /></td></tr>
<tr class="separator:a85e1a7d8dc2df6eba9b798bb2a456473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffd90677f0584b05b73183747be4e0c" id="r_acffd90677f0584b05b73183747be4e0c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acffd90677f0584b05b73183747be4e0c">peakFinder</a> (std::vector&lt; float &gt; signal)</td></tr>
<tr class="memdesc:acffd90677f0584b05b73183747be4e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the indices of the peaks of a vector of floats  <br /></td></tr>
<tr class="separator:acffd90677f0584b05b73183747be4e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Primary class for terrestrial LiDAR scan. </p>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8h_source.html#l00270">270</a> of file <a class="el" href="_li_d_a_r_8h_source.html">LiDAR.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1c946f80a3431e82e48fc54c611dca2c" name="a1c946f80a3431e82e48fc54c611dca2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c946f80a3431e82e48fc54c611dca2c">&#9670;&#160;</a></span>LiDARcloud()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LiDARcloud::LiDARcloud </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LiDAR point cloud constructor. </p>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00089">89</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a755ab5b665c80e30a49450ccfa1592d1" name="a755ab5b665c80e30a49450ccfa1592d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755ab5b665c80e30a49450ccfa1592d1">&#9670;&#160;</a></span>addGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::addGrid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1int3.html">helios::int3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ndiv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>rotation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a grid to point cloud instead of reading in from an xml file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">center</td><td>center of the grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Size of the grid in each dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ndiv</td><td>number of cells in the grid in each dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>horizontal rotation in degrees. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00674">674</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a60a1e6e5eeb76df93e99c0bbaa971b93" name="a60a1e6e5eeb76df93e99c0bbaa971b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a1e6e5eeb76df93e99c0bbaa971b93">&#9670;&#160;</a></span>addGridCell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::addGridCell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>global_anchor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>global_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>rotation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1int3.html">helios::int3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>global_ijk</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1int3.html">helios::int3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>global_count</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a cell to the grid, where the cell is part of a larger global rectangular grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">center</td><td>(x,y,z) coordinate of grid center </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">global_anchor</td><td>(x,y,z) coordinate of grid global anchor, i.e., this is the 'center' coordinate entered in the xml file. If grid Nx=Ny=Nz=1, global_anchor=center </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of the grid cell in the x,y,z directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">global_size</td><td>size of the global grid in the x,y,z directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>rotation angle (in radians) of the grid cell about the z-axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">global_ijk</td><td>index within the global grid in the x,y,z directions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">global_count</td><td>total number of cells in global grid in the x,y,z directions </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01799">1799</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="ac850f71f86e2872a78d8ff9bc6df6d08" name="ac850f71f86e2872a78d8ff9bc6df6d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac850f71f86e2872a78d8ff9bc6df6d08">&#9670;&#160;</a></span>addGridCell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::addGridCell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>center</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>rotation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a cell to the grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">center</td><td>(x,y,z) coordinate of grid center. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of the grid cell in the x,y,z directions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>rotation angle (in radians) of the grid cell about the z-axis. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01795">1795</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a2b7b76c26d6dd976bf37c0595b761507" name="a2b7b76c26d6dd976bf37c0595b761507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7b76c26d6dd976bf37c0595b761507">&#9670;&#160;</a></span>addGridToVisualizer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::addGridToVisualizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_visualizer.html">Visualizer</a> *</td>          <td class="paramname"><span class="paramname"><em>visualizer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add all grid cells to the visualizer plug-in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">visualizer</td><td>Pointer to the Visualizer plug-in object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00585">585</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="af8c99daa924206b8172bb3bb1657e251" name="af8c99daa924206b8172bb3bb1657e251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c99daa924206b8172bb3bb1657e251">&#9670;&#160;</a></span>addGridWireFrametoVisualizer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::addGridWireFrametoVisualizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_visualizer.html">Visualizer</a> *</td>          <td class="paramname"><span class="paramname"><em>visualizer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add wire frame of the grid to the visualizer plug-in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">visualizer</td><td>Pointer to the Visualizer plug-in object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00716">716</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a244a1de12e8f6a3518b8715086c28e46" name="a244a1de12e8f6a3518b8715086c28e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244a1de12e8f6a3518b8715086c28e46">&#9670;&#160;</a></span>addHitPoint() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::addHitPoint </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1int2.html">helios::int2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>row_column</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1_r_g_bcolor.html">helios::RGBcolor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>color</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a scan point as a hit by providing the (x,y,z) coordinates and row,column in scan table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>ID of scan hit point to which hit point should be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xyz</td><td>(x,y,z) coordinates of hit point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">row_column</td><td>row (theta index) and column (phi index) for point in scan table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>r-g-b color of the hit point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Map data structure containing floating point data values for the hit point. E.g., "reflectance" could be mapped to a value of 965.2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f01d5c6bdab78ee7bc08c90ba5f2217" name="a6f01d5c6bdab78ee7bc08c90ba5f2217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f01d5c6bdab78ee7bc08c90ba5f2217">&#9670;&#160;</a></span>addHitPoint() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::addHitPoint </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1_spherical_coord.html">helios::SphericalCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a scan point as a hit by providing the (x,y,z) coordinates and scan ray direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>ID of scan hit point to which hit point should be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xyz</td><td>(x,y,z) coordinates of hit point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>Spherical coordinate corresponding to the scanner ray direction for the hit point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If only the (row,column) scan table coordinates are available, use <a class="el" href="struct_scan_metadata.html#ae28f6042e5eae2adaaacbeaaa6109a8c">ScanMetadata::rc2direction()</a> to convert them to a spherical scan direction coordinate. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00171">171</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="ae1955f2181dab90400fcabedb8997c71" name="ae1955f2181dab90400fcabedb8997c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1955f2181dab90400fcabedb8997c71">&#9670;&#160;</a></span>addHitPoint() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::addHitPoint </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1_spherical_coord.html">helios::SphericalCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1_r_g_bcolor.html">helios::RGBcolor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>color</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a scan point as a hit by providing the (x,y,z) coordinates and scan ray direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>ID of scan hit point to which hit point should be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xyz</td><td>(x,y,z) coordinates of hit point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>Spherical coordinate corresponding to the scanner ray direction for the hit point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>r-g-b color of the hit point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If only the (row,column) scan table coordinates are available, use <a class="el" href="struct_scan_metadata.html#ae28f6042e5eae2adaaacbeaaa6109a8c">ScanMetadata::rc2direction()</a> to convert them to a spherical scan direction coordinate. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00194">194</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a794f9370ba56a29651a95709c528a6a4" name="a794f9370ba56a29651a95709c528a6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794f9370ba56a29651a95709c528a6a4">&#9670;&#160;</a></span>addHitPoint() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::addHitPoint </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1_spherical_coord.html">helios::SphericalCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1_r_g_bcolor.html">helios::RGBcolor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>color</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a scan point as a hit by providing the (x,y,z) coordinates and scan ray direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>ID of scan hit point to which hit point should be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xyz</td><td>(x,y,z) coordinates of hit point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>Spherical coordinate corresponding to the scanner ray direction for the hit point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">color</td><td>r-g-b color of the hit point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Map data structure containing floating point data values for the hit point. E.g., "reflectance" could be mapped to a value of 965.2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed09112c241e9d60aea781c9684a2633" name="aed09112c241e9d60aea781c9684a2633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed09112c241e9d60aea781c9684a2633">&#9670;&#160;</a></span>addHitPoint() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::addHitPoint </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>xyz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1_spherical_coord.html">helios::SphericalCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify a scan point as a hit by providing the (x,y,z) coordinates and scan ray direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>ID of scan hit point to which hit point should be added. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xyz</td><td>(x,y,z) coordinates of hit point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>Spherical coordinate corresponding to the scanner ray direction for the hit point. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Map data structure containing floating point data values for the hit point. E.g., "reflectance" could be mapped to a value of 965.2. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2102dd4711658414cca10fd40a66af18" name="a2102dd4711658414cca10fd40a66af18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2102dd4711658414cca10fd40a66af18">&#9670;&#160;</a></span>addHitsToVisualizer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::addHitsToVisualizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_visualizer.html">Visualizer</a> *</td>          <td class="paramname"><span class="paramname"><em>visualizer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>pointsize</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add all hit points to the visualizer plug-in, and color them by their r-g-b color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">visualizer</td><td>Pointer to the Visualizer plugin object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointsize</td><td>Size of scan point in font points. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00521">521</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a6292d1b6fce7638a256e090608c8c309" name="a6292d1b6fce7638a256e090608c8c309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6292d1b6fce7638a256e090608c8c309">&#9670;&#160;</a></span>addHitsToVisualizer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::addHitsToVisualizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_visualizer.html">Visualizer</a> *</td>          <td class="paramname"><span class="paramname"><em>visualizer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>pointsize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>color_value</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add all hit points to the visualizer plug-in, and color them by a hit scalar data value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">visualizer</td><td>Pointer to the Visualizer plugin object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pointsize</td><td>Size of scan point in font points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">color_value</td><td>Label for scalar hit data. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00525">525</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="aeca8578d8b5ecbc92fa669c612196f8c" name="aeca8578d8b5ecbc92fa669c612196f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca8578d8b5ecbc92fa669c612196f8c">&#9670;&#160;</a></span>addLeafReconstructionToContext() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint &gt; LiDARcloud::addLeafReconstructionToContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelios_1_1_context.html">helios::Context</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add reconstructed leaves (texture-masked patches) to the Context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to the Helios context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function creates the following primitive data for each patch 1) "gridCell" which indicates the index of the gridcell that contains the patch, 2) "directFlag" which equals 1 if the leaf was part of the direct reconstruction, and 0 if the leaf was backfilled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00845">845</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="ab2b1545809e3537b4e7e803acc8c13c1" name="ab2b1545809e3537b4e7e803acc8c13c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b1545809e3537b4e7e803acc8c13c1">&#9670;&#160;</a></span>addLeafReconstructionToContext() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint &gt; LiDARcloud::addLeafReconstructionToContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelios_1_1_context.html">helios::Context</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1int2.html">helios::int2</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>subpatches</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add reconstructed leaves (texture-masked patches) to the Context with leaves divided into sub-patches (tiled) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to the Helios context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subpatches</td><td>Number of leaf sub-patches (tiles) in the x- and y- directions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function creates the following primitive data for each patch 1) "gridCell" which indicates the index of the gridcell that contains the patch, 2) "directFlag" which equals 1 if the leaf was part of the direct reconstruction, and 0 if the leaf was backfilled. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00849">849</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a9c9cff3d1f5a68814ff2121d3b12d9b8" name="a9c9cff3d1f5a68814ff2121d3b12d9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9cff3d1f5a68814ff2121d3b12d9b8">&#9670;&#160;</a></span>addLeafReconstructionToVisualizer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::addLeafReconstructionToVisualizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_visualizer.html">Visualizer</a> *</td>          <td class="paramname"><span class="paramname"><em>visualizer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add reconstructed leaves (triangles or alpha masks) to the visualizer plug-in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">visualizer</td><td>Pointer to the Visualizer plugin object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00751">751</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a503c74fc549e5c3b25a5f5bf2d6a8955" name="a503c74fc549e5c3b25a5f5bf2d6a8955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503c74fc549e5c3b25a5f5bf2d6a8955">&#9670;&#160;</a></span>addReconstructedTriangleGroupsToContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint &gt; LiDARcloud::addReconstructedTriangleGroupsToContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelios_1_1_context.html">helios::Context</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add triangle groups used in the direct reconstruction to the Context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to the Helios context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function creates primitive data called "leafGroup" which provides an identifier for each triangle based on the fill group it is in. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00892">892</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="abbe448db446aa64f5ce5a923c597eae8" name="abbe448db446aa64f5ce5a923c597eae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe448db446aa64f5ce5a923c597eae8">&#9670;&#160;</a></span>addScan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint LiDARcloud::addScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_scan_metadata.html">ScanMetadata</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>newscan</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a LiDAR scan to the point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newscan</td><td>LiDAR scan data structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ID for scan that was created </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00139">139</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a65c36191d1f0f82b77ebd2ffa2fe3821" name="a65c36191d1f0f82b77ebd2ffa2fe3821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c36191d1f0f82b77ebd2ffa2fe3821">&#9670;&#160;</a></span>addTrianglesToContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::addTrianglesToContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelios_1_1_context.html">helios::Context</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add triangle geometry to Helios context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to Helios context </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01772">1772</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a11d8d20197aa909080d70954c97395e6" name="a11d8d20197aa909080d70954c97395e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d8d20197aa909080d70954c97395e6">&#9670;&#160;</a></span>addTrianglesToVisualizer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::addTrianglesToVisualizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_visualizer.html">Visualizer</a> *</td>          <td class="paramname"><span class="paramname"><em>visualizer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add all triangles to the visualizer plug-in, and color them by their r-g-b color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">visualizer</td><td>Pointer to the Visualizer plug-in object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00638">638</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a55d1d5c311e4cfa45fa47f36ac875e7f" name="a55d1d5c311e4cfa45fa47f36ac875e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d1d5c311e4cfa45fa47f36ac875e7f">&#9670;&#160;</a></span>addTrianglesToVisualizer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::addTrianglesToVisualizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_visualizer.html">Visualizer</a> *</td>          <td class="paramname"><span class="paramname"><em>visualizer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>gridcell</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add triangles within a given grid cell to the visualizer plug-in, and color them by their r-g-b color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">visualizer</td><td>Pointer to the Visualizer plugin object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gridcell</td><td>Index of grid cell. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00655">655</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a4af78b2f167575f641e867f0f0688dd1" name="a4af78b2f167575f641e867f0f0688dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af78b2f167575f641e867f0f0688dd1">&#9670;&#160;</a></span>addTrunkReconstructionToContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint &gt; LiDARcloud::addTrunkReconstructionToContext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelios_1_1_context.html">helios::Context</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add reconstructed trunk triangles to the Context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to the Helios context </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00925">925</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="aa23c198a2c7492b8b6c865a42971a93d" name="aa23c198a2c7492b8b6c865a42971a93d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23c198a2c7492b8b6c865a42971a93d">&#9670;&#160;</a></span>addTrunkReconstructionToVisualizer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::addTrunkReconstructionToVisualizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_visualizer.html">Visualizer</a> *</td>          <td class="paramname"><span class="paramname"><em>visualizer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add trunk reconstruction to the visualizer plug-in. Colors reconstructed triangles by hit point color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">visualizer</td><td>Pointer to the Visualizer plugin object. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00803">803</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a9fa20f56e1dbb38de35a48a599cda711" name="a9fa20f56e1dbb38de35a48a599cda711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa20f56e1dbb38de35a48a599cda711">&#9670;&#160;</a></span>addTrunkReconstructionToVisualizer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::addTrunkReconstructionToVisualizer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_visualizer.html">Visualizer</a> *</td>          <td class="paramname"><span class="paramname"><em>visualizer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1_r_g_bcolor.html">helios::RGBcolor</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>trunk_color</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add trunk reconstruction to the visualizer plug-in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">visualizer</td><td>Pointer to the Visualizer plugin object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trunk_color</td><td>r-g-b color of trunk. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00825">825</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="ab16514fff6766e89b91409077daf35fc" name="ab16514fff6766e89b91409077daf35fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16514fff6766e89b91409077daf35fc">&#9670;&#160;</a></span>calculateHitGridCellGPU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::calculateHitGridCellGPU </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the grid cell in which each hit point resides for the whole point cloud - GPU accelerated version *&zwj;/. </p>
<dl class="section note"><dt>Note</dt><dd>This function does not return a value, rather, it set the Scan variable &lsquo;hit_vol&rsquo; which is queried by the function &lsquo;Scan::getHitGridCell()&rsquo;. </dd></dl>
<p>Grid cell centers on device (GPU) memory</p>
<p>Grid cell global anchor on device (GPU) memory</p>
<p>Grid sizes on device (GPU) memory</p>
<p>Grid rotations on device (GPU) memory</p>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cu_source.html#l00268">268</a> of file <a class="el" href="_li_d_a_r_8cu_source.html">LiDAR.cu</a>.</p>

</div>
</div>
<a id="aff9aeedaa500516d1c227e5161fb599a" name="aff9aeedaa500516d1c227e5161fb599a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff9aeedaa500516d1c227e5161fb599a">&#9670;&#160;</a></span>calculateLeafAreaGPU() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::calculateLeafAreaGPU </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the leaf area for each grid volume. </p>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cu_source.html#l00897">897</a> of file <a class="el" href="_li_d_a_r_8cu_source.html">LiDAR.cu</a>.</p>

</div>
</div>
<a id="a865b46e46b3f20d879a0122b2ec21b7c" name="a865b46e46b3f20d879a0122b2ec21b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865b46e46b3f20d879a0122b2ec21b7c">&#9670;&#160;</a></span>calculateLeafAreaGPU() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::calculateLeafAreaGPU </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min_voxel_hits</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the leaf area for each grid volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min_voxel_hits</td><td>Minimum number of allowable LiDAR hits per voxel. If the total number of hits in a voxel is less than min_voxel_hits, the calculated leaf area will be set to zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Currently, this version assumes all data is discrete-return. The function calculateLeafAreaGPU_testing() deals with waveform data, but may not be working correctly. In the next version, these two functions will be combined. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cu_source.html#l00901">901</a> of file <a class="el" href="_li_d_a_r_8cu_source.html">LiDAR.cu</a>.</p>

</div>
</div>
<a id="a7b23ba7fb6a900ff86d7957fcaa89f83" name="a7b23ba7fb6a900ff86d7957fcaa89f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b23ba7fb6a900ff86d7957fcaa89f83">&#9670;&#160;</a></span>calculateLeafAreaGPU_equal_weighting() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::calculateLeafAreaGPU_equal_weighting </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>beamoutput</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>fillAnalytic</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the leaf area for each grid volume using equal weighting method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">beamoutput</td><td>if true writes detailed data about each beam to ../beamoutput/beam_data_s_[scan index]_c_[grid cell index].txt. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fillAnalytic</td><td>if true, when the iterative LAD inversion fails, the analytic solution using mean dr will be substituted. If false LAD is set to 999. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>writes voxel level data to ../voxeloutput/voxeloutput.txt </dd></dl>
<p>old code in original calculateLeafAreaGPU_testing() ... do we need to keep this??</p>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cu_source.html#l04029">4029</a> of file <a class="el" href="_li_d_a_r_8cu_source.html">LiDAR.cu</a>.</p>

</div>
</div>
<a id="a5751d6482bc6747b3b0e8d4566b46ca2" name="a5751d6482bc6747b3b0e8d4566b46ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5751d6482bc6747b3b0e8d4566b46ca2">&#9670;&#160;</a></span>calculateLeafAreaGPU_equal_weighting() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::calculateLeafAreaGPU_equal_weighting </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>beamoutput</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>fillAnalytic</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt;</td>          <td class="paramname"><span class="paramname"><em>constant_G</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the leaf area for each grid volume using equal weighting method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">beamoutput</td><td>if true writes detailed data about each beam to ../beamoutput/beam_data_s_[scan index]_c_[grid cell index].txt. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fillAnalytic</td><td>if true, when the iterative LAD inversion fails, the analytic solution using mean dr will be substituted. If false LAD is set to 999. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constant_G</td><td>A separate LAD inversion will be performed for each element of this vector, setting the value of G in all voxels to the value given in this vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>writes voxel level data to ../voxeloutput/voxeloutput.txt </dd></dl>
<p>old code in original calculateLeafAreaGPU_testing() ... do we need to keep this??</p>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cu_source.html#l04483">4483</a> of file <a class="el" href="_li_d_a_r_8cu_source.html">LiDAR.cu</a>.</p>

</div>
</div>
<a id="ac6824b871a54f9a25c0c6d1725cb4ee0" name="ac6824b871a54f9a25c0c6d1725cb4ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6824b871a54f9a25c0c6d1725cb4ee0">&#9670;&#160;</a></span>calculateLeafAreaGPU_synthetic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::calculateLeafAreaGPU_synthetic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelios_1_1_context.html">helios::Context</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>beamoutput</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>fillAnalytic</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the leaf area for each grid volume in a synthetic scan using several different method for estimating P. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to the Helios context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beamoutput</td><td>if true writes detailed data about each beam to ../beamoutput/beam_data_s_[scan index]_c_[grid cell index].txt. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fillAnalytic</td><td>if true, when the iterative LAD inversion fails, the analytic solution using mean dr will be substituted. If false LAD is set to 999. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>writes voxel level data to ../voxeloutput/voxeloutput.txt </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cu_source.html#l01690">1690</a> of file <a class="el" href="_li_d_a_r_8cu_source.html">LiDAR.cu</a>.</p>

</div>
</div>
<a id="aa6640bd0d26f6cd8e5b8225fe14eaa4d" name="aa6640bd0d26f6cd8e5b8225fe14eaa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6640bd0d26f6cd8e5b8225fe14eaa4d">&#9670;&#160;</a></span>calculateLeafAreaGPU_testing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::calculateLeafAreaGPU_testing </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>min_voxel_hits</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the leaf area for each grid volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min_voxel_hits</td><td>Minimum number of allowable LiDAR hits per voxel. If the total number of hits in a voxel is less than min_voxel_hits, the calculated leaf area will be set to zero. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cu_source.html#l01359">1359</a> of file <a class="el" href="_li_d_a_r_8cu_source.html">LiDAR.cu</a>.</p>

</div>
</div>
<a id="a94fe14aa32343dc25e366fe2ad7dfdfd" name="a94fe14aa32343dc25e366fe2ad7dfdfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94fe14aa32343dc25e366fe2ad7dfdfd">&#9670;&#160;</a></span>calculateSyntheticGtheta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; LiDARcloud::calculateSyntheticGtheta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelios_1_1_context.html">helios::Context</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the G(theta) of all primitives in the context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to the Helios context </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01849">1849</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a22f9c93700be5e5a808b97ecca6752fe" name="a22f9c93700be5e5a808b97ecca6752fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f9c93700be5e5a808b97ecca6752fe">&#9670;&#160;</a></span>calculateSyntheticLeafArea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; LiDARcloud::calculateSyntheticLeafArea </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelios_1_1_context.html">helios::Context</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the surface area of all primitives in the context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to the Helios context </td></tr>
  </table>
  </dd>
</dl>
<p>Grid cell centers on device (GPU) memory</p>
<p>Grid cell global anchor on device (GPU) memory</p>
<p>Grid sizes on device (GPU) memory</p>
<p>Grid rotations on device (GPU) memory</p>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cu_source.html#l03712">3712</a> of file <a class="el" href="_li_d_a_r_8cu_source.html">LiDAR.cu</a>.</p>

</div>
</div>
<a id="a263717159dde05f5b98ae4133dec3d5e" name="a263717159dde05f5b98ae4133dec3d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263717159dde05f5b98ae4133dec3d5e">&#9670;&#160;</a></span>coordinateRotation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::coordinateRotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1_spherical_coord.html">helios::SphericalCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rotation</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate all points in the point cloud about the origin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Spherical rotation angle </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00464">464</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="abf2f7677b1a92cba5b51ad0336e3743e" name="abf2f7677b1a92cba5b51ad0336e3743e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2f7677b1a92cba5b51ad0336e3743e">&#9670;&#160;</a></span>coordinateRotation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::coordinateRotation </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>rotation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>line_base</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>line_direction</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate all points in the point cloud about an arbitrary line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Spherical rotation angle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line_base</td><td>(x,y,z) coordinate of a point on the line about which points will be rotated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line_direction</td><td>Unit vector pointing in the direction of the line about which points will be rotated </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00494">494</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="aeae9aaa404a67082f849e1c8d56579e5" name="aeae9aaa404a67082f849e1c8d56579e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae9aaa404a67082f849e1c8d56579e5">&#9670;&#160;</a></span>coordinateRotation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::coordinateRotation </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1_spherical_coord.html">helios::SphericalCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rotation</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate all points in the point cloud about the origin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>ID of scan to be shifted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rotation</td><td>Spherical rotation angle </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00477">477</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a72bc752975f8783ad8b1710cefa1d2a9" name="a72bc752975f8783ad8b1710cefa1d2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72bc752975f8783ad8b1710cefa1d2a9">&#9670;&#160;</a></span>coordinateShift() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::coordinateShift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shift</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a translation to all points in the point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shift</td><td>Distance to translate in x-, y-, and z- direction </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00436">436</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="ab37566564d8e421a123c8b1b8cdb2347" name="ab37566564d8e421a123c8b1b8cdb2347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37566564d8e421a123c8b1b8cdb2347">&#9670;&#160;</a></span>coordinateShift() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::coordinateShift </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>shift</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a translation to all points in a given scan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>ID of scan to be shifted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shift</td><td>Distance to translate in x-, y-, and z- direction </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00448">448</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a85e1a7d8dc2df6eba9b798bb2a456473" name="a85e1a7d8dc2df6eba9b798bb2a456473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e1a7d8dc2df6eba9b798bb2a456473">&#9670;&#160;</a></span>cropBeamsToGridAngleRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::cropBeamsToGridAngleRange </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete hitpoints that do not pass through / intersect the voxel grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>the scan index </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l02494">2494</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="accf5ec6015b0b68c89716ffff1a016bb" name="accf5ec6015b0b68c89716ffff1a016bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf5ec6015b0b68c89716ffff1a016bb">&#9670;&#160;</a></span>deleteHitPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::deleteHitPoint </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a hit point in the scan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index of hit point in the point cloud </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00237">237</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="af5d0590b160e7069826c52eeeb4e0129" name="af5d0590b160e7069826c52eeeb4e0129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d0590b160e7069826c52eeeb4e0129">&#9670;&#160;</a></span>disableMessages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::disableMessages </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable all print messages to the screen except for fatal error messages. </p>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00100">100</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="af21b843806f22fb9bc80e7ef370aee1d" name="af21b843806f22fb9bc80e7ef370aee1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21b843806f22fb9bc80e7ef370aee1d">&#9670;&#160;</a></span>distanceFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::distanceFilter </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>maxdistance</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter scan by imposing a maximum distance from the scanner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">maxdistance</td><td>Maximum hit point distance from scanner </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01035">1035</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="aabb8d404b7f3fa00d8281cb6b74f90c0" name="aabb8d404b7f3fa00d8281cb6b74f90c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb8d404b7f3fa00d8281cb6b74f90c0">&#9670;&#160;</a></span>doesHitDataExist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LiDARcloud::doesHitDataExist </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>label</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if scalar data exists for a hit point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Hit number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>Label of the data value (e.g., "reflectance"). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00360">360</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a2e87dc18538155b35368ff27ed6a1504" name="a2e87dc18538155b35368ff27ed6a1504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e87dc18538155b35368ff27ed6a1504">&#9670;&#160;</a></span>enableMessages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::enableMessages </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable all print messages to the screen. </p>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00104">104</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="af680cbb9eb0c1ebf49f71f0062d18c0c" name="af680cbb9eb0c1ebf49f71f0062d18c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af680cbb9eb0c1ebf49f71f0062d18c0c">&#9670;&#160;</a></span>exportGtheta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::exportGtheta </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export to file the G(theta) value within each grid cell. Lines of the file correspond to each grid cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of file </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html#l00780">780</a> of file <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html">fileIO.cpp</a>.</p>

</div>
</div>
<a id="a6e438fd60af7f54f4d1c09ac64fd7338" name="a6e438fd60af7f54f4d1c09ac64fd7338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e438fd60af7f54f4d1c09ac64fd7338">&#9670;&#160;</a></span>exportLeafAreaDensities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::exportLeafAreaDensities </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export to file the leaf area density within each grid cell. Lines of the file correspond to each grid cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of file </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html#l00760">760</a> of file <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html">fileIO.cpp</a>.</p>

</div>
</div>
<a id="a8e8bd43bf3b2c107994fee402c41240f" name="a8e8bd43bf3b2c107994fee402c41240f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8bd43bf3b2c107994fee402c41240f">&#9670;&#160;</a></span>exportLeafAreas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::exportLeafAreas </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export to file the leaf area within each grid cell. Lines of the file correspond to each grid cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of file </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html#l00740">740</a> of file <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html">fileIO.cpp</a>.</p>

</div>
</div>
<a id="a2d0c11c6d8001171269232ff5d7f6322" name="a2d0c11c6d8001171269232ff5d7f6322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0c11c6d8001171269232ff5d7f6322">&#9670;&#160;</a></span>exportPointCloud() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::exportPointCloud </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export to file all points in the point cloud to an ASCII text file following the column format specified by the &lt;ASCII_format&gt;&lt;/ASCII_format&gt; tag in the scan XML file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If there are multiple scans in the point cloud, each scan will be exported to a different file with the scan ID appended to the filename. This is because different scans may have a different column format. </dd></dl>

<p class="definition">Definition at line <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html#l00800">800</a> of file <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html">fileIO.cpp</a>.</p>

</div>
</div>
<a id="ae9910fa1aae6b8b077d57417c130e753" name="ae9910fa1aae6b8b077d57417c130e753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9910fa1aae6b8b077d57417c130e753">&#9670;&#160;</a></span>exportPointCloud() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::exportPointCloud </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export to file all points from a given scan to an ASCII text file following the column format specified by the &lt;ASCII_format&gt;&lt;/ASCII_format&gt; tag in the scan XML file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>Identifier of scan to be exported </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html#l00828">828</a> of file <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html">fileIO.cpp</a>.</p>

</div>
</div>
<a id="ac48fe9018f26664dd9abd8c100fccaa6" name="ac48fe9018f26664dd9abd8c100fccaa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48fe9018f26664dd9abd8c100fccaa6">&#9670;&#160;</a></span>exportPointCloudPTX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::exportPointCloudPTX </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export to file all points from a given scan to PTX file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>Identifier of scan to be exported </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html#l00915">915</a> of file <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html">fileIO.cpp</a>.</p>

</div>
</div>
<a id="a416638f486c4fd2572a9589b69605fe7" name="a416638f486c4fd2572a9589b69605fe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416638f486c4fd2572a9589b69605fe7">&#9670;&#160;</a></span>exportTriangleAreas() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::exportTriangleAreas </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export to file the area of all triangles formed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of file </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html#l00562">562</a> of file <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html">fileIO.cpp</a>.</p>

</div>
</div>
<a id="adb93e3a16abc8100b2e5dac956c6cc3e" name="adb93e3a16abc8100b2e5dac956c6cc3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb93e3a16abc8100b2e5dac956c6cc3e">&#9670;&#160;</a></span>exportTriangleAreas() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::exportTriangleAreas </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>gridcell</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export to file the area of all triangles formed within a single grid cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gridcell</td><td>Index of gridcell to get triangles from </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html#l00584">584</a> of file <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html">fileIO.cpp</a>.</p>

</div>
</div>
<a id="ab9a33b5d05470e8e0362de352fc09bf1" name="ab9a33b5d05470e8e0362de352fc09bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a33b5d05470e8e0362de352fc09bf1">&#9670;&#160;</a></span>exportTriangleAzimuthDistribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::exportTriangleAzimuthDistribution </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>Nbins</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export to file discrete azimuthal angle probability distribution based on the triangulation. Azimuthal angles are between 0 and 360 degrees. The probability distribution is normalized such that the integral over all angles is 1. The value of each bin is written as a column in the output file; lines correspond to each voxel grid cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nbins</td><td>Number of bins to use for the histogram </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html#l00671">671</a> of file <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html">fileIO.cpp</a>.</p>

</div>
</div>
<a id="aadeb8297b74a75fd003f6c96fe378043" name="aadeb8297b74a75fd003f6c96fe378043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadeb8297b74a75fd003f6c96fe378043">&#9670;&#160;</a></span>exportTriangleInclinationDistribution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::exportTriangleInclinationDistribution </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>Nbins</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export to file discrete area-weighted inclination angle probability distribution based on the triangulation. Inclination angles are between 0 and 90 degrees. The probability distribution is normalized such that the sine-weighted integral over all angles is 1. The value of each bin is written as a column in the output file; lines correspond to each voxel grid cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nbins</td><td>Number of bins to use for the histogram </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html#l00610">610</a> of file <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html">fileIO.cpp</a>.</p>

</div>
</div>
<a id="ad030fdddcfa669d6af513eb66a9cbd1a" name="ad030fdddcfa669d6af513eb66a9cbd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad030fdddcfa669d6af513eb66a9cbd1a">&#9670;&#160;</a></span>exportTriangleNormals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::exportTriangleNormals </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export to file the normal vectors (nx,ny,nz) for all triangles formed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of file </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html#l00499">499</a> of file <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html">fileIO.cpp</a>.</p>

</div>
</div>
<a id="aa8376ce652d2e95e886d4d60d321c274" name="aa8376ce652d2e95e886d4d60d321c274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8376ce652d2e95e886d4d60d321c274">&#9670;&#160;</a></span>exportTriangleNormals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::exportTriangleNormals </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>gridcell</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export to file the normal vectors (nx,ny,nz) for triangles formed within a single gridcell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Name of file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gridcell</td><td>Index of gridcell to get triangles from </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html#l00528">528</a> of file <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html">fileIO.cpp</a>.</p>

</div>
</div>
<a id="a869540860f4cace62dbd2fb54353bd33" name="a869540860f4cace62dbd2fb54353bd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869540860f4cace62dbd2fb54353bd33">&#9670;&#160;</a></span>firstHitFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::firstHitFilter </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter full-waveform data to include only the first hit per laser pulse. The resulting point cloud will have only one hit point per laser pulse (first hits). </p>
<dl class="section note"><dt>Note</dt><dd>This function is only applicable for full-waveform data and requires that the scalar field "target_index" is provided in the hit point data file. The "target_index" values can start at 0 or 1 for first hits as long as it is consistent throughout the point cloud. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01296">1296</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a53b80def6bff07231b8d2b10eb3e0330" name="a53b80def6bff07231b8d2b10eb3e0330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b80def6bff07231b8d2b10eb3e0330">&#9670;&#160;</a></span>gapfillMisses() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &gt; LiDARcloud::gapfillMisses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For scans that are missing points (e.g., sky points), this function will attempt to fill in missing points for all scans. This increases the accuracy of LAD calculations because it makes sure all pulses are accounted for. </p>
<dl class="section return"><dt>Returns</dt><dd>(x,y,z) of missing points added to the scan from gapfilling </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cu_source.html#l00492">492</a> of file <a class="el" href="_li_d_a_r_8cu_source.html">LiDAR.cu</a>.</p>

</div>
</div>
<a id="a544384a19e7d060c85eb5a8daa1aeef4" name="a544384a19e7d060c85eb5a8daa1aeef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544384a19e7d060c85eb5a8daa1aeef4">&#9670;&#160;</a></span>gapfillMisses() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &gt; LiDARcloud::gapfillMisses </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For scans that are missing points (e.g., sky points), this function will attempt to fill in missing points. This increases the accuracy of LAD calculations because it makes sure all pulses are accounted for. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>ID of scan to gapfill </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(x,y,z) of missing points added to the scan from gapfilling </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cu_source.html#l00501">501</a> of file <a class="el" href="_li_d_a_r_8cu_source.html">LiDAR.cu</a>.</p>

</div>
</div>
<a id="aa70d9c9fb6ca8c20a818c2bc68d39077" name="aa70d9c9fb6ca8c20a818c2bc68d39077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70d9c9fb6ca8c20a818c2bc68d39077">&#9670;&#160;</a></span>gapfillMisses() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &gt; LiDARcloud::gapfillMisses </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>gapfill_grid_only</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>add_flags</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For scans that are missing points (e.g., sky points), this function will attempt to fill in missing points. This increases the accuracy of LAD calculations because it makes sure all pulses are accounted for. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>ID of scan to gapfill </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gapfill_grid_only</td><td>if true, missing points are gapfilled only within the axis-aligned bounding box of the voxel grid. If false missing points are gap filled across the range of phi and theta values specified in the scan xml file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add_flags</td><td>if true, gapfillMisses_code is added as hitpoint data. 0 = original points, 1 = gapfilled, 2 = extrapolated at downward edge, 3 = extrapolated at upward edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(x,y,z) of missing points added to the scan from gapfilling </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cu_source.html#l00505">505</a> of file <a class="el" href="_li_d_a_r_8cu_source.html">LiDAR.cu</a>.</p>

</div>
</div>
<a id="a6e2ce01abb33cc0f80b2aa653ac6a445" name="a6e2ce01abb33cc0f80b2aa653ac6a445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2ce01abb33cc0f80b2aa653ac6a445">&#9670;&#160;</a></span>getCellCenter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> LiDARcloud::getCellCenter </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the (x,y,z) coordinate of a grid cell by its index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index of a grid cell. Note: the index of a grid cell is given by the order in which it was added to the grid. E.g., the first cell's index is 0, and the last cell's index is Ncells-1. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01809">1809</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="ad1ad4f851b5b7fcbf5b088b161aed83e" name="ad1ad4f851b5b7fcbf5b088b161aed83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ad4f851b5b7fcbf5b088b161aed83e">&#9670;&#160;</a></span>getCellGlobalAnchor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> LiDARcloud::getCellGlobalAnchor </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the (x,y,z) coordinate of a grid global anchor by its index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index of a grid cell. Note: the index of a grid cell is given by the order in which it was added to the grid. E.g., the first cell's index is 0, and the last cell's index is Ncells-1. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01819">1819</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a54351e18e3f4155e9d55eb02bd63c722" name="a54351e18e3f4155e9d55eb02bd63c722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54351e18e3f4155e9d55eb02bd63c722">&#9670;&#160;</a></span>getCellGtheta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LiDARcloud::getCellGtheta </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the G(theta) of a grid cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index of a grid cell. Note: the index of a grid cell is given by the order in which it was added to the grid. E.g., the first cell's index is 0, and the last cell's index is Ncells-1. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01959">1959</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="ac9d20a35bdb7ee2d45490ac1cd520117" name="ac9d20a35bdb7ee2d45490ac1cd520117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d20a35bdb7ee2d45490ac1cd520117">&#9670;&#160;</a></span>getCellLeafArea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LiDARcloud::getCellLeafArea </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the leaf area of a grid cell in m^2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index of a grid cell. Note: the index of a grid cell is given by the order in which it was added to the grid. E.g., the first cell's index is 0, and the last cell's index is Ncells-1. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01928">1928</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a3c1744984481f9629dc1371291fa397e" name="a3c1744984481f9629dc1371291fa397e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1744984481f9629dc1371291fa397e">&#9670;&#160;</a></span>getCellLeafAreaDensity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LiDARcloud::getCellLeafAreaDensity </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the leaf area density of a grid cell in 1/m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index of a grid cell. Note: the index of a grid cell is given by the order in which it was added to the grid. E.g., the first cell's index is 0, and the last cell's index is Ncells-1. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01938">1938</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="aa2cba1d0bcd9a2ae35d9a5be03832efc" name="aa2cba1d0bcd9a2ae35d9a5be03832efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cba1d0bcd9a2ae35d9a5be03832efc">&#9670;&#160;</a></span>getCellRotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LiDARcloud::getCellRotation </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of a grid cell by its index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index of a grid cell. Note: the index of a grid cell is given by the order in which it was added to the grid. E.g., the first cell's index is 0, and the last cell's index is Ncells-1. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01839">1839</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a6662330b95ee7ee77ea6647871695c55" name="a6662330b95ee7ee77ea6647871695c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6662330b95ee7ee77ea6647871695c55">&#9670;&#160;</a></span>getCellSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> LiDARcloud::getCellSize </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of a grid cell by its index. </p>
<pre class="fragment"> \param[in] index Index of a grid cell.  Note: the index of a grid cell is given by the order in which it was added to the grid. E.g., the first cell's index is 0, an
</pre><p> d the last cell's index is Ncells-1. </p>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01829">1829</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a041ac4ba388c407a35b7f895029038e6" name="a041ac4ba388c407a35b7f895029038e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041ac4ba388c407a35b7f895029038e6">&#9670;&#160;</a></span>getGridBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::getGridBoundingBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>boxmin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>boxmax</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Form an axis-aligned bounding box for all grid cells in the point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">boxmin</td><td>Coordinates of the bounding box vertex in the (-x,-y,-z) direction. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">boxmax</td><td>Coordinates of the bounding box vertex in the (+x,+y,+z) direction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00988">988</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a28297a71becd69b30820d69b110fcc90" name="a28297a71becd69b30820d69b110fcc90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28297a71becd69b30820d69b110fcc90">&#9670;&#160;</a></span>getGridCellCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint LiDARcloud::getGridCellCount </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of cells in the grid. </p>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01791">1791</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a45bc37a4d26eb74a944c594a7f3cb54b" name="a45bc37a4d26eb74a944c594a7f3cb54b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bc37a4d26eb74a944c594a7f3cb54b">&#9670;&#160;</a></span>getHitBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::getHitBoundingBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>boxmin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>boxmax</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Form an axis-aligned bounding box for all hit points in the point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">boxmin</td><td>Coordinates of the bounding box vertex in the (-x,-y,-z) direction. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">boxmax</td><td>Coordinates of the bounding box vertex in the (+x,+y,+z) direction. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00951">951</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="aafafed9102966992d3cfb3772fa2ada1" name="aafafed9102966992d3cfb3772fa2ada1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafafed9102966992d3cfb3772fa2ada1">&#9670;&#160;</a></span>getHitColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhelios_1_1_r_g_bcolor.html">RGBcolor</a> LiDARcloud::getHitColor </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get color of hit point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Hit number </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00375">375</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a691fd3bbd1262d80e10a674c82c6f568" name="a691fd3bbd1262d80e10a674c82c6f568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691fd3bbd1262d80e10a674c82c6f568">&#9670;&#160;</a></span>getHitCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint LiDARcloud::getHitCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of hit points in the point cloud. </p>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00254">254</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a274ef68850afa3f288bb648d9fd6a59a" name="a274ef68850afa3f288bb648d9fd6a59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274ef68850afa3f288bb648d9fd6a59a">&#9670;&#160;</a></span>getHitData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LiDARcloud::getHitData </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>label</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get floating point data value associated with a hit point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Hit number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>Label of the data value (e.g., "reflectance"). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value of scalar data. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00345">345</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a251c4f3bbefdd07212cd8fe1037dc0d7" name="a251c4f3bbefdd07212cd8fe1037dc0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251c4f3bbefdd07212cd8fe1037dc0d7">&#9670;&#160;</a></span>getHitGridCell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LiDARcloud::getHitGridCell </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the grid cell in which the hit point resides. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Hit number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the point does not reside in any grid cells, this function returns &lsquo;-1&rsquo;. </dd>
<dd>
Calling this function requires that the function calculateHitGridCell[*]() has been called previously. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00413">413</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a34eee980f365fdd5469a0cc6ee3a36f5" name="a34eee980f365fdd5469a0cc6ee3a36f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34eee980f365fdd5469a0cc6ee3a36f5">&#9670;&#160;</a></span>getHitIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LiDARcloud::getHitIndex </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>column</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of a scan point based on its row and column in the hit table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>ID of scan. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>Row in the 2D scan data table (elevation angle). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">column</td><td>Column in the 2D scan data table (azimuthal angle). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the point was not a hit, the function will return &lsquo;-1&rsquo;. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00395">395</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="aa91258bd97d6fcacd3313d8b55cceed4" name="aa91258bd97d6fcacd3313d8b55cceed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91258bd97d6fcacd3313d8b55cceed4">&#9670;&#160;</a></span>getHitRaydir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhelios_1_1_spherical_coord.html">helios::SphericalCoord</a> LiDARcloud::getHitRaydir </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ray direction of hit point in the scan based on its index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Hit number </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00324">324</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a5510b2a0d0a878930e9f11331494bf41" name="a5510b2a0d0a878930e9f11331494bf41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5510b2a0d0a878930e9f11331494bf41">&#9670;&#160;</a></span>getHitScanID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LiDARcloud::getHitScanID </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the scan with which a hit is associated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Hit number </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00385">385</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="ac5f234b6200419f10fe82c9abe409cbd" name="ac5f234b6200419f10fe82c9abe409cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f234b6200419f10fe82c9abe409cbd">&#9670;&#160;</a></span>getHitXYZ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> LiDARcloud::getHitXYZ </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get (x,y,z) coordinate of hit point by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Hit number </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00314">314</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a9d93e6cd9decccf271fbf3fbd5c74a5a" name="a9d93e6cd9decccf271fbf3fbd5c74a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d93e6cd9decccf271fbf3fbd5c74a5a">&#9670;&#160;</a></span>getScanBeamDivergence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LiDARcloud::getScanBeamDivergence </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divergence angle of the laser beam in radians. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>ID of scan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Divergence angle of the beam. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00300">300</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="abab6b81a3d96226a766cc2450993407f" name="abab6b81a3d96226a766cc2450993407f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab6b81a3d96226a766cc2450993407f">&#9670;&#160;</a></span>getScanBeamExitDiameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LiDARcloud::getScanBeamExitDiameter </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the diameter of the laser beam at exit from the instrument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>ID of scan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Diameter of the beam at exit. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00293">293</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="abbe892f01508dc69bcc5b28bea5472bf" name="abbe892f01508dc69bcc5b28bea5472bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe892f01508dc69bcc5b28bea5472bf">&#9670;&#160;</a></span>getScanColumnFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; LiDARcloud::getScanColumnFormat </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the labels for columns in ASCII input/output file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>ID of scan. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00307">307</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="aaa463ea1aaebb03abd8c3ec87091291a" name="aaa463ea1aaebb03abd8c3ec87091291a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa463ea1aaebb03abd8c3ec87091291a">&#9670;&#160;</a></span>getScanCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint LiDARcloud::getScanCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of scans in point cloud. </p>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00135">135</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="aa657ed32a8831ebf4f2e4a9203b683ef" name="aa657ed32a8831ebf4f2e4a9203b683ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa657ed32a8831ebf4f2e4a9203b683ef">&#9670;&#160;</a></span>getScanOrigin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> LiDARcloud::getScanOrigin </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the (x,y,z) scan origin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>ID of scan. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00258">258</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="ab314aac88834eb3938fc2f37e34807e3" name="ab314aac88834eb3938fc2f37e34807e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab314aac88834eb3938fc2f37e34807e3">&#9670;&#160;</a></span>getScanRangePhi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhelios_1_1vec2.html">helios::vec2</a> LiDARcloud::getScanRangePhi </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the range of scan directions in the phi (azimuthal) direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>ID of scan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vec2.x is the minimum scan azimuthal angle, and vec2.y is the maximum scan azimuthal angle, both in radians </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00286">286</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a7f0237a83da6997e973fde9939440979" name="a7f0237a83da6997e973fde9939440979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0237a83da6997e973fde9939440979">&#9670;&#160;</a></span>getScanRangeTheta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhelios_1_1vec2.html">helios::vec2</a> LiDARcloud::getScanRangeTheta </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the range of scan directions in the theta (zenithal) direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>ID of scan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vec2.x is the minimum scan zenithal angle, and vec2.y is the maximum scan zenithal angle, both in radians </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00279">279</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="aaf04cd04c2b1bc162106a0e47cff6d29" name="aaf04cd04c2b1bc162106a0e47cff6d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf04cd04c2b1bc162106a0e47cff6d29">&#9670;&#160;</a></span>getScanSizePhi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint LiDARcloud::getScanSizePhi </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of scan points in the phi (azimuthal) direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>ID of scan. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00272">272</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a40809c7a709a6c9ccb4beddca21f8ac9" name="a40809c7a709a6c9ccb4beddca21f8ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40809c7a709a6c9ccb4beddca21f8ac9">&#9670;&#160;</a></span>getScanSizeTheta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint LiDARcloud::getScanSizeTheta </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>scanID</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of scan points in the theta (zenithal) direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scanID</td><td>ID of scan. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00265">265</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="aa1a1af5eea22185e59c267c8e4d94c9e" name="aa1a1af5eea22185e59c267c8e4d94c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a1af5eea22185e59c267c8e4d94c9e">&#9670;&#160;</a></span>getTriangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_triangulation.html">Triangulation</a> LiDARcloud::getTriangle </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get hit point corresponding to first vertex of triangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Triangulation index (0 thru Ntriangles-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hit point index (0 thru Nhits-1) </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00512">512</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="abcdbf834959379a189a60efed41f3e52" name="abcdbf834959379a189a60efed41f3e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcdbf834959379a189a60efed41f3e52">&#9670;&#160;</a></span>getTriangleCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint LiDARcloud::getTriangleCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of triangles formed by the triangulation. </p>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00508">508</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="ab812d48fd5d81a8cc382bf0d1214496d" name="ab812d48fd5d81a8cc382bf0d1214496d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab812d48fd5d81a8cc382bf0d1214496d">&#9670;&#160;</a></span>lastHitFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::lastHitFilter </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter full-waveform data to include only the last hit per laser pulse. The resulting point cloud will have only one hit point per laser pulse (last hits). </p>
<dl class="section note"><dt>Note</dt><dd>This function is only applicable for full-waveform data and requires that the scalar fields "target_index" and "target_count" are provided in the hit point data file. The "target_index" values can start at 0 or 1 for first hits as long as it is consistent throughout the point cloud. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01336">1336</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="aba102c6c5036ffb99b105fb2b4850935" name="aba102c6c5036ffb99b105fb2b4850935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba102c6c5036ffb99b105fb2b4850935">&#9670;&#160;</a></span>leafReconstructionAlphaMask() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::leafReconstructionAlphaMask </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>minimum_leaf_group_area</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>maximum_leaf_group_area</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>leaf_aspect_ratio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>mask_file</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a leaf reconstruction based on texture-masked Patches within each gridcell. The reconstruction produces Patches for each reconstructed leaf surface, with leaf size automatically estimated algorithmically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">minimum_leaf_group_area</td><td>Minimum allowable area of leaf triangular fill groups. Leaf fill groups with total areas less than minimum_leaf_group_area are not considered in the reconstruction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maximum_leaf_group_area</td><td>Maximum area of leaf triangular fill groups. Leaf fill groups with total areas greater than maximum_leaf_group_area are not considered in the reconstruction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">leaf_aspect_ratio</td><td>Ratio of length of leaf along midrib to with of leaf perpendicular to leaf midrib. This will generally be the length/width of leaf mask. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask_file</td><td>Path to PNG image file to be used with Alpha Mask. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l02074">2074</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a0c80f96188fb83f444e7e08cbf888690" name="a0c80f96188fb83f444e7e08cbf888690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c80f96188fb83f444e7e08cbf888690">&#9670;&#160;</a></span>leafReconstructionAlphaMask() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::leafReconstructionAlphaMask </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>minimum_leaf_group_area</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>maximum_leaf_group_area</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>leaf_aspect_ratio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>leaf_length_constant</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>mask_file</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a leaf reconstruction based on texture-masked Patches within each gridcell. The reconstruction produces Patches for each reconstructed leaf surface, with leaf size set to a constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">minimum_leaf_group_area</td><td>Minimum allowable area of leaf triangular fill groups. Leaf fill groups with total areas less than minimum_leaf_group_area are not considered in the reconstruction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maximum_leaf_group_area</td><td>Maximum area of leaf triangular fill groups. Leaf fill groups with total areas greater than maximum_leaf_group_area are not considered in the reconstruction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">leaf_aspect_ratio</td><td>Ratio of length of leaf along midrib to with of leaf perpendicular to leaf midrib. This will generally be the length/width of leaf mask. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">leaf_length_constant</td><td>Constant length of all reconstructed leaves. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask_file</td><td>Path to PNG image file to be used with Alpha Mask. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l02078">2078</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a6bd7e1839d1a6ecb738233b20b93f1f7" name="a6bd7e1839d1a6ecb738233b20b93f1f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd7e1839d1a6ecb738233b20b93f1f7">&#9670;&#160;</a></span>loadXML() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::loadXML </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an XML file containing scan information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Path to XML file </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html#l00022">22</a> of file <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html">fileIO.cpp</a>.</p>

</div>
</div>
<a id="ac966b0aae37889c288277b950b2fd30a" name="ac966b0aae37889c288277b950b2fd30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac966b0aae37889c288277b950b2fd30a">&#9670;&#160;</a></span>loadXML() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::loadXML </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>load_grid_only</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an XML file containing scan information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Path to XML file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">load_grid_only</td><td>if true only the voxel grid defined in the xml file will be loaded, the scans themselves will not be loaded. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html#l00026">26</a> of file <a class="el" href="lidar_2src_2file_i_o_8cpp_source.html">fileIO.cpp</a>.</p>

</div>
</div>
<a id="aa5c2bd82b67b3e84069090d75ed2973d" name="aa5c2bd82b67b3e84069090d75ed2973d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c2bd82b67b3e84069090d75ed2973d">&#9670;&#160;</a></span>maxPulseFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::maxPulseFilter </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter full-waveform data according to the maximum scalar value along each pulse. Any scalar value can be used, provided it is a field in the hit point data file. The resulting point cloud will have only one hit point per laser pulse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>Name of hit point scalar data in the hit data file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is only applicable for full-waveform data and requires that the scalar field "timestamp" is provided in the ASCII hit point data file. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01164">1164</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a530582b532eb13ca938d5e843d902327" name="a530582b532eb13ca938d5e843d902327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530582b532eb13ca938d5e843d902327">&#9670;&#160;</a></span>minPulseFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::minPulseFilter </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>scalar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter full-waveform data according to the minimum scalar value along each pulse. Any scalar value can be used, provided it is a field in the hit point data file. The resulting point cloud will have only one hit point per laser pulse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>Name of hit point scalar data in the ASCII hit data file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is only applicable for full-waveform data and requires that the scalar field "timestamp" is provided in the hit point data file. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01230">1230</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="acffd90677f0584b05b73183747be4e0c" name="acffd90677f0584b05b73183747be4e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffd90677f0584b05b73183747be4e0c">&#9670;&#160;</a></span>peakFinder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint &gt; LiDARcloud::peakFinder </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt;</td>          <td class="paramname"><span class="paramname"><em>signal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find the indices of the peaks of a vector of floats </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">signal</td><td>the signal we want to detect peaks in </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cu_source.html#l04984">4984</a> of file <a class="el" href="_li_d_a_r_8cu_source.html">LiDAR.cu</a>.</p>

</div>
</div>
<a id="adf2d9ef2301fd7fdee97e2adc0947dd3" name="adf2d9ef2301fd7fdee97e2adc0947dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2d9ef2301fd7fdee97e2adc0947dd3">&#9670;&#160;</a></span>reflectanceFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::reflectanceFilter </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>minreflectance</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter scan by imposing a minimum reflectance value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">minreflectance</td><td>Miniimum hit point reflectance value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If &lsquo;reflectance&rsquo; data was not provided for a hit point when calling Scan::addHitPoint(), the point will not be filtered. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01055">1055</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="aa2ea59f063b3c951a1e58af9e4ddfd7e" name="aa2ea59f063b3c951a1e58af9e4ddfd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ea59f063b3c951a1e58af9e4ddfd7e">&#9670;&#160;</a></span>scalarFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::scalarFilter </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>scalar_field</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>threshold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>comparator</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter hit points based on a scalar field given by a column in the ASCII data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_field</td><td>Name of a scalar field defined in the ASCII point cloud data (e.g., "reflectance") </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>Value for filter threshold </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comparator</td><td>Points will be filtered if "scalar (comparator) threshold", where (comparator) is one of "&gt;", "&lt;", or "=" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>As an example, imagine we wanted to remove all hit points where the reflectance is less than -10. In this case we would call scalarFilter( "reflectance", -10, "&lt;" ); </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01074">1074</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="aaa2f35f02a65d4a7a731c4989dd9aa36" name="aaa2f35f02a65d4a7a731c4989dd9aa36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2f35f02a65d4a7a731c4989dd9aa36">&#9670;&#160;</a></span>selfTest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LiDARcloud::selfTest </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Self-test (unit test) function. </p>

<p class="definition">Definition at line <a class="el" href="plugins_2lidar_2src_2self_test_8cpp_source.html#l00021">21</a> of file <a class="el" href="plugins_2lidar_2src_2self_test_8cpp_source.html">selfTest.cpp</a>.</p>

</div>
</div>
<a id="a4c8d55452f2423ddf8b77effbf443075" name="a4c8d55452f2423ddf8b77effbf443075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8d55452f2423ddf8b77effbf443075">&#9670;&#160;</a></span>setCellGtheta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::setCellGtheta </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>Gtheta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the average G(theta) value of a grid cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Gtheta</td><td>G(theta) in cell. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index of a grid cell. Note: the index of a grid cell is given by the order in which it was added to the grid. E.g., the first cell's index is 0, and the last cell's index is Ncells-1. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01949">1949</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a32643f365dda44670b5b132c4eee8442" name="a32643f365dda44670b5b132c4eee8442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32643f365dda44670b5b132c4eee8442">&#9670;&#160;</a></span>setCellLeafArea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::setCellLeafArea </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>area</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the leaf area of a grid cell in m^2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">area</td><td>Leaf area in cell in m^2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index of a grid cell. Note: the index of a grid cell is given by the order in which it was added to the grid. E.g., the first cell's index is 0, and the last cell's index is Ncells-1. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01918">1918</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a4ad8b12380a24f48ecfbae0ad6b5cfaa" name="a4ad8b12380a24f48ecfbae0ad6b5cfaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad8b12380a24f48ecfbae0ad6b5cfaa">&#9670;&#160;</a></span>setHitData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::setHitData </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>label</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set floating point data value associated with a hit point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Hit number. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>Label of the data value (e.g., "reflectance"). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value of scalar data. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00335">335</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a122b1716c42af6a07d48ad23b5acb427" name="a122b1716c42af6a07d48ad23b5acb427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122b1716c42af6a07d48ad23b5acb427">&#9670;&#160;</a></span>setHitGridCell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::setHitGridCell </td>
          <td>(</td>
          <td class="paramtype">uint</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cell</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the grid cell in which the hit point resides. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Hit number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>Cell number </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00426">426</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="aac5cafa2281f9d479f2bb56be0780e31" name="aac5cafa2281f9d479f2bb56be0780e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5cafa2281f9d479f2bb56be0780e31">&#9670;&#160;</a></span>syntheticScan() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::syntheticScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelios_1_1_context.html">helios::Context</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a discrete return synthetic LiDAR scan based on scan parameters given in an XML file (returns only one laser hit per pulse) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to the Helios context </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cu_source.html#l03093">3093</a> of file <a class="el" href="_li_d_a_r_8cu_source.html">LiDAR.cu</a>.</p>

</div>
</div>
<a id="a027d03054878ad27a705a839c36ba0cf" name="a027d03054878ad27a705a839c36ba0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027d03054878ad27a705a839c36ba0cf">&#9670;&#160;</a></span>syntheticScan() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::syntheticScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelios_1_1_context.html">helios::Context</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>scan_grid_only</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>record_misses</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a discrete return synthetic LiDAR scan based on scan parameters given in an XML file (returns only one laser hit per pulse) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to the Helios context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_grid_only</td><td>If true, only record hit points for rays that intersect the voxel grid. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">record_misses</td><td>If true, "miss" points (i.e., beam did not hit any primitives) are recorded in the scan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calling syntheticScan() with scan_grid_only=true can save substantial memory for contexts with large domains. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cu_source.html#l03097">3097</a> of file <a class="el" href="_li_d_a_r_8cu_source.html">LiDAR.cu</a>.</p>

</div>
</div>
<a id="aca2bef5f45b9c7f65e04952ed1551f25" name="aca2bef5f45b9c7f65e04952ed1551f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2bef5f45b9c7f65e04952ed1551f25">&#9670;&#160;</a></span>syntheticScan() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::syntheticScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelios_1_1_context.html">helios::Context</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rays_per_pulse</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>pulse_distance_threshold</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a full-waveform synthetic LiDAR scan based on scan parameters given in an XML file (returns multiple laser hits per pulse) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to the Helios context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rays_per_pulse</td><td>Number of ray launches per laser pulse direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pulse_distance_threshold</td><td>Threshold distance for determining laser hit locations. Hits within pulse_distance_threshold of each other will be grouped into a single hit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calling syntheticScan() with rays_per_pulse=1 will effectively run a discrete return synthetic scan. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cu_source.html#l03101">3101</a> of file <a class="el" href="_li_d_a_r_8cu_source.html">LiDAR.cu</a>.</p>

</div>
</div>
<a id="a0a4118588bb1a17e5d855a18ffbde299" name="a0a4118588bb1a17e5d855a18ffbde299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4118588bb1a17e5d855a18ffbde299">&#9670;&#160;</a></span>syntheticScan() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::syntheticScan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhelios_1_1_context.html">helios::Context</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rays_per_pulse</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>pulse_distance_threshold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>scan_grid_only</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>record_misses</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a full-waveform synthetic LiDAR scan based on scan parameters given in an XML file (returns multiple laser hits per pulse) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to the Helios context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rays_per_pulse</td><td>Number of ray launches per laser pulse direction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pulse_distance_threshold</td><td>Threshold distance for determining laser hit locations. Hits within pulse_distance_threshold of each other will be grouped into a single hit. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scan_grid_only</td><td>If true, only considers context geometry within the scan grid. scan_grid_only=true can save substantial memory for contexts with large domains. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">record_misses</td><td>If true, "miss" points (i.e., beam did not hit any primitives) are recorded in the scan. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Calling syntheticScan() with rays_per_pulse=1 will effectively run a discrete return synthetic scan. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cu_source.html#l03105">3105</a> of file <a class="el" href="_li_d_a_r_8cu_source.html">LiDAR.cu</a>.</p>

</div>
</div>
<a id="ac495385c9dc7cc7773819ce77175242a" name="ac495385c9dc7cc7773819ce77175242a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac495385c9dc7cc7773819ce77175242a">&#9670;&#160;</a></span>triangulateHitPoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::triangulateHitPoints </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>Lmax</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>max_aspect_ratio</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform triangulation on all hit points in point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Lmax</td><td>Maximum allowable length of triangle sides. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_aspect_ratio</td><td>Maximum allowable aspect ratio of triangles. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01382">1382</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a2e2d9ac728f839b64cedb20582d77d48" name="a2e2d9ac728f839b64cedb20582d77d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2d9ac728f839b64cedb20582d77d48">&#9670;&#160;</a></span>triangulateHitPoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::triangulateHitPoints </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>Lmax</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>max_aspect_ratio</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>scalar_field</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>threshold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>comparator</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform triangulation on hit points in point cloud that meet some filtering criteria based on scalar data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Lmax</td><td>Maximum allowable length of triangle sides. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_aspect_ratio</td><td>Maximum allowable aspect ratio of triangles. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar_field</td><td>Name of a scalar field defined in the ASCII point cloud data (e.g., "deviation") </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>Value for filter threshold </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comparator</td><td>Points will not be used in triangulation if "scalar (comparator) threshold", where (comparator) is one of "&gt;", "&lt;", or "=" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>As an example, imagine we wanted to remove all hit points where the deviation is greater than 15 for the purposes of the triangulation. In this case we would call triangulateHitPoints(Lmax, max_aspect_ratio, "deviation", 15, "&gt;" ); </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01563">1563</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="aa7d6abb997267bce460c48cf02dc3545" name="aa7d6abb997267bce460c48cf02dc3545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d6abb997267bce460c48cf02dc3545">&#9670;&#160;</a></span>trunkReconstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::trunkReconstruction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>box_center</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhelios_1_1vec3.html">helios::vec3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>box_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>Lmax</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>max_aspect_ratio</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconstruct the trunk of the tree. In order to do this, you must specify the center and size of a rectangular box that encompasses the tree trunk. This routine will then try to find the largest continuous triangle group, which is assumed to correspond to the trunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">box_center</td><td>(x,y,z) coordinates of the center of a rectangular box that encompasses the tree trunk. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box_size</td><td>Dimension of the trunk box in the x-, y-, and z- directions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Lmax</td><td>maximum dimension of triangles (see also triangulateHitPoints()). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_aspect_ratio</td><td>Maximum allowable aspect ratio of triangles (see also triangulateHitPoints()) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cu_source.html#l02838">2838</a> of file <a class="el" href="_li_d_a_r_8cu_source.html">LiDAR.cu</a>.</p>

</div>
</div>
<a id="a5b07c5c073025eeedc5cbade19c2e8d4" name="a5b07c5c073025eeedc5cbade19c2e8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b07c5c073025eeedc5cbade19c2e8d4">&#9670;&#160;</a></span>validateRayDirections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::validateRayDirections </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l00108">108</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="ac17ca020e2f2fd4f1ce91ef5101353d0" name="ac17ca020e2f2fd4f1ce91ef5101353d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17ca020e2f2fd4f1ce91ef5101353d0">&#9670;&#160;</a></span>xyzFilter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::xyzFilter </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>xmin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>xmax</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>ymin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>ymax</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>zmin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>zmax</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>overloaded version of xyzFilter that defaults to deleting points outside the provided bounding box </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xmin</td><td>minimum x coordinate of bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xmax</td><td>maximum x coordinate of bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ymin</td><td>minimum y coordinate of bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ymax</td><td>maximum y coordinate of bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zmin</td><td>minimum z coordinate of bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zmax</td><td>maximum z coordinate of bounding box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>points outside the provided bounding box are deleted by default </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01105">1105</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<a id="a56ee72fba222c399c256adf577ae860d" name="a56ee72fba222c399c256adf577ae860d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ee72fba222c399c256adf577ae860d">&#9670;&#160;</a></span>xyzFilter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LiDARcloud::xyzFilter </td>
          <td>(</td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>xmin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>xmax</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>ymin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>ymax</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>zmin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>zmax</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>deleteOutside</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter scan with a bounding box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">xmin</td><td>minimum x coordinate of bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xmax</td><td>maximum x coordinate of bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ymin</td><td>minimum y coordinate of bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ymax</td><td>maximum y coordinate of bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zmin</td><td>minimum z coordinate of bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zmax</td><td>maximum z coordinate of bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deleteOutside</td><td>if true, deletes points outside the bounding box, if false deletes points inside the bounding box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>points outside the provided bounding box are deleted </dd></dl>

<p class="definition">Definition at line <a class="el" href="_li_d_a_r_8cpp_source.html#l01111">1111</a> of file <a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>plugins/lidar/include/<a class="el" href="_li_d_a_r_8h_source.html">LiDAR.h</a></li>
<li>plugins/lidar/src/<a class="el" href="lidar_2src_2file_i_o_8cpp_source.html">fileIO.cpp</a></li>
<li>plugins/lidar/src/<a class="el" href="_li_d_a_r_8cpp_source.html">LiDAR.cpp</a></li>
<li>plugins/lidar/src/<a class="el" href="_li_d_a_r_8cu_source.html">LiDAR.cu</a></li>
<li>plugins/lidar/src/<a class="el" href="plugins_2lidar_2src_2self_test_8cpp_source.html">selfTest.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_li_d_a_rcloud.html">LiDARcloud</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
