<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>.: LiDAR Point Cloud Plugin Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Helios_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">.<span id="projectnumber">&#160;v1.3.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="_plug_ins.html">Plug-ins</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">LiDAR Point Cloud Plugin Documentation </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#LiDARissues">Known Issues</a></li>
<li class="level1"><a href="#LiDARintro">Introduction</a></li>
<li class="level1"><a href="#LiDARdepends">Dependencies</a></li>
<li class="level1"><a href="#LiDARConstructor">Class Constructor</a></li>
<li class="level1"><a href="#LiDARInputData">Input Primitive Data</a></li>
<li class="level1"><a href="#LiDARbg">Background information</a><ul><li class="level2"><a href="#LiDARcoord">Coordinates and scan pattern</a></li>
<li class="level2"><a href="#LiDARreturn">Difference between discrete-return and full-waveform LiDAR data</a></li>
<li class="level2"><a href="#ScanMetadata">Scan metadata</a></li>
<li class="level2"><a href="#AddHits">Hit point data</a></li>
</ul>
</li>
<li class="level1"><a href="#ScanIO">Loading scan data from file</a></li>
<li class="level1"><a href="#LiDARgrid">Establishing grid cells</a></li>
<li class="level1"><a href="#LiDARprocess">Processing LiDAR data</a><ul><li class="level2"><a href="#LiDARtri">Hit point triangulation</a></li>
<li class="level2"><a href="#LiDARleafarea">Calculating leaf area for each grid cell</a></li>
<li class="level2"><a href="#LiDARresonstruction">Plant reconstruction</a></li>
</ul>
</li>
<li class="level1"><a href="#LiDARsynthetic">Generating Synthetic (Simulated) LiDAR Data</a><ul><li class="level2"><a href="#LiDARsynthxml">XML parameter file</a></li>
<li class="level2"><a href="#LiDARsynthdiscrete">Synthetic discrete-return data</a></li>
<li class="level2"><a href="#LiDARsynthwaveform">Synthetic waveform data</a></li>
</ul>
</li>
<li class="level1"><a href="#LiDARvis">Visualizing results</a></li>
<li class="level1"><a href="#LiDARoutput">Writing results to file</a></li>
</ul>
</div>
<div class="textblock"><div class="image">
<img src="LiDAR.png" alt=""/>
</div>
<p><br  />
<br  />
 </p>
<table class="doxtable">
<tr>
<th>Dependencies</th><td>NVIDIA CUDA 9.0+ <br  />
<a class="el" href="class_visualizer.html" title="Class for visualization of simulation results.">Visualizer</a> plug-in </td></tr>
<tr>
<th>CMakeLists.txt</th><td>set( PLUGINS "lidar" ) </td></tr>
<tr>
<th>Header File</th><td>#include "LiDAR.h" </td></tr>
<tr>
<th>Class</th><td><a class="el" href="class_li_d_a_rcloud.html">LiDARcloud</a> </td></tr>
</table>
<h1><a class="anchor" id="LiDARissues"></a>
Known Issues</h1>
<ul>
<li>The LiDAR plug-in requires the <a class="el" href="class_visualizer.html" title="Class for visualization of simulation results.">Visualizer</a> plug-in to be loaded in the CMakeLists.txt file.</li>
<li>The current version of calculateLeafAreaGPU() assumes data is discrete-return. The version calculateLeafAreaGPU_testing() does both discrete-return and waveform data, but it has not been thoroughly tested.</li>
</ul>
<h1><a class="anchor" id="LiDARintro"></a>
Introduction</h1>
<p>The LiDAR plugin is used to process terrestrial LiDAR data into information that is useful for plant models. For example, this may be to determine leaf area and angle distributions at the voxel scale, or to reconstruct individual leaves and add them to the Context.</p>
<h1><a class="anchor" id="LiDARdepends"></a>
Dependencies</h1>
<table class="doxtable">
<caption>Installing dependent packages</caption>
<tr>
<th>Package</th><td><div class="image">
<img src="apple-logo.jpg" alt=""/>
</div>
td </td><td><div class="image">
<img src="unix-logo.png" alt=""/>
</div>
td </td><td><div class="image">
<img src="windows-logo.jpg" alt=""/>
</div>
td  </td></tr>
<tr>
<td>NVIDIA CUDA 9.0+ </td><td>Mac OSX:<br  />
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2"><code>$ brew install Caskroom/cask/cuda</code></div> </td><td>Use <a href="https://developer.nvidia.com/cuda-downloads">CUDA installer</a> </td><td>Use <a href="https://developer.nvidia.com/cuda-downloads">CUDA installer</a>  </td></tr>
</table>
<p>For help choosing the correct CUDA toolkit version for your system, consult this page: <a class="el" href="_choosing_c_u_d_a.html">Choosing the right CUDA and OptiX version</a></p>
<p>Useful OS-specific information for installing CUDA can be found here: <a class="el" href="_dependent_software.html">Dependent Software</a></p>
<p>If you are using a PC, it is likely you will need to increase the GPU timeout in the registry, otherwise calculations lasting longer than 2 secs. will timeout and kill your program. A guide on how to increase the timeout can be found here: <a class="el" href="_p_c_g_p_u_timeout.html">Increasing graphics driver timeout</a></p>
<h1><a class="anchor" id="LiDARConstructor"></a>
Class Constructor</h1>
<table class="doxtable">
<tr>
<th>Constructors </th></tr>
<tr>
<td><a class="el" href="class_li_d_a_rcloud.html">LiDARcloud( void )</a> </td></tr>
</table>
<p>The <a class="el" href="class_li_d_a_rcloud.html">LiDARcloud</a> class contains point cloud data, and is used to perform processing operations on the data. The class constructor does not take any arguments.</p>
<h1><a class="anchor" id="LiDARInputData"></a>
Input Primitive Data</h1>
<table class="doxtable">
<tr>
<th>Primitive Data Label</th><th>Symbol</th><th>Units</th><th>Data Type</th><th>Description</th><th>Available Plug-ins</th><th>Default Value </th></tr>
<tr>
<td>reflectivity_lidar</td><td><img class="formulaInl" alt="$\rho_l$" src="form_84.png" width="12" height="11"/></td><td>unitless</td><td> <font face="courier" color="green">float</font></td><td>Primitive reflectivity in the waveband of the laser. This is used to calculate the return intensity in synthetic scans.</td><td>N/A</td><td>1.0 </td></tr>
</table>
<h1><a class="anchor" id="LiDARbg"></a>
Background information</h1>
<h2><a class="anchor" id="LiDARcoord"></a>
Coordinates and scan pattern</h2>
<p>The algorithms associated with the LiDAR plug-in work with data obtained from a rectangular scan pattern. In this scan pattern, points are sampled at equally spaced intervals in both the zenithal ( <img class="formulaInl" alt="$\theta$" src="form_19.png" width="8" height="12"/>) and azimuthal ( <img class="formulaInl" alt="$\varphi$" src="form_20.png" width="9" height="11"/>) directions. At a given azimuthal angle, some range of zenithal angles are consecutively scanned, which represents a "scan line". Each scan line starts at some zenithal angle <img class="formulaInl" alt="$\theta$" src="form_19.png" width="8" height="12"/><sub>min</sub> and ends at some zenithal angle <img class="formulaInl" alt="$\theta$" src="form_19.png" width="8" height="12"/><sub>max</sub>. After recording a scan line at the first azimuthal angle <img class="formulaInl" alt="$\varphi$" src="form_20.png" width="9" height="11"/><sub>min</sub>, the scanner incrementally moves to the next adjacent azimuthal scan direction and records the next scan line until it reaches the azimuthal angle <img class="formulaInl" alt="$\varphi$" src="form_20.png" width="9" height="11"/><sub>max</sub>.</p>
<p>The number of zenithal points within each scan line is given by <img class="formulaInl" alt="$\mathrm{N}_{\theta}$" src="form_85.png" width="18" height="15"/>, and the total number of scan lines (i.e., number of individual azimuthal directions) is is given by <img class="formulaInl" alt="$\mathrm{N}_{\varphi}$" src="form_86.png" width="20" height="17"/>.</p>
<p>Angles are typically specified as degrees. Distance units are arbitrary, but must be used consistently.</p>
<div class="image">
<img src="CoordinateSystem.jpeg" alt=""/>
<div class="caption">
Scan pattern: the scanner traverses some range of zenithal and azimuthal angles to explore a portion of the spherical space surrounding the scanner.</div></div>
<div class="image">
<img src="HitSchematic.jpeg" alt=""/>
<div class="caption">
For each scan direction, the scanner records the (x,y,z) Cartesian position of the point of intersection between the ray path and the object's surface. Each Cartesian position corresponds to spherical coordinate (zenith,azimuth) representing the scan direction.</div></div>
<div class="image">
<img src="RectangularScan.png" alt=""/>
<div class="caption">
The rectangular scan pattern creates quadrilateral polygons between four neighboring points.</div></div>
<h2><a class="anchor" id="LiDARreturn"></a>
Difference between discrete-return and full-waveform LiDAR data</h2>
<p>The laser beam emitted from a LiDAR instrument has some finite diameter, which increases with distance from the scanner. In many cases, the beam diameter may be larger than the width of individual leaves by the time it reaches the canopy. This means that a single laser pulse may intersect multiple objects along its path to the ground.</p>
<p>For a "discrete-return" instrument, only one (or sometimes a few) hit points are recorded per laser pulse. The distance from the scanner recorded for the hit point is an effective average distance to all objects intersected by the beam.</p>
<p>By contrast "full-waveform" instruments are able to record multiple hit point locations along a single laser pulse by analyzing the return timeseries or "waveform". This class of instruments is able to process the timeseries of pulse returns into separate distances. Full-waveform instruments are preferred because they provide more information, particularly in dense canopies where a discrete-return instrument would rarely record the location of the ground. Technically, full-waveform instruments ultimately output discrete hit points, but for the purposes of this documentation we will consider discrete-return data to have a single hit point per laser pulse, and full-waveform data to have an unlimited number of hit points per laser pulse.</p>
<p>There is sometimes ambiguity or inconsitency in usage of the terms discrete-return and full-waveform LiDAR data in the literature. For the purposes of this documentation, we will call "discrete-return" data as a scan that records only a single hit point per laser pulse, and "full-waveform" data as a scan that can record a large number of hit points per laser pulse.</p>
<div class="image">
<img src="WaveformSchematic.jpeg" alt=""/>
</div>
<h2><a class="anchor" id="ScanMetadata"></a>
Scan metadata</h2>
<p>Each scan has a set of parameters or "metadata" that must be specified in order to process the data. Some parameters are optional, while some are required. The following metadata is needed to define the overall scan itself, in addition to individual scan hit points. Note that XML tags are case-sensitive.</p>
<table class="doxtable">
<tr>
<th>Metadata</th><th>XML tag</th><th>Description</th><th>Default behavior </th></tr>
<tr>
<td>Scanner origin</td><td>&lt;origin&gt;</td><td>(x,y,z) coordinate of the scanner. This is the position where the scanner rays are sent from. Values should be separated by a space in the XML file.</td><td>None: REQUIRED </td></tr>
<tr>
<td>size</td><td>&lt;size&gt;</td><td>Number of scan points in the theta (zenithal) and phi (azimuthal) directions. Values should be separated by a space in the XML file.</td><td>None: REQUIRED </td></tr>
<tr>
<td><img class="formulaInl" alt="$\theta$" src="form_19.png" width="8" height="12"/><sub>min</sub> (degrees)</td><td>&lt;thetaMin&gt;</td><td>Minimum scan theta (zenital) angle. <img class="formulaInl" alt="$\theta$" src="form_19.png" width="8" height="12"/><sub>min</sub>=0 if the scan starts from upward vertical, <img class="formulaInl" alt="$\theta$" src="form_19.png" width="8" height="12"/><sub>min</sub>=90 is the scan starts from horizontal, etc. </td><td>0 </td></tr>
<tr>
<td><img class="formulaInl" alt="$\theta$" src="form_19.png" width="8" height="12"/><sub>max</sub> (degrees)</td><td>&lt;thetaMax&gt;</td><td>Maximum scan theta (zenital) angle. <img class="formulaInl" alt="$\theta$" src="form_19.png" width="8" height="12"/><sub>max</sub>=90 if the scan ends at horizontal, <img class="formulaInl" alt="$\theta$" src="form_19.png" width="8" height="12"/><sub>min</sub>=180 is the scan ends at downward vertical, etc. </td><td>180 </td></tr>
<tr>
<td><img class="formulaInl" alt="$\varphi$" src="form_20.png" width="9" height="11"/><sub>min</sub> (degrees)</td><td>&lt;phiMin&gt;</td><td>Minimum scan phi (azimuthal) angle. <img class="formulaInl" alt="$\varphi$" src="form_20.png" width="9" height="11"/><sub>min</sub>=0 if the scan starts pointing in the +y direction, <img class="formulaInl" alt="$\varphi$" src="form_20.png" width="9" height="11"/><sub>min</sub>=90 if the scan starts pointing in the +x direction, etc. </td><td>0 </td></tr>
<tr>
<td><img class="formulaInl" alt="$\varphi$" src="form_20.png" width="9" height="11"/><sub>max</sub> (degrees)</td><td>&lt;phiMax&gt;</td><td>Maximum scan phi (azimuthal) angle. <img class="formulaInl" alt="$\varphi$" src="form_20.png" width="9" height="11"/><sub>max</sub>=90 if the scan ends pointing in the +x direction, <img class="formulaInl" alt="$\varphi$" src="form_20.png" width="9" height="11"/><sub>min</sub>=180 if the scan ends pointing in the -y direction, etc. NOTE: <img class="formulaInl" alt="$\varphi$" src="form_20.png" width="9" height="11"/><sub>max</sub> could be greater than 360 if <img class="formulaInl" alt="$\varphi$" src="form_20.png" width="9" height="11"/><sub>min</sub>&gt;0 and the scanner makes a full rotation in the in the azimuthal direction, in which case <img class="formulaInl" alt="$\varphi$" src="form_20.png" width="9" height="11"/><sub>max</sub>= <img class="formulaInl" alt="$\varphi$" src="form_20.png" width="9" height="11"/><sub>min</sub>+360.</td><td>360 </td></tr>
<tr>
<td>translation</td><td>&lt;translation&gt;</td><td>Global (x,y,z) translation to be applied to entire scan, including the origin and all hit ponts.</td><td>No translation. </td></tr>
<tr>
<td>rotation (degrees)</td><td>&lt;rotation&gt;</td><td>Global spherical rotation (theta,phi) to be applied to the entire scan, including the origin and all hit ponts.</td><td>No rotation. </td></tr>
<tr>
<td>beam exit diameter (meters)</td><td>&lt;exitDiameter&gt;</td><td>Effective diameter of laser beam exiting the instrument. Only used for full-waveform synthetic data generation.</td><td>0 (discrete return) </td></tr>
<tr>
<td>beam divergence angle (rad)</td><td>&lt;beamDivergence&gt;</td><td>Angle of laser beam divergence after exiting the instrument. Only used for full-waveform sythetic data generation.</td><td>0 </td></tr>
<tr>
<td>ASCII point cloud file</td><td>&lt;filename&gt;</td><td>File containing point cloud data to be read.</td><td>No file will be read. </td></tr>
<tr>
<td>ASCII file column format</td><td>&lt;ASCII_format&gt;</td><td>Labels for columns in ASCII point cloud file. See section below for possible values and examples. Labels should be separated by a space in the XML file.</td><td>x y z </td></tr>
</table>
<h2><a class="anchor" id="AddHits"></a>
Hit point data</h2>
<p>In addition to scan metadata, the data collected by the scan itself must also be added to the plug-in. This can be achieved by either reading data from an ASCII text file, or performing a synthetic scan. At a minimum, point cloud data consists of the Cartesian (x,y,z) coordinates of each hit in the scan. Additionally, hit points may also have an associated r-g-b color value, or some other scalar data value such as intensity or temperature.</p>
<p>For the processing algorithms to work, the scan direction associated with each hit point must also be known. This can be specified directly as a ( <img class="formulaInl" alt="$\theta$" src="form_19.png" width="8" height="12"/>, <img class="formulaInl" alt="$\varphi$" src="form_20.png" width="9" height="11"/>) spherical coordinate, or using the row (i.e., index in the scanline: 1... <img class="formulaInl" alt="$\mathrm{N}_\theta$" src="form_87.png" width="18" height="15"/>) and column (i.e., scanline index: 1... <img class="formulaInl" alt="$\mathrm{N}_\varphi$" src="form_88.png" width="20" height="17"/>). Otherwise, it will calculate the scan direction by drawing a line between the scan origin position and the hit point.</p>
<p>For full-waveform data, additional information is needed about the hit points. Specifically, the total number of hit points along the pulse. IfThe index can start at 0 or 1 for the first hit along the pulse, it just should be consistent for all points.</p>
<h1><a class="anchor" id="ScanIO"></a>
Loading scan data from file</h1>
<p>Scan metadata is typically specified by loading an XML file containing the relevant metadata for each scan. For real data, the XML file specifies the path to an ASCII text file that contains the data for each scan. For synthetic data, the parameters of the simulated scan are loaded from the XML file and used to perform the scan.</p>
<p>The code below gives a sample XML file for loading multiple scans. As specified in the metadata table above, not all entries are required (see above).</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> &lt;helios&gt;

    &lt;scan&gt;
      &lt;filename&gt; /path/to/data/file.xyz &lt;/filename&gt;
      &lt;ASCII_format&gt; x y z r255 g255 b255 target_count target_index timestamp &lt;/ASCII_format&gt;
      &lt;origin&gt; 0 0 0 &lt;/origin&gt;
      &lt;size&gt; 2500 4500 &lt;/size&gt;
      &lt;thetaMin&gt; 30 &lt;/thetaMin&gt;
      &lt;thetaMax&gt; 130 &lt;/thetaMax&gt;
      &lt;phiMin&gt; 0 &lt;/phiMin&gt;
      &lt;phiMax&gt; 360 &lt;/phiMax&gt; 
      &lt;translation&gt; 1.2 1.5 -10.2 &lt;/translation&gt;
      &lt;rotation&gt; 20 180 &lt;/rotation&gt;
      &lt;exitDiameter&gt; 0.005 &lt;/exitDiameter&gt;
      &lt;beamDivergence&gt; 0.003 &lt;/beamDivergence&gt;
    &lt;/scan&gt;

 &lt;/helios&gt;</code></pre></div><p>The ASCII text file containing the data is a plain text file, where each row corresponds to a hit point and each column is some data value associated with that hit point. The "ASCII_format" tag defines the column format of the ASCII text file (in this case, file.xyz). Each entry in the list specifies the meaning of each column. Possible fields are listed in the table below:</p>
<table class="doxtable">
<tr>
<th>Label</th><th>Description</th><th>Default behavior </th></tr>
<tr>
<td>x</td><td>x-component of the (x,y,z) Cartesian coordinate of the hit point.</td><td>None: REQUIRED </td></tr>
<tr>
<td>y</td><td>y-component of the (x,y,z) Cartesian coordinate of the hit point.</td><td>None: REQUIRED </td></tr>
<tr>
<td>z</td><td>z-component of the (x,y,z) Cartesian coordinate of the hit point.</td><td>None: REQUIRED </td></tr>
<tr>
<td>zenith (or zenith_rad)</td><td>Zenithal angle (degrees) of scan ray direction corresponding to the hit point. If "theta_rad" is used, theta has units of radians rather than degrees.</td><td>Calculated from scan origin and hit (x,y,z). </td></tr>
<tr>
<td>azimuth (or phi_rad)</td><td>Azithal angle (degrees) of scan ray direction corresponding to the hit point. If "phi_rad" is used, phi has units of radians rather than degrees.</td><td>Calculated from scan origin and hit (x,y,z). </td></tr>
<tr>
<td>r (or r255)</td><td>red component of (r,g,b) hit color. If "r" tag is used, r is a floating point value between 0 and 1. If "r255" is used, r is an integer and betwen 0 and 255.</td><td>r=1 or r255=255 </td></tr>
<tr>
<td>g (or g255)</td><td>green component of (r,g,b) hit color. If "g" tag is used, g is a floating point value between 0 and 1. If "g255" is used, g is an integer between 0 and 255.</td><td>g=0 or g255=0 </td></tr>
<tr>
<td>b (or b255)</td><td>blue component of (r,g,b) hit color. If "b" tag is used, b is a floating point value between 0 and 1. If "b255" is used, b is an integer between 0 and 255.</td><td>b=0 or b255=0 </td></tr>
<tr>
<td>target_count</td><td>Number of hits along scan pulse.</td><td>Assumed to be discrete return data. </td></tr>
<tr>
<td>target_index</td><td>Index of hit along scan pulse.</td><td>Assumed to be discrete return data. </td></tr>
<tr>
<td>timestamp</td><td>Unique timestamp of hit point.</td><td>Assumed to be discrete return data. </td></tr>
<tr>
<td>deviation</td><td>Indication of variability in return within a given hit point. Note: this is never used for real data, but can be output for synthetic data.</td><td>N/A </td></tr>
<tr>
<td>intensity</td><td>Intensity of return. Note: this is never used for real data, but can be output for synthetic data.</td><td>N/A </td></tr>
<tr>
<td>(label)</td><td>User-defined floating-point data value. "label" can be any string describing data. For example, "temperature", etc. </td><td>N/A </td></tr>
</table>
<p>The XML file can be automatically loaded into the point cloud using the loadXML() function, as illustrated below.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>  #include "Context.h"
  #include "LiDAR.h"

  using namespace helios;

  int main( void ){

     LiDARcloud pointcloud; //Initialize the LiDAR point cloud

     pointcloud.loadXML("/path/to/file.xml");

  }</code></pre></div><h1><a class="anchor" id="LiDARgrid"></a>
Establishing grid cells</h1>
<p>Rectangular grid cells are used as the basis for processing point cloud data. For example, total leaf area (or leaf area density) may be calculated for each grid cell. Grid cells or "voxels" are parallelpiped volumes. The top and bottom faces are always horizontal, but the cells can be rotated in the azimuthal direction.</p>
<p>Grid cells are defined by specifying the (x,y,z) position of its center, and the size of the cell in the x, y, and z directions. Additional optional information can also be provided for grid cells, which are detailed below.</p>
<table class="doxtable">
<tr>
<th>Tag</th><th>Description</th><th>Default behavior </th></tr>
<tr>
<td>center</td><td>(x,y,z) Cartesian coordinates of cell center.</td><td>None: required. </td></tr>
<tr>
<td>size</td><td>Length of cell sides in x, y, and z directions.</td><td>None: required. </td></tr>
<tr>
<td>rotation</td><td>Azimuthal rotation of the cell in degrees.</td><td>0 </td></tr>
<tr>
<td>Nx</td><td>Grid cell subdivisions in the x-direction.</td><td>1 </td></tr>
<tr>
<td>Ny</td><td>Grid cell subdivisions in the y-direction.</td><td>1 </td></tr>
<tr>
<td>Nz</td><td>Grid cell subdivisions in the z-direction.</td><td>1 </td></tr>
</table>
<p>The grid cell subdivisions options allow the cells to be easily split up into a grid of smaller cells. For example, Nx=Ny=Nz=3 would create 27 grid cells similar to a "Rubik's cube".</p>
<p>Grid cell options can be specified in an XML file using the tags listed in the table above. Multiple grid cells are added by simply adding more &lt;grid&gt;...&lt;/grid&gt; groups to the XML file.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> &lt;grid&gt;
     &lt;center&gt; 0 0 0.5 &lt;/center&gt;
     &lt;size&gt; 1 1 1 &lt;/size&gt;
     &lt;rotation&gt; 30 &lt;/rotation&gt; 
     &lt;Nx&gt; 3 &lt;/Nx&gt; 
     &lt;Ny&gt; 3 &lt;/Ny&gt; 
     &lt;Nz&gt; 3 &lt;/Nz&gt; 
  &lt;/grid&gt;</code></pre></div><p>One way to figure out the appropriate dimension and position of the voxel grid is using the visualizer and trial-and-error. Make a guess of the voxel parameters, then visualize the point cloud and voxels together and adjust accordingly. This can be tedious and time-consuming because you need to re-run the entire code each time.</p>
<p>An often faster way to figure out the dimensions of the voxel grid is to use point cloud visualization software such as <a href="https://www.cloudcompare.org">Cloud Compare</a>. Load the point cloud data into Cloud Compare, then add a Box (file-&gt;Primitive Factory). You can translate or rotate the box by clicking on the Box object in the DB Tree pane, then select the menu item Edit-&gt;Translate/Rotate. To change the box size, click on the box vertices in the DB Tree pane, then go to Edit-&gt;Multiply/Scale. You can then find the resulting box location and dimensions in the Properties pane.</p>
<div class="image">
<img src="LiDARvoxelgrid.png" alt=""/>
</div>
<h1><a class="anchor" id="LiDARprocess"></a>
Processing LiDAR data</h1>
<h2><a class="anchor" id="LiDARtri"></a>
Hit point triangulation</h2>
<p>A triangulation between adjacent points is typically required for any of the available data processing algorithms. In the triangulation, adjacent hit points are connected to form a mesh of triangular solid surfaces. The algorithm for performing this triangulation is described in detail in <a href="dx.doi.org/doi:10.1016/j.rse.2017.03.011">Bailey and Mahaffee (2017a)</a>.</p>
<p>There are two possible options to be specified when performing the triangulation. A required option is <img class="formulaInl" alt="$L_{max}$" src="form_89.png" width="33" height="15"/>, which is the maximum allowable length of a triangle side. This parameter prevents triangles from connecting adjacent leaves (i.e., we only want triangles to be formed with neighboring points on the same leaf). Typically we want <img class="formulaInl" alt="$L_{max}$" src="form_89.png" width="33" height="15"/> to be much larger than the spacing between adjacent hit points, and much smaller than the characteristic length of a leaf. For example, <a href="dx.doi.org/doi:10.1016/j.rse.2017.03.011">Bailey and Mahaffee (2017a)</a> used 5cm for a cottonwood tree.</p>
<p>Another optional parameter is the maximum allowable aspect ratio of a triangle, which is the ratio of the length of the longest triangle side to the shortest triangle side. This has a similar effect as the <img class="formulaInl" alt="$L_{max}$" src="form_89.png" width="33" height="15"/> parameter, and works better in some cases.</p>
<p>The following code sample illustrates how to perform a triangulation.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
  #include "LiDAR.h"

  using namespace helios;

  int main( void ){

     LiDARcloud pointcloud; //Initialize the LiDAR point cloud

     pointcloud.loadXML("/path/to/file.xml");  //Load the XML file

     pointcloud.triangulateHitPoints( 0.05, 5 ); //Perform triangulation with Lmax=0.05 and maximum aspect ratio of 5 

  }</code></pre></div><h2><a class="anchor" id="LiDARleafarea"></a>
Calculating leaf area for each grid cell</h2>
<p>Using the triangulation and defined grid cells, the plug-in can calculate the leaf area (and leaf area density) for each grid cell. The algorithm for calculating leaf area is described in detail in <a href="dx.doi.org/doi:10.1088/1361-6501/aa5cfd">Bailey and Mahaffee (2017b)</a> (except that in the current implementation, weighting by the sine of the scan zenith direction has been removed).</p>
<p>Performing the calculations is simple and requires no inputs, which is illustrated with the following code sample. Note that the leaf area calculation requires that the triangulation has been performed beforehand. If no triangulation is available, the plug-in will assume a uniformly distributed leaf angle orientation ( <img class="formulaInl" alt="$G=0.5$" src="form_90.png" width="51" height="12"/>). The leaf area calculation also requires that at least one grid cell was defined.</p>
<p>When using real LiDAR data, it is recommended to gapfill sky/miss points using the <a class="el" href="class_li_d_a_rcloud.html#a53b80def6bff07231b8d2b10eb3e0330">LiDARcloud::gapfillMisses()</a> method if this has not already been done by the scanner or in pre-processing. When a laser pulse does not intersect any object and reaches the sky, many scanners do not record any hit points. These miss points are important for accurate determination of leaf area.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
  #include "LiDAR.h"

  using namespace helios;

  int main( void ){

     LiDARcloud pointcloud; //Initialize the LiDAR point cloud

     pointcloud.loadXML("/path/to/file.xml");  //Load the XML file

     pointcloud.gapfillMisses(); //Gapfill sky/miss points if necessary

     pointcloud.triangulateHitPoints( 0.05, 5 ); //Perform triangulation with Lmax=0.05 and maximum aspect ratio of 5

     pointcloud.calculateLeafAreaGPU(); //Calculate leaf area for each grid cell

  }</code></pre></div><h2><a class="anchor" id="LiDARresonstruction"></a>
Plant reconstruction</h2>
<p>A leaf-by-leaf reconstruction can be performed for the plant of interest using the method described in <a href="https://www.sciencedirect.com/science/article/pii/S0034425718300191?via%3Dihub">Bailey and Ochoa (2018)</a>. The reconstruction utilizes the triangulation and leaf area computations to ensure the correct leaf angle and area distributions on average, and thus requires that these routines have been run before performing the reconstruction.</p>
<p>There are two types of available reconstructions. One is a triangular reconstruction that directly uses triangles resulting from the triangulation to produce the reconstruction. The advantage is that it doesn not require any assumption about the shape of the leaf and can give a more direct reconstruction in some cases, however this reconstruction is typically not recommended as it often results in many small triangle groups that don't necessarily resemble actual leaves. This reconstruction is performed using the leafReconstructionTriangular() function, whose arguments are thresholds for the minimum and maximum area of reconstructed triangular leaf groups.</p>
<p>The other type of reconstruction is the "Alpha Mask" reconstruction, which replaces the triangle groups with a "prototype" leaf (which is an alpha mask). This ensures that all reconstructed leaves are representative of an actual leaf in terms of shape and size. This reconstruction is performed using the leafReconstructionAlphaMask() function. This function's arguments, in addition to area thresholds, are the aspect ratio of the prototype leaf (length along midrib divided by width perpendicular to midrib) and the path to a PNG image file to be used for the leaf alpha mask.</p>
<p>There is a function that can automatically add all reconstructed elements (triangles or alpha masks) to the Helios Context, which is addLeafReconstructionToContext().</p>
<p>Below is an example of performing a reconstruction using alpha masks and adding the alpha masks to the Context.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "Context.h"
  #include "LiDAR.h"

  using namespace helios;

  int main( void ){

     LiDARcloud pointcloud; //Initialize the LiDAR point cloud

     pointcloud.loadXML("/path/to/file.xml");  //Load the XML file

     pointcloud.triangulateHitPoints( 0.05, 5 ); //Perform triangulation with Lmax=0.05 and maximum aspect ratio of 5

     pointcloud.calculateLeafAreaGPU(); //Calculate leaf area for each grid cell

     pointcloud.leafReconstructionAlphaMask( 0.001, 0.02, "plugins/visualizer/textures/ElmLeaf.png" ); //Perform the reconstruction

     Context context; //Initialize the Context

     pointcloud.addLeafReconstructionToContext( &amp;context );

  }</code></pre></div><h1><a class="anchor" id="LiDARsynthetic"></a>
Generating Synthetic (Simulated) LiDAR Data</h1>
<p>The LiDAR plug-in can simulate the measurements of discrete-return and full-waveform instruments based on the geometry in the Context. Ray-tracing is used to simulate the emission of radiation from the instrument, and based on ray-object intersection tests with primitive geometry in the model domain, the simulated hit points can be determined. Currently, only a rectangular scan pattern is supported.</p>
<p>To simulate discrete-return instruments, each laser pulse is modeled by a single ray emanating from the scanner origin. Rays are launched according to the scan parameters currently specified in the <a class="el" href="class_li_d_a_rcloud.html">LiDARcloud</a>. After calling the appropriate synthetic scan generation function (see below), the simulated scan data will be added to the <a class="el" href="class_li_d_a_rcloud.html">LiDARcloud</a> as if it was imported from real LiDAR data. In addition to the (x,y,z) location of the ray intersection, the model also produces estimates of return intensity, deviation, and can return an identifier for the intersected object.</p>
<p>For full-waveform data simulation, multiple rays are cast for a single laser beam pulse. The density of rays is Gaussian, with the peak at the center of the beam. The model will also record the target count, target index, and timestamp associated with each hit point.</p>
<h2><a class="anchor" id="LiDARsynthxml"></a>
XML parameter file</h2>
<p>To generate synthetic discrete-return LiDAR data, first add all desired model geometry to the Context. Then declare an instance of the <a class="el" href="class_li_d_a_rcloud.html">LiDARcloud</a> class as above, and load an XML file containing the scan parameters. As in the case of importing a real point cloud dataset, the XML file must specify the scan origin and the scan resolution at a minimum (see above). However, in the case of synthetic data generation, you will not specify a filename to read containing point cloud data, as this data will be generated by the simulation. You can optionally specify the ASCII_format tag, which will determine which additional data fields should be recorded for each hit point. Valid hit point data fields are listed above in <a class="el" href="_li_d_a_r_doc.html#ScanIO">Loading scan data from file</a>.</p>
<p>If no ASCII_format tag is provided in the XML file, the default is to record the (x,y,z) position of the hit point. If the function <a class="el" href="class_li_d_a_rcloud.html#a2d0c11c6d8001171269232ff5d7f6322">LiDARcloud::exportPointCloud()</a> is called, it will export the simulated point cloud according to the provided ASCII_format tag (or the default if not provided).</p>
<p>Note that you can add multiple &lt;scan&gt;&lt;/scan&gt; blocks in a single XML file to perform multiple scans.</p>
<h2><a class="anchor" id="LiDARsynthdiscrete"></a>
Synthetic discrete-return data</h2>
<p>Once the <a class="el" href="class_li_d_a_rcloud.html">LiDARcloud</a> has been declared, and an XML file containing the scan parameters has been read, a discrete-return synthetic scan can be perfomed by calling LiDARcloud::syntheticScan( helios::Context*, const char* ). This version (i.e., without the optional rays_per_pulse and pulse_distance_threshold arguments) will perform a discrete-return synthetic scan.</p>
<p>The code block below gives an example XML file. As a reminder, you can place this XML file anywhere, but the path given to the <a class="el" href="class_li_d_a_rcloud.html#a6bd7e1839d1a6ecb738233b20b93f1f7" title="Read an XML file containing scan information.">LiDARcloud::loadXML()</a> function should either be absolute or relative to the directory in which the executable is being run (usually build/).</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> &lt;helios&gt;

    &lt;scan&gt;
      &lt;ASCII_format&gt; x y z r255 g255 b255 &lt;/ASCII_format&gt;
      &lt;origin&gt; 0 0 1.0 &lt;/origin&gt;
      &lt;size&gt; 2500 4500 &lt;/size&gt;
      &lt;thetaMin&gt; 30 &lt;/thetaMin&gt;
      &lt;thetaMax&gt; 130 &lt;/thetaMax&gt;
      &lt;phiMin&gt; 0 &lt;/phiMin&gt;
      &lt;phiMax&gt; 360 &lt;/phiMax&gt; 
    &lt;/scan&gt;

  &lt;/helios&gt;</code></pre></div><p>Example code is given below for generating synthetic discrete-return data and writing to an ASCII text file.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>  #include "Context.h"
  #include "LiDAR.h"

  using namespace helios;

  int main( void ){

     Context context;

     context.addPatch(); // create some model geometry here

     LiDARcloud pointcloud; //Initialize the LiDAR point cloud

     pointcloud.loadXML("/path/to/file.xml");  //Load the XML file

     pointcloud.syntheticScan( &amp;context );  //generate synthetic data

     pointcloud.exportPointCloud( "/path/to/file.xyz" );  //write to ASCII file

  }</code></pre></div><h2><a class="anchor" id="LiDARsynthwaveform"></a>
Synthetic waveform data</h2>
<p>Generation of synthetic full-waveform data is similar to discrete-return, except that additional information is needed to define the scan and simulation. In the XML file, the user must specify the diameter of the laser beam at the scan origin using the &lt;exitDiameter&gt; &lt;/exitDiameter&gt; tags, as well as the angle of beam divergence in radians using the &lt;beamDivergence&gt; &lt;/beamDivergence&gt; tags. If the exit diameter value is not specified, the default value of 0 is used, which means that the model will revert to discrete-return data generation. If the beam divergence value is not specified, a default beam divergence of 0 will be assumed, which effectively just means that the beam will remain perfectly cylindrical with diameter of exitDiameter.</p>
<p>Contents of an example XML file is given below.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> &lt;helios&gt;

    &lt;scan&gt;
      &lt;ASCII_format&gt; x y z r255 g255 b255 target_count target_index timestamp &lt;/ASCII_format&gt;
      &lt;origin&gt; 0 0 1.0 &lt;/origin&gt;
      &lt;size&gt; 2500 4500 &lt;/size&gt;
      &lt;thetaMin&gt; 30 &lt;/thetaMin&gt;
      &lt;thetaMax&gt; 130 &lt;/thetaMax&gt;
      &lt;phiMin&gt; 0 &lt;/phiMin&gt;
      &lt;phiMax&gt; 360 &lt;/phiMax&gt; 
      &lt;exitDiameter&gt; 0.005 &lt;/exitDiameter&gt;
      &lt;beamDivergence&gt; 0.003 &lt;/beamDivergence&gt;
    &lt;/scan&gt;

  &lt;/helios&gt;</code></pre></div><p>Running the synthetic data generation function requires the specificaiton of parameters associated with the simulation. The first is the number of rays to use per laser pulse in performing ray-tracing calculations, which sets the maximum possible number of hits possible per pulse. Specifying 1 ray/pulse effectively creates a discrete-return simulation, because that would mean you could only have a maximum of 1 hit/pulse. Ideally, you want a large number of rays/pulse because it allows for more hits/pulse if needed and results in more accureate simulations. The drawback to a very high number of rays/pulse is that the simulation will take longer to run. A value on the order of 100 is usually reasonable.</p>
<p>Second, the user needs to specify the distance threshold for aggregation of similar ray hit distances. For each simulated laser pulse, the number of rays/pulse specified above are launched from the scan origin. When some or all of those rays intersect the same surface, they will record a distance from the scanner to the hit point that is slightly different for each ray. Similar distances, which are presumed to lie on the same surface, are aggregated into a single hit point if they are within this distance threshold of each other. This is similar to how a real LiDAR instrument works as indicated in the sketch above, in that it aggregates similar returns into a single hit point. Specifying too small of a distance threshold may result in many duplicate hit points on the same surface. Specifying too large of a threshold may result in hit points that lie in between two disconnected surfaces (e.g., leaves). A threshold value that is smaller than the leaf or branch with is usually reasonable.</p>
<p>Below is example code with a rays/pulse value of 100 and distance threshold of 0.02.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>  #include "Context.h"
  #include "LiDAR.h"

  using namespace helios;

  int main( void ){

     Context context;

     context.addPatch(); // create some model geometry here

     LiDARcloud pointcloud; //Initialize the LiDAR point cloud

     pointcloud.loadXML("/path/to/file.xml");  //Load the XML file

     int rays_per_pulse = 100;
     float pulse_distance_threshold = 0.02; 

     pointcloud.syntheticScan( &amp;context, rays_per_pulse, pulse_distance_threshold );  //generate synthetic data

     pointcloud.exportPointCloud( "/path/to/file.xyz" );  //write to ASCII file

  }</code></pre></div><p>Synthetic hit points can be labeled based on the primitive they intersect based on the value of the primitive data "object_label" of type 'int'. Primitive groups can be labeled in any way by setting a common integer value for the "object_label" primitive data. In order to enable synthetic data labeling, the column "object_label" must be included within the &lt;ASCII_format&gt; tag in the scan XML file. The object_label value for each hit point will be recorded and a column will be written if the point cloud is exported to file.</p>
<h1><a class="anchor" id="LiDARvis"></a>
Visualizing results</h1>
<p>Results can be visualized using the <a class="el" href="class_visualizer.html" title="Class for visualization of simulation results.">Visualizer</a> plug-in for Helios. There are two possible means for doing so. First, is to add the relevant geometry to the Context, then visualize primitives in the Context using the <a class="el" href="class_visualizer.html" title="Class for visualization of simulation results.">Visualizer</a>. This works for the triangulation and plant reconstructions, but cannot be used to visualize just the point cloud since there is no "point" primitive in the Context. The next section describes how to accomplish this.</p>
<p>The second option is to add any geometry directly to the <a class="el" href="class_visualizer.html" title="Class for visualization of simulation results.">Visualizer</a>. There are several functions build in to the LiDAR plug-in that can to this automatically, which are listed below.</p>
<table class="doxtable">
<tr>
<th>Function</th><th>Description </th></tr>
<tr>
<td>LiDARcloud::addHitsToVisualizer( Visualizer * visualizer, const uint pointsize )</td><td>Add all hits in the point cloud to the visualizer. </td></tr>
<tr>
<td>LiDARcloud::addGridToVisualizer( Visualizer * visualizer )</td><td>Add all grid cells to the visualizer, which are displayed as translucent voxels. </td></tr>
<tr>
<td>LiDARcloud::addTrianglesToVisualizer( Visualizer * visualizer )</td><td>Add all triangles to the visualizer, which are colored by the r-g-b color value. </td></tr>
<tr>
<td>LiDARcloud::addTrianglesToVisualizer( Visualizer * visualizer, const uint gridcell )</td><td>Add triangles from a specified grid cell to the visualizer, which are colored by the r-g-b color value. </td></tr>
</table>
<p>The following code sample illustrates how to visualize the point cloud.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>   #include "Context.h"
   #include "LiDAR.h"
   #include "Visualizer.h"   

   using namespace helios;

   int main( void ){

      LiDARcloud pointcloud; //Initialize the LiDAR point cloud

      pointcloud.loadXML("/path/to/file.xml");  //Load the XML file

      Visualizer vis( 1000 ); //Initialize the visualizer

      pointcloud.addHitsToVisualizer( &amp;vis, 1 );  //Add the hit points to visualizer

      vis.plotInteractive();

   }</code></pre></div><h1><a class="anchor" id="LiDARoutput"></a>
Writing results to file</h1>
<p>Results of data processing can be easily written to file for external analysis. The following table lists these functions. Data is written to an ASCII text file, where each line in the file corresponds to a different data point (e.g., hit point, triangle, etc.).</p>
<table class="doxtable">
<tr>
<th>Function</th><th>Description </th></tr>
<tr>
<td><a class="el" href="class_li_d_a_rcloud.html#a2d0c11c6d8001171269232ff5d7f6322">LiDARcloud::exportPointCloud( const char* filename )</a> </td><td>Write the entire point cloud to ASCII file (this is usually only used for generated synthetic data). </td></tr>
<tr>
<td><a class="el" href="class_li_d_a_rcloud.html#ad030fdddcfa669d6af513eb66a9cbd1a">LiDARcloud::exportTriangleNormals( const char* filename )</a> </td><td>Write the unit normal vectors [nx ny nz] of all triangles formed from triangulation. </td></tr>
<tr>
<td><a class="el" href="class_li_d_a_rcloud.html#aa8376ce652d2e95e886d4d60d321c274">LiDARcloud::exportTriangleNormals( const char* filename, const int gridcell )</a> </td><td>Write the unit normal vectors of triangles formed from triangulation that reside in a specified grid cell. </td></tr>
<tr>
<td><a class="el" href="class_li_d_a_rcloud.html#a416638f486c4fd2572a9589b69605fe7">LiDARcloud::exportTriangleAreas( const char* filename )</a> </td><td>Write the areas of all triangles formed from triangulation. </td></tr>
<tr>
<td><a class="el" href="class_li_d_a_rcloud.html#adb93e3a16abc8100b2e5dac956c6cc3e">LiDARcloud::exportTriangleAreas( const char* filename, const int gridcell )</a> </td><td>Write the areas of triangles formed from triangulation that reside in a specified grid cell. </td></tr>
<tr>
<td><a class="el" href="class_li_d_a_rcloud.html#a8e8bd43bf3b2c107994fee402c41240f">LiDARcloud::exportLeafAreas( const char* filename )</a> </td><td>Write the leaf area contained within each voxel. Each line of the output file corresponds to the total leaf area within each voxel. </td></tr>
<tr>
<td><a class="el" href="class_li_d_a_rcloud.html#a6e438fd60af7f54f4d1c09ac64fd7338">LiDARcloud::exportLeafAreaDensities( const char* filename )</a> </td><td>Write the leaf area density of each voxel. Each line of the output file corresponds to the leaf area density of each voxel. </td></tr>
</table>
<p>The following code sample illustrates an example of how to write results to file.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>   #include "Context.h"
   #include "LiDAR.h"

   using namespace helios;

   int main( void ){

      LiDARcloud pointcloud; //Initialize the LiDAR point cloud

      pointcloud.loadXML("/path/to/file.xml");  //Load the XML file

      pointcloud.triangulateHitPoints( 0.05, 5 ); //Perform triangulation with Lmax=0.05 and maximum aspect ratio of 5

      pointcloud.calculateLeafAreaGPU(); //Calculate leaf area for each grid cell

      uint Ncells = pointcloud.getGridCellCount(); //Get the number of grid cells

      char f_normals[50], f_areas[50];
      for( uint i=0; i&lt;Ncells; i++ ){ //loop over grid cells
           <code></code>// define strings with output file names
           sprintf(f_normals,"../output/triangle_normals_%d.txt",i);
           sprintf(f_areas,"../output/triangle_areas_%d.txt",i);

           pointcloud.exportTriangleNormals( f_normals, i );
           pointcloud.exportTriangleAreas( f_areas, i );
      }
      pointcloud.exportLeafAreas( "../output/leaf_areas.txt" );
      pointcloud.exportLeafAreaDensities( "../output/leaf_area_densities.txt" );

      pointcloud.exportPointCloud( "../output/pointcloud.xyz" );                   

   }</code></pre></div> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
