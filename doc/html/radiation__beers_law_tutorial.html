<!-- HTML header for doxygen 1.12.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Helios: Tutorial 11: Light interception and fraction of sunlit/shaded leaf area for a homogeneous canopy</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph_link.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
  DoxygenAwesomeParagraphLink.init()
  DoxygenAwesomeTabs.init()
  DoxygenAwesomeInteractiveToc.init()
</script>
<script>
    try {
        // Remove the stored “last visited page” so the tree always starts fresh
        Cookie.eraseSetting('navpath');
        localStorage.removeItem('navpath');
        // Older Doxygen versions might use this key:
        localStorage.removeItem('nav-sync-path');
        // Force panel synchronization on by default
        localStorage.setItem('navsync', 'true');
        // (fallback for some older builds)
        localStorage.setItem('nav-sync', 'true');
    } catch(e) {
        /* storage unavailable? ignore */
    }
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-93BB4673PE"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-93BB4673PE');
</script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3F0Y5Z6543"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-3F0Y5Z6543');
</script>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="5">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Helios_logo_small.png"></td>
  <td id="projectalign">
   <div id="projectname">
       <span id="projectnumber">&#160;v1.3.36</span>
   </div>
  </td>
     <td id="searchbox-container">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('radiation__beers_law_tutorial.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial 11: Light interception and fraction of sunlit/shaded leaf area for a homogeneous canopy</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this tutorial, we will consider radiation transfer in a homogeneous, horizontally infinite canopy. This canonical canopy case will allow for comparison against theoretical values computed from Beer's law. Our goal will be to simulate the fraction of photosynthetically active radiation (PAR) absorbed by the canopy and the fraction of sunlit/shaded leaf area, and compare the 3D simulated values against Beer's law. This tutorial will integrate the <a class="el" href="_canopy_generator_doc.html">Canopy Generator</a> plug-in to create the canopy geometry, and the <a class="el" href="_voxel_intersection_doc.html">Voxel Intersection</a> plug-in to slice leaves that lie on the canopy boundary.</p>
<h1><a class="anchor" id="tutorial11_theory"></a>
0. Theory</h1>
<p>Beer's law describes the probability that a collimated bean of radiation propagating through a homogeneous medium of particulates is intercepted. For a canopy of leaves, Beer's law can be written as</p>
<p class="formulaDsp">
\[\dfrac{R}{R_0}=\left[1-\mathrm{exp}\left(-\dfrac{G\,LAI}{\mathrm{cos}\,\theta_s}\right)\right],\]
</p>
<p>where \(R\) is the average radiation flux absorbed by the canopy, \(R_0\) is the above-canopy radiation flux on a horizontal surface, \(R/R_0\) is the fraction of absorbed radiation, \(G\) is the fraction of leaf area projected in the direction of the sun, \(LAI\) is the one-sided canopy leaf area per unit ground area, and \(\theta_s\) is the solar zenith angle. The following are the assumptions used to derive this equation: 1) the leaf dimension is "much" smaller than the depth of the canopy layer, 2) the leaf angle distribution is azimuthally isotropic, 3) leaf position is spatially uniform, 4) the canopy extends infinitely in the lateral directions, 5) solar radiation is collimated (i.e., beams are parallel), and 6) leaves absorb all incident radiation.</p>
<p>Operating under similar assumptions, Beer's law can be integrated to determine the fraction of sunlit leaf area</p>
<p class="formulaDsp">
\[f_{sun}=\dfrac{\mathrm{cos}\,\theta_s}{G\,LAI}\left[1-\mathrm{exp}\left(-\dfrac{G\,LAI}{\mathrm{cos}\,\theta_s}\right)\right].\]
</p>
<h1><a class="anchor" id="tutorial11_geom"></a>
1. Model geometry creation</h1>
<p>We will use the <a class="el" href="_canopy_generator_doc.html">Canopy Generator</a> plug-in to create a canopy that matches the assumptions inherent in Beer's law described above. This will be a homogeneous canopy with azimuthally isotropic leaf angle distribution that extends infinitely in the horizontal (via applying periodic boundary conditions).</p>
<p>We start by defining a few variables that will be used later, including parameters specifying the canopy geometry. We'll use a spherical leaf angle distribution, although others are available (also uniform, planophile, erectophile, plagiophile, extremophile). The canopy has an LAI of 1.5 and a height of 1 m. The canopy extends 3x3 m<sup>2</sup> in the horizontal (but will be infinitely extended through periodic boundaries).</p>
<p>The Context is declared in the usual way. The <a class="el" href="class_canopy_generator.html">CanopyGenerator</a> class is then declared and initialized by passing a pointer to the Context. It's job is to add canopy geometry to the Context. The CanopyGenerator::HomogeneousCanopyParameters structure is declared, which is what is used to set the canopy variables. The leaf_angle_distribution, canopy_extent, canopy_height, and leaf_area_index are straight-forward and set based on the variables we declared above (reference the <a class="el" href="_canopy_generator_doc.html#CGenHomogeneous">canopy generator documentation</a> for the list and meaning of all possible variables).</p>
<p>The variables "buffer" and "leaf_subdivisions" are both important and less intuitive. We don't want the canopy to extend further than the horizontal extent we've specified (or the ground). This can be dealt with in two ways. One is to add a "buffer" of a half leaf width from the canopy boundaries such that no leaves lie on the boundaries. This is not ideal because it will result in a canopy that is not perfectly periodic. Alternatively, we could add no buffer and crop the canopy exactly to the canopy boundaries, which is what we'll do below. In that case, specify the buffer as "none".</p>
<p>The "leaf_subdivisions" variable specifies how many sub-patches (rectangles) should be used to represent each leaf. This does not matter much for computing total canopy absorbed radiation, but it is important to have adequate leaf sub-patch resolution to accurately compute the fraction of sunlit leaf area since we need to resolve shadows on leaves. See the references <a href="https://doi.org/10.1029/2020JG005796">Kent and Bailey (2021)</a> and <a href="https://doi.org/10.1093/insilicoplants/diab023">Bailey and Kent (2021)</a> for a detailed investigation. We'll use 5x5=25 sub-patches as a compromise.</p>
<p>The canopy is built using the <a class="el" href="class_canopy_generator.html#a1c7efa40c83c82ec081a7723c9c9ed98">CanopyGenerator::buildCanopy()</a> function, which takes the parameter structure we created earlier. UUIDs of leaf primitives in the canopy can be queried using the <a class="el" href="class_canopy_generator.html#a73680976a2826f0b5dbf567551fd5593">CanopyGenerator::getLeafUUIDs()</a> function, which we'll store for use in the next step.</p>
<h1><a class="anchor" id="tutorial11_slice"></a>
2. Slicing and cropping primitives on the boundaries</h1>
<p>As introduced above, we have not applied a "buffer" at the canopy boundaries, and thus we have some primitives that extend beyond the intended boundaries. We'll use the <a class="el" href="_voxel_intersection_doc.html">Voxel Intersection</a> plug-in to crop leaves to the exact location of the boundary, and then use the <a class="el" href="classhelios_1_1_context.html#aea4ea9dfed93b6e75cdc49ab3a94b023">helios::Context::cropDomain()</a> function to remove remaining leaf segments beyond the boundaries.</p>
<p>The VoxelIntersection class is declared and initialized in a similar way as other plug-ins by passing a pointer to the Context. It's job will be to slice any primitives lying on the canopy boundaries, which creates two or more triangle primitives with a break along the slicing plane. Two variables are defined that give the (x,y,z) coordinates of the canopy center location and the width of the canopy in the x-, y-, and z-directions:</p>
<div class="fragment"><div class="line">vec3 slice_box_center(0,0,0.5f*canopy_height);</div>
<div class="line">vec3 slice_box_size(canopy_extent.x,canopy_extent.y,canopy_height);</div>
</div><!-- fragment --><p>By default, the canopy is centered at the location (0, 0, 0.5*canopy_height), and as we specified before the dimensions of the canopy are (canopy_extent.x, canopy_extent.y, canopy_height).</p>
<p>The slicing is performed using the function <a class="el" href="class_voxel_intersection.html#a03d0dcdbf67ada3ba0d99b0e3754ef61">VoxelIntersection::slicePrimitivesUsingGrid()</a>. This function has the potential to slice based on a sub-divided voxelized grid, but since we only want to slice on the boundaries we'll specify the grid subdivisions as (1, 1, 1) (i.e., not subdivided).</p>
<p>The <a class="el" href="classhelios_1_1_context.html#aea4ea9dfed93b6e75cdc49ab3a94b023">helios::Context::cropDomain()</a> function is then used to crop the domain to the canopy boundaries, which will remove leaf segments outside of the specified boundaries. Some of the primitives the Canopy Generator created may no longer exist if the were sliced and/or cropped, and thus the "UUIDs_leaves" contains UUIDs referencing primitives that no longer exist. We can use the helios::Context::getAllUUIDs() function to get all the UUIDs currently in the Context, which at this point only contains leaves.</p>
<p>Finally, we add a ground surface using the helios::Context::addTile() function. For this particular tutorial, a ground is not explicitly needed because we have no diffuse/scattered radiation that could emanate from below.</p>
<h1><a class="anchor" id="tutorial11_rad"></a>
3. Radiation model set-up</h1>
<p>The set-up of the radiation model is very similar to the <a class="el" href="radiation_basics_tutorial.html">previous tutorial</a>, except for two main differences: 1) we add a collimated radiation source rather than a "sun sphere" to match the assumptions of Beer's law, 2) the solar flux is set to a normalize value of 1.0 since we only compute absorption fractions. A variable defining the sun direction was defined at the beginning of the main() function, which is used to set the direction of the collimated source. It is important to note that the solar flux value of 1.0 that we set for the source is the flux perpendicular to the sun direction, and needs to be multiplied by the cosine of the solar zenith angle to get the flux on a horizontal surface.</p>
<h1><a class="anchor" id="tutorial11_run"></a>
4. Run model and process results</h1>
<p>Radiation model calculations are performed when the <a class="el" href="class_radiation_model.html#a7d803f2b67bc4d0d89b2dc98a58d9ff1">RadiationModel::runBand()</a> function is called.</p>
<h2><a class="anchor" id="tutorial11_G"></a>
4a. Calculate G(theta)</h2>
<p>In order to apply Beer's law, we need to calculate the G-function (fraction of leaf area projected in the direction of the sun). In this example, we used a spherical leaf angle distribution, in which case G = 0.5 regardless of sun direction. However, if a different leaf angle distribution was used, G would vary with sun angle. Either way, it is a good exercise to calculate this important parameter.</p>
<p>The G-function is simply the average dot product (absolute value) between the leaf normal and the sun direction. In this example, each leaf element has the same area, but in general this may not be the case, and the average should be area-weighted to avoid biasing toward small primitives. Functions are available to perform each of the necessary operations: a) the <a class="el" href="classhelios_1_1_context.html#abfeadf8e6a35eb97da1439abc21c434e">helios::Context::getPrimitiveNormal()</a> function returns a unit vector pointing in the direction of the primitive normal, b) the <a class="el" href="classhelios_1_1_context.html#a1dafe58b3251d2ef9d09112258b2e85d">helios::Context::getPrimitiveArea()</a> function returns the primitive surface area, and c) the '*' operator when applied to two vec3's will calculate the dot product.</p>
<p>Calculation of the G-function based on the 3D geometry can be written as</p>
<p class="formulaDsp">
\[G = \sum\limits_i |\vec{n}_i \cdot \vec{n}_s |A_i/\sum\limits_i A_i,\]
</p>
<p>where \(\vec{n}_i\) is the normal of the i<sup>th</sup> leaf primitive (unit length), \(\vec{n}_s\) is a unit vector pointing in the direction of the sun, and \(A_i\) is the area of the i<sup>th</sup> leaf primitive.</p>
<h2><a class="anchor" id="tutorial11_abs"></a>
4b. Calculate radiation flux absorbed by the canopy on a ground area basis</h2>
<p>Beer's law gives the radiation flux absorbed by the canopy on a ground area basis, so we will need to calculate this flux based on the 3D model result. It is important to note that the 3D model gives fluxes on a leaf area basis, which can be converted to ground area basis by multiplying the LAI.</p>
<p>The flux absorbed by the canopy \(R\) is simply the area-weighted average leaf PAR flux multiplied by the LAI, which can be written as</p>
<p class="formulaDsp">
\[R = LAI\sum\limits_i R_i A_i / \sum\limits_i A_i,\]
</p>
<p>where \(R_i\) is the absorbed PAR flux of the i<sup>th</sup> leaf primitive. The <a class="el" href="classhelios_1_1_context.html#acbc8e2f6b09248ef0e1b4039ae49dc3f">helios::Context::calculatePrimitiveDataAreaWeightedMean()</a> function can be used to easily calculate the area-weighted average of the primitive data "radiation_flux_PAR".</p>
<h2><a class="anchor" id="tutorial11_absBeer"></a>
4c. Calculate the theoretical absorbed PAR flux using Beer's law</h2>
<p>The theoretical absorbed PAR flux can be calculated by substituting appropriate values into the equation for Beer's law given above. One important thing to remember is that the radiation flux specified in Helios is the flux on the surface perpendicular to the sun direction, whereas the source flux specified in Beer's law is the flux on a horizontal surface. Thus, the source flux specified in Helios needs to be multiplied by \(\mathrm{cos}\,\theta_s\) to get the flux on a horizontal surface. The <a class="el" href="group__functions.html#ga32a34b00e0a28f4b35e501b8b34cfccd">helios::cart2sphere()</a> function is used to convert our Cartesian vector specifying the sun direction into a spherical coordinate, from which we can get the zenith angle.</p>
<h2><a class="anchor" id="tutorial11_fsun"></a>
4d. Calculate the sunlit leaf area fraction from the simulation</h2>
<p>In order to calculate the fraction of sunlit leaf area for the canopy, we need to determine whether each leaf element is sunlit or shaded. This is tricky because 1) the fully sunlit PAR flux for a given leaf depends on its angle relative to the sun, and 2) many leaves will neither be 100% sunlit or 100% shaded, but somewhere in between. To deal with the first issue, we first calculate what the fully sunlit flux should be for each leaf based on its angle, which is</p>
<p class="formulaDsp">
\[R_{sun} = R_{source}|\vec{n} \cdot \vec{n}_s|,\]
</p>
<p>where \(R_{source}\) is the PAR flux on a plane perpendicular to the sun, and other symbols are as defined above. We then define a "sunlit" leaf as a leaf whose actual absorbed flux is greater than 50% of \(R_{sun}\). We then identify which leaves are "sunlit" according to this definition, and sum their areas. The fraction of sunlit leaf area is then the area of sunlit leaves divided by the total leaf area.</p>
<h2><a class="anchor" id="tutorial11_fsunBeer"></a>
4e. Calculate the theoretical sunlit area fraction</h2>
<p>Calculation of the theoretical fraction of sunlit leaf area is simply a matter of plugging values into the equation for \(f_{sun}\) above.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_radiation_model_8h.html">RadiationModel.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_canopy_generator_8h.html">CanopyGenerator.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="_voxel_intersection_8h.html">VoxelIntersection.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>helios; <span class="comment">//note that we are using the helios namespace so we can omit &#39;helios::&#39; before names</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// !!!!!!!!! Inputs for this example study !!!!!!!!! //</span></div>
<div class="line"> </div>
<div class="line">   <a class="code hl_struct" href="structhelios_1_1vec3.html" title="Vector of three elements of type &#39;float&#39;.">vec3</a> sun_direction(1,0,1);                              <span class="comment">//Cartesian unit vector pointing in the direction of (toward) the sun</span></div>
<div class="line">   sun_direction.normalize();</div>
<div class="line"> </div>
<div class="line">   std::string leaf_angle_dist = <span class="stringliteral">&quot;spherical&quot;</span>;              <span class="comment">//name of leaf angle distribution for the canopy - (spherical, uniform, planophile, erectophile, plagiophile, extremophile)</span></div>
<div class="line"> </div>
<div class="line">   <span class="keywordtype">float</span> LAI = 1.5f;                                       <span class="comment">//one-sided leaf area index of the canopy</span></div>
<div class="line"> </div>
<div class="line">   <a class="code hl_struct" href="structhelios_1_1vec2.html" title="Vector of two elements of type &#39;float&#39;.">vec2</a> canopy_extent(3,3);                                <span class="comment">//dimension of the canopy in the x- and y-directions (horizontal)</span></div>
<div class="line">   <span class="keywordtype">float</span> canopy_height = 1.f;                              <span class="comment">//vertical dimension of the canopy</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// *** 1. Model geometry creation *** //</span></div>
<div class="line"> </div>
<div class="line">   <a class="code hl_class" href="classhelios_1_1_context.html" title="Stores the state associated with simulation.">Context</a> context;                                        <span class="comment">//declare the Context class</span></div>
<div class="line"> </div>
<div class="line">   <a class="code hl_class" href="class_canopy_generator.html">CanopyGenerator</a> cgen(&amp;context);                        <span class="comment">//declare the Canopy Generator class and pass it the Context so it can add geometry</span></div>
<div class="line"> </div>
<div class="line">   <a class="code hl_struct" href="struct_homogeneous_canopy_parameters.html" title="Parameters defining the homogeneous canopy.">HomogeneousCanopyParameters</a> params;                    <span class="comment">//structure containing parameters for homogeneous canopy</span></div>
<div class="line">   params.<a class="code hl_variable" href="struct_homogeneous_canopy_parameters.html#a1b6de173fb1f5e71f4d8e7ff9ae99881" title="String specifying whether leaves should be placed so that leaf edges do not fall outside the specifie...">buffer</a> = <span class="stringliteral">&quot;none&quot;</span>;                                 <span class="comment">//no buffer on the canopy edges - we will slice along border</span></div>
<div class="line">   params.<a class="code hl_variable" href="struct_homogeneous_canopy_parameters.html#a9d22fee5250b0fc616acdd91e5cb34b2" title="Leaf angle distribution - one of &quot;spherical&quot;, &quot;uniform&quot;, &quot;erectophile&quot;, &quot;planophile&quot;,...">leaf_angle_distribution</a> = leaf_angle_dist;       <span class="comment">//set the leaf angle distribution based on the variable we set above</span></div>
<div class="line">   params.<a class="code hl_variable" href="struct_homogeneous_canopy_parameters.html#a68c488e6bd2f209af3a46ce8aca4bf60" title="Horizontal extent of the canopy in the x- and y-directions.">canopy_extent</a> = canopy_extent;                   <span class="comment">//set the lateral canopy extent based on the variable we set above</span></div>
<div class="line">   params.<a class="code hl_variable" href="struct_homogeneous_canopy_parameters.html#a80df27cc13e2b7f113d52e405ddb2737" title="Height of the canopy.">canopy_height</a> = canopy_height;                   <span class="comment">//set the canopy height based on the variable we set above</span></div>
<div class="line">   params.<a class="code hl_variable" href="struct_homogeneous_canopy_parameters.html#ae8880f6cbbdd6c69caee3cedba4ef542" title="One-sided leaf area index of the canopy.">leaf_area_index</a> = LAI;                           <span class="comment">//set the canopy LAI based on the variable we set above</span></div>
<div class="line"> </div>
<div class="line">   params.<a class="code hl_variable" href="struct_homogeneous_canopy_parameters.html#a7e385ca3b257c8012d8336c03a617b31" title="Number of sub-division segments per leaf.">leaf_subdivisions</a> = <a class="code hl_function" href="group__vectors.html#ga70f2d62c3dfc6bbff6581cbc0f8bacee" title="Make an int2 vector from two ints.">make_int2</a>(5,5);              <span class="comment">//set the number of subdivisions per leaf to be 5x5=25 primitives</span></div>
<div class="line"> </div>
<div class="line">   cgen.buildCanopy(params);                               <span class="comment">//build the homogeneous canopy</span></div>
<div class="line"> </div>
<div class="line">   std::vector&lt;uint&gt; UUIDs_leaves = cgen.getLeafUUIDs();   <span class="comment">//get UUIDs for all leaves in the canopy</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// *** 2. Slicing and cropping primitives on the boundaries *** //</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// slice and primitives that lie on the canopy boundaries (imagine taking a knife and perfectly cutting along the edges of the canopy)</span></div>
<div class="line">   <a class="code hl_class" href="class_voxel_intersection.html">VoxelIntersection</a> vslice(&amp;context);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// define variables that give the center (x,y,z) coordinate of the canopy and the overall canopy dimensions</span></div>
<div class="line">   <a class="code hl_struct" href="structhelios_1_1vec3.html" title="Vector of three elements of type &#39;float&#39;.">vec3</a> slice_box_center(0,0,0.5f*canopy_height);</div>
<div class="line">   <a class="code hl_struct" href="structhelios_1_1vec3.html" title="Vector of three elements of type &#39;float&#39;.">vec3</a> slice_box_size(canopy_extent.x,canopy_extent.y,canopy_height);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// do the slicing</span></div>
<div class="line">   vslice.slicePrimitivesUsingGrid( UUIDs_leaves, slice_box_center, slice_box_size, <a class="code hl_function" href="helios__vector__types_8h.html#a55971d7a623ad5c10a74e7eda37c2149" title="Make an int3 vector from three ints.">make_int3</a>(1,1,1) );</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// delete any leaf slices that fall outside of the slicing volume</span></div>
<div class="line">   context.<a class="code hl_function" href="classhelios_1_1_context.html#aea4ea9dfed93b6e75cdc49ab3a94b023" title="Crop specified UUIDs such that they lie within some specified axis-aligned box.">cropDomain</a>( <a class="code hl_function" href="group__vectors.html#ga2c8ce4551d0597a3aaaf32530233c6fd" title="Make a vec2 from two floats.">make_vec2</a>(-0.5f*canopy_extent.x,0.5f*canopy_extent.x), <a class="code hl_function" href="group__vectors.html#ga2c8ce4551d0597a3aaaf32530233c6fd" title="Make a vec2 from two floats.">make_vec2</a>(-0.5f*canopy_extent.y,0.5f*canopy_extent.y), <a class="code hl_function" href="group__vectors.html#ga2c8ce4551d0597a3aaaf32530233c6fd" title="Make a vec2 from two floats.">make_vec2</a>(0,canopy_height) );</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// our UUID vector now contains some primitives that have been deleted. We can just get all the primitives currently in the Context and store them in a vector</span></div>
<div class="line">   UUIDs_leaves = context.<a class="code hl_function" href="classhelios_1_1_context.html#a98516632daccf958cca6b5b6582310bb" title="Get all primitive UUIDs currently in the Context.">getAllUUIDs</a>();</div>
<div class="line"> </div>
<div class="line">   <span class="comment">//make a ground</span></div>
<div class="line">   std::vector&lt;uint&gt; UUIDs_ground = context.<a class="code hl_function" href="group__compoundobjects.html#gae15ba3f5741d27c52c43a35eec6c866b" title="Add a patch that is subdivided into a regular grid of sub-patches (tiled)">addTile</a>(<a class="code hl_function" href="helios__vector__types_8h.html#acff34a9c833707c7aef9618cd19265c5" title="Make a vec3 from three floats.">make_vec3</a>(0, 0, 0), canopy_extent, <a class="code hl_variable" href="global_8h.html#adcd5a98ec7c45292736ec8e19ce9de51" title="Default null SphericalCoord that applies no rotation.">nullrotation</a>,<a class="code hl_function" href="group__vectors.html#ga70f2d62c3dfc6bbff6581cbc0f8bacee" title="Make an int2 vector from two ints.">make_int2</a>(10, 10));</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// *** 3. Radiation model set-up *** //</span></div>
<div class="line"> </div>
<div class="line">   <a class="code hl_class" href="class_radiation_model.html" title="Radiation transport model plugin.">RadiationModel</a> radiation(&amp;context);                      <span class="comment">//declare and initialize the radiation model class</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// add a sun source. We&#39;ll assume collimated radiation since that is what is assumed in Beer&#39;s law</span></div>
<div class="line">   uint sourceID = radiation.addCollimatedRadiationSource( sun_direction );</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// set up the PAR band. We&#39;ll use separate direct and diffuse bands to keep them separate for post-processing (normally you would combine them)</span></div>
<div class="line">   radiation.addRadiationBand(<span class="stringliteral">&quot;PAR&quot;</span>);</div>
<div class="line">   radiation.disableEmission(<span class="stringliteral">&quot;PAR&quot;</span>);</div>
<div class="line">   radiation.setSourceFlux(sourceID, <span class="stringliteral">&quot;PAR&quot;</span>, 1.f);  <span class="comment">//set a flux of 1.0 W/m^2 to simplify calculations</span></div>
<div class="line">   radiation.setDiffuseRadiationFlux(<span class="stringliteral">&quot;PAR&quot;</span>, 0.f);      <span class="comment">//no diffuse radiation this band</span></div>
<div class="line"> </div>
<div class="line">   radiation.enforcePeriodicBoundary(<span class="stringliteral">&quot;xy&quot;</span>);      <span class="comment">//use periodic boundary conditions in the horizontal to simulate an infinite canopy</span></div>
<div class="line"> </div>
<div class="line">   context.<a class="code hl_function" href="classhelios_1_1_context.html#a817fe7d1b8a11f51923d3a7e2c3ba092" title="Add data value (int) associated with a primitive element.">setPrimitiveData</a>(UUIDs_ground, <span class="stringliteral">&quot;twosided_flag&quot;</span>,uint(0)); <span class="comment">//only want ground to intercept/emit radiation from the top</span></div>
<div class="line"> </div>
<div class="line">   radiation.updateGeometry();                            <span class="comment">//update the geometry in the radiation model</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// 4. Run model and process results //</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">//Run the radiation model calculations</span></div>
<div class="line">   radiation.runBand(<span class="stringliteral">&quot;PAR&quot;</span>);</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// 4a. Calculate G(theta)</span></div>
<div class="line">   <span class="keywordtype">float</span> Gtheta = 0;</div>
<div class="line">   <span class="keywordtype">float</span> area_total = 0;</div>
<div class="line">   <span class="keywordflow">for</span>( <span class="keyword">auto</span> UUID : UUIDs_leaves ){</div>
<div class="line">     <a class="code hl_struct" href="structhelios_1_1vec3.html" title="Vector of three elements of type &#39;float&#39;.">vec3</a> normal = context.<a class="code hl_function" href="classhelios_1_1_context.html#abfeadf8e6a35eb97da1439abc21c434e" title="Method to return the normal vector of a Primitive.">getPrimitiveNormal</a>(UUID);</div>
<div class="line">     <span class="keywordtype">float</span> area = context.<a class="code hl_function" href="classhelios_1_1_context.html#a1dafe58b3251d2ef9d09112258b2e85d" title="Method to return the surface area of a Primitive.">getPrimitiveArea</a>(UUID);</div>
<div class="line">     Gtheta += std::abs( sun_direction*normal )*area;</div>
<div class="line">     area_total += area;</div>
<div class="line">   }</div>
<div class="line">   Gtheta = Gtheta/area_total;  <span class="comment">//normalize</span></div>
<div class="line"> </div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;G(theta) = &quot;</span> &lt;&lt; Gtheta &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// 4b. Calculate radiation flux absorbed by the canopy on a ground area basis - this will end up just being the area-weighted average PAR flux multiplied by LAI.</span></div>
<div class="line"> </div>
<div class="line">   <span class="keywordtype">float</span> PAR_abs_dir;</div>
<div class="line">   context.<a class="code hl_function" href="classhelios_1_1_context.html#acbc8e2f6b09248ef0e1b4039ae49dc3f" title="Calculate mean of primitive data values (float) for a subset of primitives, where each value in the m...">calculatePrimitiveDataAreaWeightedMean</a>( UUIDs_leaves, <span class="stringliteral">&quot;radiation_flux_PAR&quot;</span>, PAR_abs_dir ); <span class="comment">//recall that the output primitive data from the radiation model has the form &quot;radiation_flux_[*band_name*]&quot;</span></div>
<div class="line">   PAR_abs_dir = PAR_abs_dir*LAI; <span class="comment">//converts between leaf area basis to ground area basis</span></div>
<div class="line"> </div>
<div class="line">   <span class="comment">// 4c. Calculate the theoretical absorbed PAR flux using Beer&#39;s law</span></div>
<div class="line"> </div>
<div class="line">   <span class="keywordtype">float</span> theta_s = <a class="code hl_function" href="group__functions.html#ga32a34b00e0a28f4b35e501b8b34cfccd" title="Convert Cartesian coordinates to spherical coordinates.">cart2sphere</a>(sun_direction).zenith;  <span class="comment">//calculate the solar zenith angle</span></div>
<div class="line"> </div>
<div class="line">   <span class="keywordtype">float</span> R0 = cos(theta_s); <span class="comment">//PAR flux on horizontal surface</span></div>
<div class="line">   <span class="keywordtype">float</span> intercepted_theoretical_direct = R0*(1.f-exp(-Gtheta*LAI/cos(theta_s)));  <span class="comment">//Beer&#39;s law</span></div>
<div class="line"> </div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;Calculated interception: &quot;</span> &lt;&lt; PAR_abs_dir &lt;&lt; std::endl;</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;Theoretical interception: &quot;</span> &lt;&lt; intercepted_theoretical_direct &lt;&lt; std::endl;</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;Error of interception: &quot;</span> &lt;&lt; std::abs(PAR_abs_dir-intercepted_theoretical_direct)/intercepted_theoretical_direct*100.f &lt;&lt; <span class="stringliteral">&quot; %&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// 4d. Calculate the sunlit leaf area fraction from the simulation</span></div>
<div class="line"> </div>
<div class="line">   <span class="keywordtype">float</span> sunlit_area = 0;</div>
<div class="line">   <span class="keywordtype">float</span> total_area = 0;</div>
<div class="line">   <span class="keywordflow">for</span>( <span class="keyword">auto</span> UUID : UUIDs_leaves ){ <span class="comment">//looping over all leaf elements</span></div>
<div class="line"> </div>
<div class="line">     <a class="code hl_struct" href="structhelios_1_1vec3.html" title="Vector of three elements of type &#39;float&#39;.">vec3</a> normal = context.<a class="code hl_function" href="classhelios_1_1_context.html#abfeadf8e6a35eb97da1439abc21c434e" title="Method to return the normal vector of a Primitive.">getPrimitiveNormal</a>(UUID);</div>
<div class="line"> </div>
<div class="line">     <span class="keywordtype">float</span> PARmax = std::abs( normal*sun_direction );  <span class="comment">//this is the PAR flux of a leaf with the same normal that is fully sunlit</span></div>
<div class="line"> </div>
<div class="line">     <span class="keywordtype">float</span> PAR;</div>
<div class="line">     context.<a class="code hl_function" href="classhelios_1_1_context.html#a2144eea981e4030c973287ce2c38315e" title="Get data associated with a primitive element.">getPrimitiveData</a>( UUID, <span class="stringliteral">&quot;radiation_flux_PAR&quot;</span>, PAR ); <span class="comment">//get this leaf&#39;s PAR flux</span></div>
<div class="line"> </div>
<div class="line">     <span class="keywordtype">float</span> fsun_leaf = PAR/PARmax;  <span class="comment">//PAR flux as a fraction of the fully sunlit flux</span></div>
<div class="line"> </div>
<div class="line">     <span class="keywordtype">float</span> area = context.<a class="code hl_function" href="classhelios_1_1_context.html#a1dafe58b3251d2ef9d09112258b2e85d" title="Method to return the surface area of a Primitive.">getPrimitiveArea</a>(UUID);</div>
<div class="line"> </div>
<div class="line">     <span class="keywordflow">if</span>( fsun_leaf&gt;0.5 ){ <span class="comment">//if fsun is greater than 0.5, we&#39;ll call this leaf &quot;sunlit&quot;</span></div>
<div class="line">       sunlit_area += area;</div>
<div class="line">     }</div>
<div class="line">     total_area += area;</div>
<div class="line"> </div>
<div class="line">   }</div>
<div class="line"> </div>
<div class="line">   <span class="keywordtype">float</span> fsun = sunlit_area/total_area;</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// 4e. Calculate the theoretical sunlit area fraction</span></div>
<div class="line"> </div>
<div class="line">   <span class="keywordtype">float</span> fsun_theoretical = cos(theta_s)/(Gtheta*LAI)*(1-exp(-Gtheta*LAI/cos(theta_s)));</div>
<div class="line"> </div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;Calculated sunlit fraction: &quot;</span> &lt;&lt; fsun &lt;&lt; std::endl;</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;Theoretical sunlit fraction: &quot;</span> &lt;&lt; fsun_theoretical &lt;&lt; std::endl;</div>
<div class="line">   std::cout &lt;&lt; <span class="stringliteral">&quot;Error of sunlit fraction: &quot;</span> &lt;&lt; std::abs(fsun-fsun_theoretical)/fsun_theoretical*100.f &lt;&lt; <span class="stringliteral">&quot; %&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
