<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>.: Helios Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-93BB4673PE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-93BB4673PE');
</script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3F0Y5Z6543"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-3F0Y5Z6543');
</script>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Helios_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname"><span id="projectnumber">&#160;v1.3.10</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part --><!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="_plug_ins.html">Plug-ins</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Visualizer Plugin Documentation </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#VisDepends">Dependencies</a></li>
<li class="level1"><a href="#VisIssues">Known Issues</a></li>
<li class="level1"><a href="#VisIntro">Introduction</a></li>
<li class="level1"><a href="#VisClass">Class Constructor(s)</a></li>
<li class="level1"><a href="#UseVis">Using the Visualizer Plug-in</a><ul><li class="level2"><a href="#coord">Coordinate Systems</a></li>
<li class="level2"><a href="#Window">Visualization Window</a></li>
<li class="level2"><a href="#Background">Window background</a></li>
<li class="level2"><a href="#AddGeom">Adding Geometry</a><ul><li class="level3"><a href="#ContextGeom">Automatically importing Context geometry</a></li>
</ul>
</li>
<li class="level2"><a href="#PlotWindow">Plotting Geometry</a><ul><li class="level3"><a href="#PlotInteractive">plotInteractive()</a></li>
<li class="level3"><a href="#ViewControls">View Controls</a></li>
<li class="level3"><a href="#PlotUpdate">plotUpdate()</a></li>
</ul>
</li>
<li class="level2"><a href="#ColorShade">Colors and Shading</a><ul><li class="level3"><a href="#ColoringRGB">Coloring by r-g-b code</a></li>
<li class="level3"><a href="#ColoringTexture">Coloring by texture map</a></li>
<li class="level3"><a href="#ColoringPseudo">Coloring by pseudocolor map</a></li>
<li class="level3"><a href="#Cbar">Colorbar</a></li>
<li class="level3"><a href="#Shading">Shading</a></li>
</ul>
</li>
<li class="level2"><a href="#Options">View Options</a></li>
</ul>
</li>
<li class="level1"><a href="#VisAcklowledgements">Acknowledgements</a></li>
</ul>
</div>
<div class="textblock"><div class="image">
<img src="Visualizer.png" alt=""/>
</div>
<table class="doxtable">
<tr>
<th>Dependencies </th><td>X11/xorg (Mac/Linux)  </td></tr>
<tr>
<th>CMakeLists.txt </th><td>set( PLUGINS "visualizer" )  </td></tr>
<tr>
<th>Header File </th><td>#include "Visualizer.h"  </td></tr>
<tr>
<th>Class </th><td><a class="el" href="class_visualizer.html">Visualizer</a>  </td></tr>
</table>
<h1><a class="anchor" id="VisDepends"></a>
Dependencies</h1>
<table class="doxtable">
<caption>Installing dependent packages</caption>
<tr>
<th>Package </th><td><div class="image">
<img src="apple-logo.jpg" alt=""/>
</div>
td </td><td><div class="image">
<img src="unix-logo.png" alt=""/>
</div>
td </td><td><div class="image">
<img src="windows-logo.jpg" alt=""/>
</div>
td  </td></tr>
<tr>
<td>X11/xorg </td><td><div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2"><code>$ brew install Caskroom/cask/xquartz</code></div> </td><td>Debian/Ubuntu:<br  />
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2"><code>$ sudo apt-get install libx11-dev xorg-dev libgl1-mesa-dev libglu1-mesa-dev libxrandr-dev</code></div> </td><td>None (if using Visual Studio)  </td></tr>
</table>
<h1><a class="anchor" id="VisIssues"></a>
Known Issues</h1>
<ul>
<li>The visualizer does not work well for visualizing very large point clouds, as it will be very slow to respond.</li>
</ul>
<h1><a class="anchor" id="VisIntro"></a>
Introduction</h1>
<p>This plugin facilitates visualization of model geometry and data. It can visualize a number of different geometric shapes, including all of the primitive types supported by the Helios context. Individual geometric objects can be added though API commands, and there is a command to automatically add all geometric primitives from the Helios context.</p>
<h1><a class="anchor" id="VisClass"></a>
Class Constructor(s)</h1>
<table class="doxtable">
<tr>
<th>Constructors  </th></tr>
<tr>
<td><a class="el" href="class_visualizer.html#a9277e99596d46d77d31a2249a1406983">Visualizer( uint Wdisplay )</a>  </td></tr>
<tr>
<td><a class="el" href="class_visualizer.html#ac39e631c7d248c0e0f4f9ebba58a6dc4">Visualizer( uint Wdisplay, uint Hdisplay )</a>  </td></tr>
</table>
<p>The class associated with the visualization is called <a class="el" href="class_visualizer.html" title="Class for visualization of simulation results.">Visualizer</a>. The class constructor takes one or two arguments that specifies the size of the graphics window. If only one argument is provided (see <a class="el" href="class_visualizer.html">Visualizer( uint Wdisplay )</a>), the argument is an integer that specifies the width of the diplay window in pixels, with the hight of the window specified according to the default aspect ratio. If two arguments are provided (see <a class="el" href="class_visualizer.html">Visualizer( uint Wdisplay, uint Hdisplay )</a>), the two arguments correspond respectively to the width and height of the display window in pixels. Below is an example program:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.4"> <pre><code> #include "Visualizer.h"

  int main( void ){
      Visualizer vis( 1200 ); //Opens a graphics window of width 1200 pixels with default aspect ratio
  }</code></pre> </div><h1><a class="anchor" id="UseVis"></a>
Using the Visualizer Plug-in</h1>
<h2><a class="anchor" id="coord"></a>
Coordinate Systems</h2>
<p>The visualizer uses two types of coordinate systems to specify the locations of points in space during visualization:</p>
<ol>
<li>
<a class="el" href="class_visualizer.html#a084713b3d4d0720dcc1ee44d270b42e3a9392af82f887f2fc1982a8315bcc95f5">COORDINATES_WINDOW_NORMALIZED</a> - Coordinates are normalized to unity and are window-aligned. The point (x,y)=(0,0) is in the bottom left corner of the window, and (x,y)=(1,1) is in the upper right corner of the window. The z-coordinate specifies the depth in the screen-normal direction, with values ranging from -1 to 1. For example, an object at z=0.5 would be behind an object at z=0. This coordinate system is typically used when annotating visualizations with text, adding watermarks, or adding objects to the dashboard. </li>
<li>
<a class="el" href="class_visualizer.html#a084713b3d4d0720dcc1ee44d270b42e3a83efc5e87fcf84a8c3d646e77adf53d4">COORDINATES_CARTESIAN</a> - Coordinates are specified in a 3D Cartesian system (right-handed), where +z is vertical. This coordinate system is typically used when adding model geometry or 3D objects. </li>
</ol>
<h2><a class="anchor" id="Window"></a>
Visualization Window</h2>
<p>In order to actually display a window for visualization, we must issue a comand to plot the geometry. There are different comands to produce a visualization window depending on the intended output:</p>
<ul>
<li>
<a class="el" href="class_visualizer.html#ab4858ed12fa78fe451569f4bbc27cd7c">plotInteractive()</a> - Open an interactive visualization window that allows for user input control. This type of visualization allows for one to, for example, rotate the view or zoom in/out. This will cause the program to wait until the window is closed by the user to continue. </li>
<li>
<a class="el" href="class_visualizer.html#aa87c684dd84db8d1ae0d12872b1dda22">plotUpdate()</a> - Open a window and update it with the current visualization, then continue the program. This does not allow for any user input, since it continues on without checking for input. This is useful when generating a large number of visualization images for a movie. <br  />
 </li>
</ul>
<p>If <a class="el" href="class_visualizer.html#aa87c684dd84db8d1ae0d12872b1dda22">plotUpdate()</a> is issued, another command <a class="el" href="class_visualizer.html#a2db00c518bf610fdcb70e0ec5a5a0e32">printWindow()</a> can be used to output the current visualization to file (JPEG files only).</p>
<p>The current window can be closed using the <a class="el" href="class_visualizer.html#a6b7be76387563b2981bba995a7578d78">closeWindow()</a> command.</p>
<p>Below is an example of opening a window (blank), exporting its contents to file, then closing the window:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2"> <pre><code> #include "Visualizer.h"

   int main( void ){
      Visualizer vis( 1200 );
      vis.plotUpdate(); //we have not added geometry, so window is blank
      vis.printWindow("blank_window.jpg");
      vis.closeWindow();
    }</code></pre> </div><h2><a class="anchor" id="Background"></a>
Window background</h2>
<p>The window background can be set to a constant color via the command setBackgroundColor( RGBcolor color ). Alternatively, a three-dimensional &lsquo;sky&rsquo; background can be set using the <a class="el" href="class_visualizer.html#abc14ae2206a8b46c9724cc6aac06b44b">addSkyDomeByCenter</a> command. This adds a hemispherical dome with a sky texture image mapped to its surface. The default sky texture is &lsquo;SkyDome_clouds.jpg&rsquo; located in the plugins/visualizer/textures directory. The following example shows how to add a sky dome:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2"> <pre><code> #include "Visualizer.h"

   int main( void ){
      Visualizer vis( 1200 );
      vis.addSkyDomeByCenter( 100, make_vec3(0,0,0), 20, "plugins/visualizer/textures/SkyDome_clouds.jpg", 0 );
   }</code></pre> </div><p>In the example, we have created a sky dome with a radius of 100 centered at the origin (0,0,0), 20 divisions in the spherical coordinate directions (elevation,azimuth), and on layer 0.</p>
<h2><a class="anchor" id="AddGeom"></a>
Adding Geometry</h2>
<p>Next, we will learn how to add objects to the visualization. The visualizer supports the following objects:</p>
<table class="doxtable">
<tr>
<th>Primitive </th><th>Description </th><th>Add Functions  </th></tr>
<tr>
<td>Rectangle </td><td>Rectangular polygon with coplanar vertices. </td><td><ul>
<li>
Visualizer::addRectangleByCenter( const helios::vec3 &amp;center, const helios::vec2 &amp;size, const helios::SphericalCoord &amp;rotation, const helios::RGBcolor &amp;color, CoordinateSystem coordFlag ) </li>
<li>
Visualizer::addRectangleByCenter( const helios::vec3 &amp;center, const helios::vec2 &amp;size, const helios::SphericalCoord &amp;rotation, const helios::RGBAcolor &amp;color, CoordinateSystem coordFlag ) </li>
<li>
Visualizer::addRectangleByCenter( const helios::vec3 &amp;center, const helios::vec2 &amp;size, const helios::SphericalCoord &amp;rotation, const char* texture_file, CoordinateSystem coordFlag ) </li>
<li>
Visualizer::addRectangleByCenter( const helios::vec3 &amp;center, const helios::vec2 &amp;size, const helios::SphericalCoord &amp;rotation, const helios::RGBcolor &amp;color, const char* texture_file, CoordinateSystem coordFlag ) </li>
<li>
Visualizer::addRectangleByVertices( const std::vector&lt;helios::vec3&gt;&amp; vertices, const helios::RGBcolor &amp;color, CoordinateSystem coordFlag ) </li>
<li>
Visualizer::addRectangleByVertices( const std::vector&lt;helios::vec3&gt;&amp; vertices, const helios::RGBAcolor &amp;color, CoordinateSystem coordFlag ) </li>
<li>
Visualizer::addRectangleByVertices( const std::vector&lt;helios::vec3&gt;&amp; vertices, const char* texture_file, CoordinateSystem coordFlag ) </li>
<li>
Visualizer::addRectangleByVertices( const std::vector&lt;helios::vec3&gt;&amp; vertices, const helios::RGBcolor &amp;color, const char* texture_file, CoordinateSystem coordFlag )   </li>
</ul>
</td></tr>
<tr>
<td>Triangle </td><td>Triangular polygon specified by its three vertices. </td><td><ul>
<li>
Visualizer::addTriangle( const helios::vec3 &amp;vertex0, const helios::vec3 &amp;vertex1, const helios::vec3 &amp;vertex2, const helios::RGBcolor &amp;color, CoordinateSystem coordFlag ) </li>
<li>
Visualizer::addTriangle( const helios::vec3 &amp;vertex0, const helios::vec3 &amp;vertex1, const helios::vec3 &amp;vertex2, const helios::RGBAcolor &amp;color, CoordinateSystem coordFlag ) </li>
<li>
Visualizer::addTriangle( const helios::vec3 &amp;vertex0, const helios::vec3 &amp;vertex1, const helios::vec3 &amp;vertex2, const char* texture_file, const helios::vec2 &amp;uv0, const helios::vec2 &amp;uv1, const helios::vec2 &amp;uv2, CoordinateSystem coordFlag ) </li>
<li>
Visualizer::addTriangle( const helios::vec3 &amp;vertex0, const helios::vec3 &amp;vertex1, const helios::vec3 &amp;vertex2, const char* texture_file, const helios::vec2 &amp;uv0, const helios::vec2 &amp;uv1, const helios::vec2 &amp;uv2, const helios::RGBAcolor &amp;color, CoordinateSystem coordFlag ) </li>
</ul>
</td></tr>
<tr>
<td>Disk </td><td>Ellipsoidal disk. </td><td><ul>
<li>
Visualizer::addDiskByCenter( const helios::vec3 &amp;center, const helios::vec2 &amp;size, const helios::SphericalCoord &amp;rotation, uint Ndivisions, const helios::RGBcolor &amp;color, CoordinateSystem coordFlag ) </li>
<li>
Visualizer::addDiskByCenter( const helios::vec3 &amp;center, const helios::vec2 &amp;size, const helios::SphericalCoord &amp;rotation, uint Ndivisions, const helios::RGBAcolor &amp;color, CoordinateSystem coordFlag ) </li>
<li>
Visualizer::addDiskByCenter( const helios::vec3 &amp;center, const helios::vec2 &amp;size, const helios::SphericalCoord &amp;rotation, uint Ndivisions, const char* texture_file, CoordinateSystem coordFlag ) </li>
</ul>
</td></tr>
<tr>
<td>Voxel </td><td>Parallelpiped or rectangular prism. </td><td><ul>
<li>
Visualizer::addVoxelByCenter( const helios::vec3 &amp;center, const helios::vec3 &amp;size, const helios::SphericalCoord &amp;rotation, const helios::RGBcolor &amp;color, CoordinateSystem coordFlag ) </li>
<li>
Visualizer::addVoxelByCenter( const helios::vec3 &amp;center, const helios::vec3 &amp;size, const helios::SphericalCoord &amp;rotation, const helios::RGBAcolor &amp;color, CoordinateSystem coordFlag ) </li>
</ul>
</td></tr>
<tr>
<td>Sphere </td><td>Tessellated sphere composed of triangles. </td><td><ul>
<li>
Visualizer::addSphereByCenter( float radius, const helios::vec3 center, uint Ndivisions, const helios::RGBcolor &amp;color, CoordinateSystem coordFlag ) </li>
<li>
Visualizer::addSphereByCenter( float radius, const helios::vec3 center, uint Ndivisions, const helios::RGBAcolor &amp;color, CoordinateSystem coordFlag ) </li>
</ul>
</td></tr>
<tr>
<td>Line </td><td>Linear segment between two points. </td><td><ul>
<li>
Visualizer::addLine( const helios::vec3 &amp;start, const helios::vec3 &amp;end, const helios::RGBcolor &amp;color, uint linewidth, CoordinateSystem coordFlag ) </li>
<li>
Visualizer::addLine( const helios::vec3 &amp;start, const helios::vec3 &amp;end, const helios::RGBAcolor &amp;color, uint linewidth, CoordinateSystem coordFlag ) </li>
</ul>
<p class="endtd"></p>
</td></tr>
<tr>
<td>Textbox </td><td>Box of text. </td><td><ul>
<li>
Visualizer::addTextboxByCenter( const char* textstring, const helios::vec3 &amp;center, const helios::SphericalCoord &amp;rotation, const helios::RGBcolor &amp;fontcolor, uint fontsize, const char* fontname, CoordinateSystem coordFlag ) </li>
</ul>
<br  />
 </td></tr>
</table>
<p>Each object can be added by calling one of the associated functions listed in the table above. The syntax is usually fairly similar to how gometry is added in the Helios context, except that you must specify a coordinate system (see <a class="el" href="_visualizer_doc.html#coord">Coordinate Systems</a>).</p>
<p>The code sample below gives an example of how to add a horizontal rectangle to the visualizer by providing the coordinates of its center:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2"> <pre><code> #include "Visualizer.h"

   int main( void ){
      Visualizer vis( 1200 );

      vec3 center = make_vec3(0,0,0);
      vec2 size = make_vec2(1,1);
      SphericalCoord rotation = make_SphericalCoord(0,0);
      vis.addRectangleByCenter(center,size,rotation,RGB::red,Visualizer::COORDINATES_CARTESIAN);
   }</code></pre> </div><h3><a class="anchor" id="ContextGeom"></a>
Automatically importing Context geometry</h3>
<p>The visualizer can automatically import some or all geometry from the Context. This is accomplished using the buildContextGeometry command. To add all primitives in the Context, the buildContextGeometry command would be issued, which is passed the Context. We can add a subset of the Context geometry through an additional argument which takes a vector of UUID's.</p>
<table class="doxtable">
<tr>
<th>Command </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="class_visualizer.html#a4834cddbcc01696bf0b1ef1b0a2cde0c">buildContextGeometry( Context* context )</a> </td><td>Add all primitives in the Context to the Visualizer.  </td></tr>
<tr>
<td><a class="el" href="class_visualizer.html#ada78ef51373f63718a95841f564a83ef">buildContextGeometry( Context* context, std::vector&lt;uint&gt; UUIDs )</a> </td><td>Add a subset of primitives in the Context to the Visualizer.  </td></tr>
</table>
<p>The example below shows how to add all Context geometry to the visualizer.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.1"> <pre><code> #include "Context.h"
   #include "Visualizer.h"

   using namespace helios;

   int main( void ){
      Context context;

      vec3 center = make_vec3(0,0,0);
      vec2 size = make_vec2(1,1);
      context.addPatch(center,size);

      Visualizer vis( 1200 );

      vis.buildContextGeometry(&amp;context);
   }</code></pre> </div><h2><a class="anchor" id="PlotWindow"></a>
Plotting Geometry</h2>
<p>To this point, we have not actually plotted anything in the Visualizer window. A final command is neede to display all of the geometry added to the Visualizer in the window we have opened. There are two functions for doing this, which are detailed below.</p>
<h3><a class="anchor" id="PlotInteractive"></a>
plotInteractive()</h3>
<p>The plotInteractive() function can be used to generate an interactive plot of the geometry in the Visualizer. This means that the code will pause to produce the plot/visualization until the window is closed by the user. The user can interact with the plot by issuing keystrokes to, e.g., zoom. An example is given below to generate an interactive plot.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.1"> <pre><code> #include "Context.h"
   #include "Visualizer.h"

   using namespace helios;

   int main( void ){
      Context context;

      vec3 center = make_vec3(0,0,0);
      vec2 size = make_vec2(1,1);
      context.addRectangleByCenter(center,size);

      Visualizer vis( 1200 );

      vis.buildContextGeometry(&amp;context);

      vis.plotInteractive();
   }</code></pre> </div><h3><a class="anchor" id="ViewControls"></a>
View Controls</h3>
<p>In an interactive plot, the view can be modified via various keystrokes, which are detailed in the table below.</p>
<table class="doxtable">
<tr>
<th>Key </th><th>Action  </th></tr>
<tr>
<td>up arrow </td><td>increase the viewing elevation angle  </td></tr>
<tr>
<td>down arrow </td><td>decrease the viewing elevation angle  </td></tr>
<tr>
<td>left arrow </td><td>rotate camera left (clockwise)  </td></tr>
<tr>
<td>right arrow </td><td>rotate camera right (counter-clockwise)  </td></tr>
<tr>
<td>spacebar+up arrow </td><td>move the camera position upward  </td></tr>
<tr>
<td>spacebar+down arrow </td><td>move the camera position downward  </td></tr>
<tr>
<td>+ </td><td>zoom in  </td></tr>
<tr>
<td>- </td><td>zoom out  </td></tr>
</table>
<h3><a class="anchor" id="PlotUpdate"></a>
plotUpdate()</h3>
<p>The plotUpdate() function simply updates the plot window based on current geometry, and continues on to the next lines of code. This can be useful if only a still image is to be written to file, as illustrated below.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.1"> <pre><code> #include "Context.h"
   #include "Visualizer.h"

   using namespace helios;

   int main( void ){
      Context context;

      vec3 center = make_vec3(0,0,0);
      vec2 size = make_vec2(1,1);
      context.addPatch(center,size);

      Visualizer vis( 1200 );

      vis.buildContextGeometry(&amp;context);

      vis.plotUpdate();
      vis.printWindow("rectangle.jpg");
      vis.closeWindow();
   }</code></pre> </div><h2><a class="anchor" id="ColorShade"></a>
Colors and Shading</h2>
<h3><a class="anchor" id="ColoringRGB"></a>
Coloring by r-g-b code</h3>
<p>The surfaces of primitives are most commonly colored by specifying an r-g-b/r-g-b-a color code when adding the geometry, and thus this is the default behavior.</p>
<h3><a class="anchor" id="ColoringTexture"></a>
Coloring by texture map</h3>
<p>Rectangles and disks have the cabability of coloring their surface according to a texture map. A texture map can be specified by providing the path to either a JPEG or PNG image file. The image will be mapped onto the surface of the primitive element.</p>
<div class="image">
<img src="Disk_textured.png" alt=""/>
</div>
<h3><a class="anchor" id="ColoringPseudo"></a>
Coloring by pseudocolor map</h3>
<p>Primitives can be colored by mapping associated data values to a color table. Given some range of data values, each value is normalized by this range and used to look up an associated color in the color table. The available predefined color tables are shown below. There is also the capability of defining custom color tables.</p>
<table class="doxtable">
<tr>
<th>Enumeration </th><th>Example  </th></tr>
<tr>
<td><a class="el" href="class_visualizer.html#a0af839aae42fd7086643608a6cbd194ba50215b5b3fb3a48fc83d7b4670da2026">Visualizer::COLORMAP_HOT</a> </td><td><div class="image">
<img src="colormap_hot.png" alt=""/>
</div>
td  </td></tr>
<tr>
<td><a class="el" href="class_visualizer.html#a0af839aae42fd7086643608a6cbd194ba65fd6eb9eefd4fbd10caa6ccceb689f5">Visualizer::COLORMAP_COOL</a> </td><td><div class="image">
<img src="colormap_cool.png" alt=""/>
</div>
td  </td></tr>
<tr>
<td><a class="el" href="class_visualizer.html#a0af839aae42fd7086643608a6cbd194baae019baa3e114715bf2a8feab826608d">Visualizer::COLORMAP_RAINBOW</a> </td><td><div class="image">
<img src="colormap_rainbow.png" alt=""/>
</div>
td  </td></tr>
<tr>
<td><a class="el" href="class_visualizer.html#a0af839aae42fd7086643608a6cbd194baae3d180822a9415592cd938ef445e128">Visualizer::COLORMAP_LAVA</a> </td><td><div class="image">
<img src="colormap_lava.png" alt=""/>
</div>
td  </td></tr>
<tr>
<td><a class="el" href="class_visualizer.html#a0af839aae42fd7086643608a6cbd194ba9a15b906eca8c544a6b83f885877fbe7">Visualizer::COLORMAP_PARULA</a> </td><td><div class="image">
<img src="colormap_parula.png" alt=""/>
</div>
td  </td></tr>
<tr>
<td><a class="el" href="class_visualizer.html#a0af839aae42fd7086643608a6cbd194ba9902d02656030da0e50afae4ac10ab58">Visualizer::COLORMAP_GRAY</a> </td><td><div class="image">
<img src="colormap_gray.png" alt=""/>
</div>
td  </td></tr>
<tr>
<td><a class="el" href="class_visualizer.html#a0af839aae42fd7086643608a6cbd194ba915aba9d8ae7c0796d8ed705671003a7">Visualizer::COLORMAP_CUSTOM</a> </td><td>N/A  </td></tr>
</table>
<p>The colormap to be used is set using the following command setColormap( Ctable colormap_name ), where &lsquo;colormap_name&rsquo; is one of the enumerations in the table above. For example, to set the &lsquo;hot&rsquo; colormap one would use:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.1"> <pre><code> vis.setColormap( Visualizer::COLORMAP_HOT );</code></pre> </div><p>To set a custom color table, the same command is used with the <a class="el" href="class_visualizer.html#a0af839aae42fd7086643608a6cbd194ba915aba9d8ae7c0796d8ed705671003a7">Visualizer::COLORMAP_CUSTOM</a> argument, plus additional arguments that define the custom color table. These arguments are 1) a vector of r-g-b colors defining various colors in the color table, and 2) a vector of values between 0 and 1 defining the relative positions of the colors in the table. The first position value must always be 0, and the last value must be 1. The visualizer interpolates between colors to populate the full color table. The table below shows how the &lsquo;hot&rsquo; color table is defined:</p>
<table class="doxtable">
<tr>
<th>RGBcolor </th><th>relative position  </th></tr>
<tr>
<td>(0, 0, 0) <div style="width:50px;height:30px;background-color:rgb(0,0,0);"></div> </td><td>0  </td></tr>
<tr>
<td>(0.5, 0, 0.5) <div style="width:50px;height:30px;background-color:rgb(127,0,127);"></div> </td><td>0.25  </td></tr>
<tr>
<td>(1, 0, 0) <div style="width:50px;height:30px;background-color:rgb(255,0,0);"></div> </td><td>0.5  </td></tr>
<tr>
<td>(1, 0.5, 0) <div style="width:50px;height:30px;background-color:rgb(255,127,0);"></div> </td><td>0.75  </td></tr>
<tr>
<td>(1, 1, 0) <div style="width:50px;height:30px;background-color:rgb(255,255,0);"></div> </td><td>1  </td></tr>
</table>
<p>Example code on how to implement the color table creation is given below:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.1"> <pre><code> Visualizer vis(1000);

   std::vector&lt;RGBcolor&gt; ctable_colors;
   ctable_colors.push_back( make_RGBcolor( 0.f, 0.f, 0.f ) );
   ctable_colors.push_back( make_RGBcolor( 0.5f, 0.f, 0.5f ) );
   ctable_colors.push_back( make_RGBcolor( 1.f, 0.f, 0.f ) );
   ctable_colors.push_back( make_RGBcolor( 1.f, 0.5f, 0.f ) );
   ctable_colors.push_back( make_RGBcolor( 1.f, 1.f, 0.f ) );

   std::vector&lt;float&gt; ctable_positions;
   ctable_positions.push_back( 0.f );
   ctable_positions.push_back( 0.25f );
   ctable_positions.push_back( 0.5f );
   ctable_positions.push_back( 0.75f );
   ctable_positions.push_back( 1.f );

   vis.setColormap( Visualizer::COLORMAP_CUSTOM, ctable_colors, ctable_positions );</code></pre> </div><h3><a class="anchor" id="Cbar"></a>
Colorbar</h3>
<p>The colorbar is the legend showing how values are mapped to the color table. The table below gives functions for customizing colorbar behavior, including for example its position, size, and visibility.</p>
<table class="doxtable">
<tr>
<th>Function </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="class_visualizer.html#a050807f8462ca95bde2fd737b26830c4">enableColorbar(void)</a> </td><td>Make the colorbar visible.  </td></tr>
<tr>
<td><a class="el" href="class_visualizer.html#a3580188fe9f0daf71e1c434fe7f14103">disableColorbar(void)</a> </td><td>Make the colorbar invisible.  </td></tr>
<tr>
<td><a class="el" href="class_visualizer.html#ad0a19f3097299a4407919d6fd9c5fefe">setColorbarPosition( vec3 position )</a> </td><td>Set the position of the colorbar. Note that position.z gives the depth of the colorbar.  </td></tr>
<tr>
<td><a class="el" href="class_visualizer.html#a7efb1e8bc6de19f885781b564573066f">setColorbarSize( vec2 size )</a>  </td><td>Set the size of the colorbar.  </td></tr>
<tr>
<td><a class="el" href="class_visualizer.html#ac41ea2148985f9797ca84a3affa35da9">setColorbarRange( float cmin, float cmax )</a>  </td><td>Set the range of data values for the colorbar/colormap.  </td></tr>
<tr>
<td>setColorbarTicks( std::vector&lt;float&gt; ticks )  </td><td>Set locations of data tick along colorbar.  </td></tr>
<tr>
<td><a class="el" href="class_visualizer.html#ae30cb19cb7d003ebbc0851c51c45d8a8">setColorbarTitle( const char* title )</a>  </td><td>Set the title text displayed above the colorbar.  </td></tr>
<tr>
<td><a class="el" href="class_visualizer.html#a452fa37af4c7294b8b631ee83c6fe46c">setColorbarFontColor( RGBcolor color )</a>  </td><td>Set the color of text in the colorbar.  </td></tr>
<tr>
<td><a class="el" href="class_visualizer.html#a40280c3f96152de174a4d9b26cc58c9d">setColorbarFontSize( uint font_size )</a>  </td><td>Set the size of the colorbar text in points.  </td></tr>
</table>
<div class="image">
<img src="vineyard_PAR_cmap.png" alt=""/>
</div>
<h3><a class="anchor" id="Shading"></a>
Shading</h3>
<p>To allow for more realistic visualizations, the Phong shading model can be enabled. The Phong shading model can be enabled with or without shadows. The shading options and their enumeration for specifying them are detailed in the table below. The appropriate enumeration is passed to the <a class="el" href="class_visualizer.html#afc496b8bd99bbb786d553c4b3e8dfded">Visualizer::setLightingModel</a> command to enable the specified shading model.</p>
<table class="doxtable">
<tr>
<th>Shading Model </th><th>Enumeration </th><th>Example  </th></tr>
<tr>
<td>No shading is applied. Objects are colored only according to the r-g-b(-a) color code or texture map. </td><td><a class="el" href="class_visualizer.html#a580a78fe3e25c423e2d13aebc1b54573ac864e3d3a92a93d2d070faee3a6b4789">Visualizer::LIGHTING_NONE</a> </td><td></td></tr>
<tr>
<td>Phong shading model </td><td><a class="el" href="class_visualizer.html#a580a78fe3e25c423e2d13aebc1b54573adce805e52c5b47950ecc3cfdddd2160c">Visualizer::LIGHTING_PHONG</a> </td><td></td></tr>
<tr>
<td>Phong shading model with shadows. </td><td><a class="el" href="class_visualizer.html#a580a78fe3e25c423e2d13aebc1b54573afe63a1dd4fcd9bbf57ad0dc2c168c864">Visualizer::LIGHTING_PHONG_SHADOWED</a> </td><td></td></tr>
</table>
<p>If the Phong shading model is used, the position of the light source should be specified. This is accomplished through the Visualizer::setLightDirection( vec3 direction ) command, which takes a unit vector pointing toward the light source. The example below shows how to enable the Phong lighting model with shadows, with the light position set according to the position of the sun.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2"> <pre><code> #include "Visualizer.h"

   int main( void ){
      Visualizer vis( 1200 );

      vec3 center = make_vec3(0,0,0);
      vec2 size = make_vec2(1,1);
      SphericalCoord rotation = make_SphericalCoord(0,0);
      vis.addRectangleByCenter(center,size,rotation,RGB::red,Visualizer::COORDINATES_CARTESIAN,0);

      vec3 light_direction = make_vec3(1,1,1);

      vis.setLightingModel( Visualizer::LIGHTING_PHONG_SHADOWED );
      vis.setLightDirection( light_direction );
   }</code></pre> </div><h2><a class="anchor" id="Options"></a>
View Options</h2>
<p>The default camera position is at an elevation angle of 20 degrees and to the North, with the camera looking toward the origin. The distance of the camera from the origin is automatically adjusted to fit all primitives in view.</p>
<p>There are multiple ways of specifying custom camera views. One method involves specifying the (x,y,z) position of the camera, and the (x,y,z) position that the camera is looking at. This is accomplished using the command setCameraPosition( vec3 cameraPosition, vec3 lookAt ).</p>
<p>The other method involves specifying the spherical coordinates of the camera with respect to the (x,y,z) position the camera is looking at. This is accomplished using the setCameraPosition( SphericalCoord cameraAngle, vec3 lookAt ).</p>
<div class="image">
<img src="CameraSchematic.jpeg" alt=""/>
</div>
<h1><a class="anchor" id="VisAcklowledgements"></a>
Acknowledgements</h1>
<p>This plug-in uses all or parts of the following open-sourced software libraries:</p>
<p>The OpenGL Extension Wrangler Library: Copyright (C) 2008-2016, Nigel Stewart &lt;nigels[]users sourceforge net&gt; Copyright (C) 2002-2008, Milan Ikits &lt;milan ikits[]ieee org&gt; Copyright (C) 2002-2008, Marcelo E. Magallon &lt;mmagallo[]debian org&gt; Copyright (C) 2002, Lev Povalahev All rights reserved.</p>
<p>The FreeType Project: Portions of this software are copyright © 2019 The FreeType Project (www.freetype.org). All rights reserved.</p>
<p>GLFW: Copyright © 2002-2006 Marcus Geelnard Copyright © 2006-2019 Camilla Löwy</p>
<p>OpenGL Mathematics (GLM): Copyright (c) 2005 - 2014 G-Truc Creation</p>
<p>libjpeg: This software is copyright (C) 1991-2016, Thomas G. Lane, Guido Vollbeding. All Rights Reserved except as specified below.</p>
<p>libpng: Copyright (c) 1995-2019 The PNG Reference Library Authors. Copyright (c) 2018-2019 Cosmin Truta. Copyright (c) 2000-2002, 2004, 2006-2018 Glenn Randers-Pehrson. Copyright (c) 1996-1997 Andreas Dilger. Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
