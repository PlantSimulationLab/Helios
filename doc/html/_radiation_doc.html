<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>.: Radiation Model Plugin Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Helios_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname">.<span id="projectnumber">&#160;v1.2.64</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="_plug_ins.html">Plug-ins</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Radiation Model Plugin Documentation </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#RadDepends">Dependencies</a></li>
<li class="level1"><a href="#RadIssues">Known Issues</a></li>
<li class="level1"><a href="#RadConstructor">RadiationModel Class Constructor</a></li>
<li class="level1"><a href="#RadVarsAndProps">Input/Output Primitive Data</a><ul><li class="level2"><a href="#RadInputData">Input Primitive Data</a></li>
<li class="level2"><a href="#RadOutputData">Output Primitive Data</a></li>
</ul>
</li>
<li class="level1"><a href="#RadUse">Using the Radiation Model Plug-In</a><ul><li class="level2"><a href="#RadConst">Model Class Constructor</a></li>
<li class="level2"><a href="#RadTwoSided">Area Basis for Calculating Fluxes</a></li>
<li class="level2"><a href="#RadBands">Defining Wavelength Bands</a></li>
<li class="level2"><a href="#RadProps">Radiative Properties</a></li>
<li class="level2"><a href="#RadEmission">Radiative Emission</a></li>
<li class="level2"><a href="#RadSources">External Radiation Sources</a><ul><li class="level3"><a href="#ColSource">Adding Collimated Sources</a></li>
<li class="level3"><a href="#SunSphereSource">Adding Spherical Sun Source</a></li>
<li class="level3"><a href="#PointSource">Adding Spherical Sources</a></li>
<li class="level3"><a href="#AmbSource">Adding Diffuse/Ambient Sources</a></li>
</ul>
</li>
<li class="level2"><a href="#RadScatter">Scattering Iterations</a></li>
<li class="level2"><a href="#RadPeriodic">Periodic Boundary Conditions</a></li>
<li class="level2"><a href="#RadRun">Running Simulations</a></li>
<li class="level2"><a href="#RadSolar">Integrating with the SolarPosition Plug-in</a></li>
<li class="level2"><a href="#RadVis">Visualizing Model Outputs</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><div class="image">
<img src="GreenhouseImage.png" alt=""/>
</div>
<p><br  />
<br  />
 </p>
<table class="doxtable">
<tr>
<th>Dependencies </th><td>NVIDIA CUDA 9.0+  </td></tr>
<tr>
<th>CMakeLists.txt </th><td>set( PLUGINS "radiation" )  </td></tr>
<tr>
<th>Header File </th><td>#include "RadiationModel.h"  </td></tr>
<tr>
<th>Class </th><td><a class="el" href="class_radiation_model.html">RadiationModel</a>  </td></tr>
</table>
<h1><a class="anchor" id="RadDepends"></a>
Dependencies</h1>
<table class="doxtable">
<tr>
<th>Package </th><td><div class="image">
<img src="apple-logo.jpg" alt=""/>
</div>
td </td><td><div class="image">
<img src="unix-logo.png" alt=""/>
</div>
td </td><td><div class="image">
<img src="windows-logo.jpg" alt=""/>
</div>
td  </td></tr>
<tr>
<td>NVIDIA CUDA 9.0+ </td><td>Mac OSX:<br  />
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2"><code>$ brew install Caskroom/cask/cuda</code></div> </td><td>Use <a href="https://developer.nvidia.com/cuda-downloads">CUDA installer</a> </td><td>Use <a href="https://developer.nvidia.com/cuda-downloads">CUDA installer</a>  </td></tr>
</table>
<p>For help choosing the correct CUDA toolkit version and accompanying OptiX version for your system, consult this page: <a class="el" href="_choosing_c_u_d_a.html">Choosing the right CUDA and OptiX version</a></p>
<p>Useful OS-specific information for installing CUDA can be found here: <a class="el" href="_dependent_software.html">Dependent Software</a></p>
<p>If you are using a PC, it is likely you will need to increase the GPU timeout in the registry, otherwise calculations lasting longer than 2 secs. will timeout and kill your program. A guide on how to increase the timeout can be found here: <a class="el" href="_p_c_g_p_u_timeout.html">Increasing graphics driver timeout</a></p>
<h1><a class="anchor" id="RadIssues"></a>
Known Issues</h1>
<ul>
<li>If the <a class="el" href="class_radiation_model.html" title="Radiation transport model plugin.">RadiationModel</a> class is re-declared many (e.g., hundreds) of times within a loop, this causes an internal OpTiX error. The error will look something like this:</li>
</ul>
<p><code>OptiX Error: Unknown error (Details: Function "RTresult _rtContextLaunch3D(RTcontext, unsigned int, RTsize, RTsize, RTsize)" caught exception: Assertion failed: "!m_building : dirty list modified while build in progress", file: &lt;internal&gt;, line: 94) (/home/user/Helios/plugins/radiation/src/RadiationModel.cpp:2920)</code></p>
<p>It is recommended to declare the <a class="el" href="class_radiation_model.html" title="Radiation transport model plugin.">RadiationModel</a> class outside of a loop, then call updateGeometry() on every loop iteration if geometry has changed.</p>
<h1><a class="anchor" id="Introduction"></a>
Introduction</h1>
<p>This model simulates the transport of radiative energy for arbitrary wavelength bands using a GPU-accelerated ray-tracing model. The model details are described in <a href="http://dx.doi.org/10.1016/j.ecolmodel.2017.11.022">Bailey (2018)</a>. Briefly, the model uses a reverse ray-tracing approach to simulate emission from primitive elements, collimated radiation sources, and point radiation sources.</p>
<h1><a class="anchor" id="RadConstructor"></a>
RadiationModel Class Constructor</h1>
<table class="doxtable">
<tr>
<th>Constructors  </th></tr>
<tr>
<td><a class="el" href="class_radiation_model.html">RadiationModel( helios::Context* context )</a>  </td></tr>
</table>
<p>The <a class="el" href="class_radiation_model.html">RadiationModel</a> class is initialized by simply passing a pointer to the Helios context as an argument to the constructor. This gives the class the ability to automatically query model geometry and read/write from/to model data.</p>
<h1><a class="anchor" id="RadVarsAndProps"></a>
Input/Output Primitive Data</h1>
<h2><a class="anchor" id="RadInputData"></a>
Input Primitive Data</h2>
<table class="doxtable">
<tr>
<th>Primitive Data </th><th>Units </th><th>Data Type </th><th>Description </th><th>Available Plug-ins </th><th>Default Value  </th></tr>
<tr>
<td>temperature </td><td>Kelvin </td><td> <font face="courier" color="green">float</font> </td><td>Primitive surface temperature. <b>NOTE: Only needed if performing emission calculations.</b> </td><td>Can be computed by <a class="el" href="class_energy_balance_model.html">EnergyBalanceModel</a> plug-in </td><td>300 K  </td></tr>
<tr>
<td>reflectivity_* </td><td>unitless </td><td> <font face="courier" color="green">float</font> </td><td>Primitive reflectivity for band * (i.e., reflectivity for band 'PAR' would be 'reflectivity_PAR'). </td><td>N/A </td><td>0  </td></tr>
<tr>
<td>transmissivity_* </td><td>unitless </td><td> <font face="courier" color="green">float</font> </td><td>Primitive transmissivity for band * (i.e., transmissivity for band 'PAR' would be 'transmissivity_PAR'). </td><td>N/A </td><td>0  </td></tr>
<tr>
<td>emissivity_* </td><td>unitless </td><td> <font face="courier" color="green">float</font> </td><td>Primitive emissivity for band * (i.e., emissivity for band 'PAR' would be 'emissivity_PAR'). <b>NOTE: Only needed if performing emission calculations.</b> </td><td>N/A </td><td>1.0  </td></tr>
<tr>
<td>twosided_flag </td><td>N/A </td><td> <font face="courier" color="green">uint</font> </td><td>Flag to determine whether a primitive should be treated as two-sided (=1) or single-sided (=0). See Sect. <a class="el" href="_radiation_doc.html#RadTwoSided">Area Basis for Calculating Fluxes</a> below for more information. </td><td>N/A </td><td>1  </td></tr>
</table>
<p><br  />
</p>
<h2><a class="anchor" id="RadOutputData"></a>
Output Primitive Data</h2>
<table class="doxtable">
<tr>
<th>Primitive Data </th><th>Units </th><th>Data Type </th><th>Description  </th></tr>
<tr>
<td>radiation_flux_* </td><td>W/m<sup>2</sup> </td><td> <font face="courier" color="green">float</font> </td><td>Absorbed radiation flux for band * (i.e., the flux for band 'PAR' would be 'radiation_flux_PAR').  </td></tr>
</table>
<h1><a class="anchor" id="RadUse"></a>
Using the Radiation Model Plug-In</h1>
<h2><a class="anchor" id="RadConst"></a>
Model Class Constructor</h2>
<p>The radiation model class contains functions and data associated with the model. To begin, declare an instance of the <a class="el" href="class_radiation_model.html" title="Radiation transport model plugin.">RadiationModel</a> class. The class constructor takes one argument - a pointer to the Helios context. It uses this pointer to access model geometry and data in the context.</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>RadiationModel radiationmodel(&amp;context); //declare the model class</code></pre></div><h2><a class="anchor" id="RadTwoSided"></a>
Area Basis for Calculating Fluxes</h2>
<p>The ultimate outputs of the radiation model are absorbed radiative fluxes, which is the rate of radiative energy transfer per unit surface area. <b>All flux calculations are on a per unit one-sided surface area basis.</b> For planar primitive elements (patches and triangles), this means that the flux will be the rate of radiative energy absorption on both sides of the primitive, divided by the one-sided surface area of the primitive (i.e., that returned by the helios::Primitive::getArea() function).</p>
<p>By default, a planar primitive will emit and absorb radiation from/to both faces. For primitives that only emit and absorb from/to one face (e.g., ground primitives), this default behavior should be modified. Single-sided emission can be achieved by setting primitive data for the particular primitive with a name of "twosided_flag" to a value of 0 (where '0' is defined as an unsigned integer):</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>context.setPrimitiveData( UUID, "twosided_flag", uint(1) );</code></pre></div><p>Note that in this case radiation will be emitted from the side with its face in the direction of the primitive normal vector. If primitive data called "twosided_flag" is set to 1, this will produce the default behavior of emission from both faces.</p>
<p>A primitive with "twosided_flag" set to 0 will not absorb any radiation from the back face of the primitive, but it will attenuate radiation. So if a ray hits the back face, the ray trajectory will be terminated, but no energy will be deposited.</p>
<p>Example: If we had a single patch and a diffuse radiation source with a flux of 1.0, with default behavior the absorbed flux on the patch would be 2.0 because it would absorb energy from both faces, but the end flux would be expressed on a single-sided area basis. If "twosided_flag" was set to 0 for that patch (non-default behavior), then the absorbed flux on the patch would be 1.0.</p>
<h2><a class="anchor" id="RadBands"></a>
Defining Wavelength Bands</h2>
<p>Arbitrary radiation wavelength bands can be added to the model, over which radiation calculations are performed. Each wavelength band is given a label that is defined by the user (e.g., 'PAR'). Each band has the possibility of having components of direct, diffuse, and emission, each of which are specified when adding the band. The <a class="el" href="class_radiation_model.html#a19ca27c9617fca821fa46a983bb31a1e">addRadiationBand()</a> command is used to add each band, which takes one argument, which is a user-defined label for the band (e.g, 'PAR').</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>radiationmodel.addRadiationBand( "PAR" ); //Add band 'PAR'</code></pre></div><h2><a class="anchor" id="RadProps"></a>
Radiative Properties</h2>
<p>Radiative properties (reflectivity, transmissivity, emissivity) are defined for each band each primitive. Their values are set via primitive data (see also Input Primitive Data table above, and <a class="el" href="classhelios_1_1_context.html#ac7677094a3bbcb62506ce461d982af1d">setPrimitiveData()</a>): <br  />
</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>  <code></code>// Initialize the Context
  Context context;

  <code></code>// Add 'Patch' primitive
  vec3 center = make_vec3(0,0,1);
  vec2 size = make_vec2(1,1);
  uint UUID = context.addPatch( center, size );

  float rho = 0.1; //reflectivity value
  context.setPrimitiveData( UUID, "reflectivity_PAR", rho);

  float tau = 0.1; //transmissivity value
  context.setPrimitiveData( UUID, "transmissivity_PAR", tau);</code></pre></div><p>Note that absorptivity is not directly set, rather it is calculated as <img class="formulaInl" alt="$1-\rho-\tau$" src="form_139.png" width="60" height="14"/>. If <img class="formulaInl" alt="$1-\rho-\tau$" src="form_139.png" width="60" height="14"/> is calculated to be negative, an error is thrown.</p>
<p>If radiative properties are changed from default vaules, the number of scattering iterations needs to be increased from the default value of 0 (see <a class="el" href="_radiation_doc.html#RadScatter">Scattering Iterations</a>). If radiative properties are changed, but the number of scattering iterations is set to the default value of 0, the modified radiative property values are overridden and set back to their default values (black surface).</p>
<h2><a class="anchor" id="RadEmission"></a>
Radiative Emission</h2>
<p>By default, radiation emission calculations are performed for each band. Each primitive emits radiation with a flux of <img class="formulaInl" alt="$\varepsilon \sigma T^4$" src="form_140.png" width="35" height="14"/>, where <img class="formulaInl" alt="$\varepsilon$" src="form_141.png" width="8" height="8"/> is the primitive's emissivity, <img class="formulaInl" alt="$\sigma=5.67\times 10^{-8}\,W/m^2/K^4$" src="form_142.png" width="177" height="18"/> is the Steffan Boltzmann constant, and <img class="formulaInl" alt="$T$" src="form_143.png" width="12" height="11"/> is the primitive's surface temperature in Kelvin. By default, it is assumed that <img class="formulaInl" alt="$\varepsilon=1$" src="form_144.png" width="35" height="11"/>, unless primitive data exists that defines the emissivity. By default, it is also assumed that <img class="formulaInl" alt="$T=300K$" src="form_145.png" width="69" height="12"/>, unless the primitive data 'temperature' exists in the Context whose value defines the temperature.</p>
<p>Emission can be disabled for the band by caling the <a class="el" href="class_radiation_model.html#a45774805001673a42a94e5cd1e45be4c">disableEmission()</a> function. For example, for the photosynthetically active (PAR) band, terrestrial objects do not emit radiation (i.e., <img class="formulaInl" alt="$\varepsilon\approx 0$" src="form_146.png" width="36" height="11"/>) and thus rather than setting a zero emissivity for this band for all primitives, it is desirable to simply disable radiation emission for this band:</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> radiationmodel.disableEmission( "PAR" ); //Disable emission for the 'PAR' band</code></pre></div><p>The surface emissivity can be changed similarly as was shown above for the reflectivity and transmissivity:</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> float eps = 0.9; //emissivity value
 context.setPrimitiveData( UUID, "emissivity_LW", eps);</code></pre></div><p>Note that you can also set the reflectivity and transmissivity for a band with emission. It is required that <img class="formulaInl" alt="$\rho+\tau+\varepsilon=0$" src="form_147.png" width="89" height="14"/> in order to satisfy conservation of energy. If only the emissivity is set and reflectivity and transmissivity are left at their default values of 0, it is automatically assumed that <img class="formulaInl" alt="$\rho=1-\varepsilon$" src="form_148.png" width="62" height="14"/> and <img class="formulaInl" alt="$\tau=0$" src="form_149.png" width="38" height="11"/>.</p>
<h2><a class="anchor" id="RadSources"></a>
External Radiation Sources</h2>
<p>There are three types of external sources of radiation that can be simulated: 1) a collimated radiation source (beams of radiation are approximately parallel), 2) ambient diffuse radiation, and 3) a point source.</p>
<h3><a class="anchor" id="ColSource"></a>
Adding Collimated Sources</h3>
<p>A collimated radiation source is defined by a unit vector pointing in the direction of the collimated source, and by the radiation flux emitted by the source normal to the direction of radiation propagation.</p>
<p>The radiation model also requires the specification of the number of rays per primitive to be used in the simulation (default is 100 rays per primitive). The more rays used in the simulation the more accurate the answer will be, but this will result in a longer simulation time.</p>
<p>Below is an example of adding a collimated source oriented in the direction of the sun, with a flux of 800 and using 200 rays per primitive:</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> vec3 sun_dir(0,0,1);
 uint SunSource = radiationmodel.addCollimatedRadiationSource( sun_dir ); //add the source, whose identifier is stored in the 'SunSource' variable
 radiationmodel.setSourceFlux(SunSource,"PAR",800); //set the flux of the source
 radiationmodel.setDirectRayCount("PAR",200); //set the ray count for sources </code></pre></div><h3><a class="anchor" id="SunSphereSource"></a>
Adding Spherical Sun Source</h3>
<p>To represent penumbral effects, a spherical radiation source can be used to represent the sun. The sun is represented by a sphere, which has the same diameter and distance from the earth as the sun.</p>
<p>The spherical sun source is defined in a similar manner as the collimated radiation source, but using the <a class="el" href="class_radiation_model.html#a301f41951818cd511d2950f57558cdac">addSunSphereRadiationSource()</a> function. Below is an example of adding a spherical sun source, with a flux of 800 and using 200 rays per primitive:</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> vec3 sun_dir(0,0,1);
 uint SunSource = radiationmodel.addSunSphereRadiationSource( sun_dir ); //add the source, whose identifier is stored in the 'SunSource' variable
 radiationmodel.setSourceFlux(SunSource,"PAR",800); //set the flux of the source
 radiationmodel.setDirectRayCount("PAR",200); //set the ray count for sources </code></pre></div><h3><a class="anchor" id="PointSource"></a>
Adding Spherical Sources</h3>
<p>More general spherical radiation sources can be added to represent sources such as a lamp. Spherical sources are added using the <a class="el" href="class_radiation_model.html#adc26a37949e004de563d80fe44c8dac0">addSphereRadiationSource()</a> function, which takes an (x,y,z) location of the spherical source and its radius as arguments. This function returns a uint which specifies the identifier for the point source, similar to a collimated and sun sphere source. The flux emanating from the source can also be set using the source identifier.</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> vec3 sun_dir(0,0,1);
 float sphere_radius = 1.0;
 uint SphereSource = radiationmodel.addSphereRadiationSource( sun_dir, sphere_radius ); //add the source, whose identifier is stored in the 'SphereSource' variable
 radiationmodel.setSourceFlux(SphereSource,"PAR",800); //set the flux of the source
 radiationmodel.setDirectRayCount("PAR",200); //set the ray count for source</code></pre></div><h3><a class="anchor" id="AmbSource"></a>
Adding Diffuse/Ambient Sources</h3>
<p>An ambient radiation source is added simply by setting its flux value:</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>radiationmodel.setDiffuseRadiationFlux("PAR",200.f); //set the flux</code></pre></div><p>The default is to use 100 diffuse rays per primitive, which can be set to a user-defined value using the following command:</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>radiationmodel.setDiffuseRayCount("PAR",200); //set the number of rays</code></pre></div><p> <br  />
</p>
<p>By default, the diffuse radiation distribution is isotropic. An anisotropic diffuse radiation distribution can be utilized using the function <a class="el" href="class_radiation_model.html#a2e2ddc281a577c48b71010c49c7cf536">setDiffuseRadiationExtinctionCoeff()</a>. This function applies an anisotropic diffuse distribution in which intensity declines exponentially away from the peak direction (usually the solar direction). The relative diffuse intensity is given by <a href="https://doi.org/10.1016/0038-092X(88)90072-2">(Harrison and Coombes, 1988)</a></p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ f_d(\theta,\phi) = f_0\Psi^{-K},\]" src="form_150.png" width="119" height="20"/>
</p>
<p>where</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \Psi = acos\left( cos\,\theta\,cos\,\theta_s + sin\,\theta\,sin\,\theta_s\,cos\,(\phi-\phi_s) \right), \]" src="form_151.png" width="320" height="17"/>
</p>
<p>and <img class="formulaInl" alt="$\theta_s$" src="form_6.png" width="12" height="15"/> and <img class="formulaInl" alt="$\phi_s$" src="form_152.png" width="14" height="15"/> are the zenith and azimuth angles of the peak direction. If <img class="formulaInl" alt="$\Psi&lt;1^\circ$" src="form_153.png" width="45" height="14"/>, <img class="formulaInl" alt="$\Psi$" src="form_154.png" width="11" height="12"/> is clamped to a value of 1 degree. The <img class="formulaInl" alt="$f_0$" src="form_155.png" width="14" height="15"/> is a normalization factor that is computed such that the integral of <img class="formulaInl" alt="$f_d$" src="form_156.png" width="14" height="15"/> for a one-sided horizontal element is equal to 1, i.e.,</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{1}{\pi}\int\limits_0^{2\pi}\int\limits_0^{\pi/2}\,f_d\,\mathrm{cos}\,\theta\,\mathrm{sin}\,\theta\,d\theta d\phi = 1. \]" src="form_157.png" width="200" height="57"/>
</p>
<p>The figure below shows the diffuse distribution for different values of <img class="formulaInl" alt="$K$" src="form_158.png" width="14" height="12"/> for a solar zenith of 45 degrees. Note that a value of <img class="formulaInl" alt="$K=0$" src="form_159.png" width="41" height="12"/> yields an anisotropic distribution, and as <img class="formulaInl" alt="$K$" src="form_158.png" width="14" height="12"/> gets large the distribution becomes increasingly anisotropic.</p>
<div class="image">
<img src="diffuse_distribution.png" alt=""/>
</div>
<p>An example implementation is given below.</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> vec3 sun_dir(0,0,1); //sun direction
 float K = 0.1; //diffuse radiation distribution extinction coefficient
 radiation.setDiffuseRadiationExtinctionCoeff("PAR", K, sun_dir);</code></pre></div><h2><a class="anchor" id="RadScatter"></a>
Scattering Iterations</h2>
<p>If the reflectivity or tranmissivity are set to values greater than 0, scattering calculations are required to simulate the reflected or transmitted radiation transport. These scattering calculations are performed iteratively until there is no energy left to be scattered. The number of scattering iterations is defined using:</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>radiationmodel.setScatteringDepth( "PAR", 5); //set the number of scattering iterations</code></pre></div><p> <br  />
</p>
<h2><a class="anchor" id="RadPeriodic"></a>
Periodic Boundary Conditions</h2>
<p>By default, the radiation model does not enforce any boundary conditions on the edge of the domain (other than being a diffuse ambient radiation source if one has been added). Optionally, users can specify to enforce a periodic boundary in the horizontal in either the x- or y-direction or both. This effectively means that the domain repeats indefintely, and that any radiation leaving the domain on one boundary will re-enter the domain on the opposite boundary. This is useful for eliminating domain edge effects.</p>
<div class="image">
<img src="PeriodicBC.png" alt=""/>
</div>
<p>A periodic boundary condition is specified using the <a class="el" href="class_radiation_model.html#a07986ba42a24c97635a315c7982040be">enforcePeriodicBoundary()</a> function. The argument to this function is the lateral boundary that should be considered periodic: one of "x" (periodic in x-direction), "y" (periodic in y-direction), or "xy" (periodic in both x- and y-directions).</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>radiationmodel.enforcePeriodicBoundary("xy"); //enforce periodic boundaries in horizontal</code></pre></div><p>Note that it is very important that no primitives extend laterally beyond the ground surface, otherwise the periodic boundary will lie beyond the lateral extent of the ground and there will potentially be ambient radiation that enters the domain from below. If there is a chance that primitives may laterally extend beyond the ground, it is recommended to use the Context::cropDomain() function to crop the domain in the horizontal to the size of the ground.</p>
<div style="padding:10px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> vec2 ground_size(10,10);  //lateral size of the ground
 vec3 ground_center(0,0,0);  //position of the ground center
 context.addPatch( ground_center, ground_size );  //ground patch

 context.cropDomainX( ground_center.x + make_vec2(-0.5*ground_size.x,0.5*ground_size.x) );
 context.cropDomainY( ground_center.y + make_vec2(-0.5*ground_size.y,0.5*ground_size.y) );</code></pre></div><h2><a class="anchor" id="RadRun"></a>
Running Simulations</h2>
<p>Before simulations are run, we must update the context geometry within the radiation model using the <a class="el" href="class_radiation_model.html#a0f55795694c31a0568e606c73f9d945a">updateGeometry()</a> command. The geometry update can be somewhat costly, so it should only be done whenever geometry changes.</p>
<p>Simulations for each band are run separately via the <a class="el" href="class_radiation_model.html#a7f43a8453667e3314aef36d6b5c416ed">runBand()</a> command:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> radiationmodel.updateGeometry(); //build the context geometry in the radiation model

 radiationmodel.runBand("PAR"); //run the model for the 'PAR' band</code></pre></div><p>The model will create several primitive data in the context with values set using simulation results (see Sect. "Output Primitive Data" above).</p>
<h2><a class="anchor" id="RadSolar"></a>
Integrating with the SolarPosition Plug-in</h2>
<p>A common task when using the radiation model is to integrate with the <a class="el" href="class_solar_position.html">SolarPosition</a> plug-in to set the position of a collimated radiation source (i.e., the sun), potentially at several different times of the day. In this case, one would initialize the <a class="el" href="class_solar_position.html">SolarPosition</a> and <a class="el" href="class_radiation_model.html" title="Radiation transport model plugin.">RadiationModel</a> classes and set up relevant inputs, then execute a for-loop over each time of the day. For each time iteration, the current time is set in the Context, the direction of the sun is calculated for that particular time, then the sun direction is passed to the radiation model. An example is illustrated in the code below.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>  #include "Context.h"
  #include "Visualizer.h"
  #include "SolarPosition.h"
  #include "RadiationModel.h"

  using namespace helios;

  int main( void ){

     <code></code>//---- inputs ----//
     int UTC = 7;             //hours from UTC
     float latitude = 35.2;   //latitude in degrees
     float longitude = 124.3; //longitude in degrees
     Date date(1,6,2018);     //current date (June 1 2018)

     float pressure = 101300; //atmospheric pressure (Pa)
     float temperature = 300; //air temperature (K)
     float humidity = 0.5;    //relative humidity (-)
     float turbidity = 0.05;  //atmospheric turbidity coeff (-)
     <code></code>//----------------//

     <code></code>// --- 1. Initialize the Context and some geometry --- //
     Context context; //Initialize Context

     <code></code>// add some geometry
     context.addTile( make_vec3(0,0,0), make_vec2(10,10), make_SphericalCoord(0,0), make_int2(500,500) );

     context.addSphere( 50, make_vec3(0,0,2), 1 );

     <code></code>// --- 2. Initialize the solar position model --- //

     SolarPosition solarposition( UTC, latitude, longitude, &amp;context ); //initialize the solar position model

     <code></code>// --- 3. Initialize the radiation model --- //

     RadiationModel radiationmodel( &amp;context ); //initialize the radiation model

     uint SunSource = radiationmodel.addCollimatedRadiationSource(); //add the source (sun), we'll set it's direction later

     radiationmodel.addRadiationBand("SW");
     radiationmodel.setDirectRayCount("SW",1000); //set the ray count for source
     radiationmodel.disableEmission("SW");

     radiationmodel.updateGeometry();

     <code></code>// --- 4. Loop over various hours of the day (7:00 thru 21:00) --- //

     context.setDate( date ); //set the date, which will not change

     for( int hour=7; hour&lt;22; hour++ ){

        <code></code>// --- 5. Set the current time and calculate the associated sun direction --- //

        context.setTime(0,hour); //set the current time for this iteration

        <code></code>//Set the correct sun position for the current date, time, latitude, etc.
        vec3 sdir = solarposition.getSunDirectionVector(); //get the solar direction from plug-in
        radiationmodel.setSourcePosition( SunSource, sdir ); //set the radiation source direction in radiation model

        <code></code>// --- 6. Calculate incoming solar fluxes for the current time --- //

        <code></code>//Calculate the clear-sky direct and diffuse solar flux for the current date, time, latitude, etc.
        float Rflux = solarposition.getSolarFlux( pressure, temperature, humidity, turbidity );
        float fdiff = solarposition.getDiffuseFraction( pressure, temperature, humidity, turbidity ); //fraction of Rflux that is diffuse
        radiationmodel.setSourceFlux( SunSource, "SW", Rflux*(1-fdiff) ); //set the direct flux: Rflux*(1-fdiff)
        radiationmodel.setDiffuseRadiationFlux( "SW", Rflux*fdiff ); //set the diffuse flux: Rflux*fdiff

        <code></code>// --- 7. Run the model --- //
        radiationmodel.runBand("SW");

        <code></code>// --- 8. Visualize the result --- //

        Visualizer vis(1000); //Initialize the visualizer

        vis.buildContextGeometry(&amp;context); //add all geometry in the Context to the visualizer
        vis.colorContextPrimitivesByData( "radiation_flux_SW" ); //tell the visualizer to color based on radiation flux (primitive data)

        vis.plotUpdate(); //plot the result

        vis.printWindow(); //print to JPEG image

        helios::wait(3); //wait for 3 seconds

        vis.closeWindow(); //close the window, then continue to next loop iteration

     }//end loop over time

     return 0;     

  }</code></pre></div><h2><a class="anchor" id="RadVis"></a>
Visualizing Model Outputs</h2>
<p>Visualization of radiation model outputs is typically achieved by coloring primitives based on the value of the primitive data "radiation_flux_*" for a particular band. However, we could visualize any input or output of the model or calculated value based on the model outputs.</p>
<p>A simple example of visualization of the absorbed flux for band "PAR" is given below, which assumes that a band exists named "PAR" and the model was run for that band.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> Visualizer vis(1000);

  vis.buildContextGeometry( &amp;context );
  vis.colorContextPrimitivesByData("radiation_flux_PAR");
  vis.enableColorbar();

  vis.plotInteractive();</code></pre></div><p>It could also be possible to visualize the net all-wave radiation flux by summing multiple band fluxes. The following example assumes that there are bands created in the model for shortwave radiation called "SW" and for longwave radiation called "LW", and that the model has been run for each of these bands.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code>  Visualizer vis(1000);

  vis.buildContextGeometry( &amp;context );

  std::vector&lt;uint&gt; allUUIDs = context.getAllUUIDs();
  for( size_t p=0; p&lt;allUUIDs.size(); p++ ){
      uint UUID = allUUIDs.at(p);
      float flux_SW, flux_LW;
      context.getPrimitiveData( UUID, "radiation_flux_SW", flux_SW );
      context.getPrimitiveData( UUID, "radiation_flux_LW", flux_LW );
      context.setPrimitiveData( UUID, "total_flux", flux_SW + flux_LW );
  }
       
  vis.colorContextPrimitivesByData( "total_flux" );
  vis.enableColorbar();

  vis.plotInteractive();</code></pre></div> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
