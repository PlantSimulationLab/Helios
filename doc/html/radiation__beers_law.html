<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>.: Helios Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-93BB4673PE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-93BB4673PE');
</script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-3F0Y5Z6543"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-3F0Y5Z6543');
</script>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Helios_logo_small.png"/></td>
  <td id="projectalign">
   <div id="projectname"><span id="projectnumber">&#160;v1.3.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part --><!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="_tutorials.html">Tutorials</a></li>  </ul>
</div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial 11: Light interception and fraction of sunlit/shaded leaf area for a homogeneous canopy </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >In this tutorial, we will consider radiation transfer in a homogeneous, horizontally infinite canopy. This canonical canopy case will allow for comparison against theoretical values computed from Beer's law. Our goal will be to simulate the fraction of photosynthetically active radiation (PAR) absorbed by the canopy and the fraction of sunlit/shaded leaf area, and compare the 3D simulated values against Beer's law. This tutorial will integrate the <a class="el" href="_canopy_generator_doc.html">Canopy Generator</a> plug-in to create the canopy geometry, and the <a class="el" href="_voxel_intersection_doc.html">Voxel Intersection</a> plug-in to slice leaves that lie on the canopy boundary.</p>
<h2><a class="anchor" id="tutorial11_theory"></a>
0. Theory</h2>
<p >Beer's law describes the probability that a collimated bean of radiation propagating through a homogeneous medium of particulates is intercepted. For a canopy of leaves, Beer's law can be written as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\dfrac{R}{R_0}=\left[1-\mathrm{exp}\left(-\dfrac{G\,LAI}{\mathrm{cos}\,\theta_s}\right)\right],\]" src="form_0.png" width="195" height="38"/>
</p>
<p >where <img class="formulaInl" alt="$R$" src="form_1.png" width="12" height="12"/> is the average radiation flux absorbed by the canopy, <img class="formulaInl" alt="$R_0$" src="form_2.png" width="17" height="15"/> is the above-canopy radiation flux on a horizontal surface, <img class="formulaInl" alt="$R/R_0$" src="form_3.png" width="36" height="17"/> is the fraction of absorbed radiation, <img class="formulaInl" alt="$G$" src="form_4.png" width="12" height="12"/> is the fraction of leaf area projected in the direction of the sun, <img class="formulaInl" alt="$LAI$" src="form_5.png" width="29" height="12"/> is the one-sided canopy leaf area per unit ground area, and <img class="formulaInl" alt="$\theta_s$" src="form_6.png" width="12" height="15"/> is the solar zenith angle. The following are the assumptions used to derive this equation: 1) the leaf dimension is "much" smaller than the depth of the canopy layer, 2) the leaf angle distribution is azimuthally isotropic, 3) leaf position is spatially uniform, 4) the canopy extends infinitely in the lateral directions, 5) solar radiation is collimated (i.e., beams are parallel), and 6) leaves absorb all incident radiation.</p>
<p >Operating under similar assumptions, Beer's law can be integrated to determine the fraction of sunlit leaf area</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[f_{sun}=\dfrac{\mathrm{cos}\,\theta_s}{G\,LAI}\left[1-\mathrm{exp}\left(-\dfrac{G\,LAI}{\mathrm{cos}\,\theta_s}\right)\right].\]" src="form_7.png" width="251" height="38"/>
</p>
<h2><a class="anchor" id="tutorial11_geom"></a>
1. Model geometry creation</h2>
<p >We will use the <a class="el" href="_canopy_generator_doc.html">Canopy Generator</a> plug-in to create a canopy that matches the assumptions inherent in Beer's law described above. This will be a homogeneous canopy with azimuthally isotropic leaf angle distribution that extends infinitely in the horizontal (via applying periodic boundary conditions).</p>
<p >We start by defining a few variables that will be used later, including parameters specifying the canopy geometry. We'll use a spherical leaf angle distribution, although others are available (also uniform, planophile, erectophile, plagiophile, extremophile). The canopy has an LAI of 1.5 and a height of 1 m. The canopy extends 3x3 m<sup>2</sup> in the horizontal (but will be infinitely extended through periodic boundaries).</p>
<p >The Context is declared in the usual way. The <a class="el" href="class_canopy_generator.html">CanopyGenerator</a> class is then declared and initialized by passing a pointer to the Context. It's job is to add canopy geometry to the Context. The CanopyGenerator::HomogeneousCanopyParameters structure is declared, which is what is used to set the canopy variables. The leaf_angle_distribution, canopy_extent, canopy_height, and leaf_area_index are straight-forward and set based on the variables we declared above (reference the <a class="el" href="_canopy_generator_doc.html#CGenHomogeneous">canopy generator documentation</a> for the list and meaning of all possible variables).</p>
<p >The variables "buffer" and "leaf_subdivisions" are both important and less intuitive. We don't want the canopy to extend further than the horizontal extent we've specified (or the ground). This can be dealt with in two ways. One is to add a "buffer" of a half leaf width from the canopy boundaries such that no leaves lie on the boundaries. This is not ideal because it will result in a canopy that is not perfectly periodic. Alternatively, we could add no buffer and crop the canopy exactly to the canopy boundaries, which is what we'll do below. In that case, specify the buffer as "none".</p>
<p >The "leaf_subdivisions" variable specifies how many sub-patches (rectangles) should be used to represent each leaf. This does not matter much for computing total canopy absorbed radiation, but it is important to have adequate leaf sub-patch resolution to accurately compute the fraction of sunlit leaf area since we need to resolve shadows on leaves. See the references <a href="https://doi.org/10.1029/2020JG005796">Kent and Bailey (2021)</a> and <a href="https://doi.org/10.1093/insilicoplants/diab023">Bailey and Kent (2021)</a> for a detailed investigation. We'll use 5x5=25 sub-patches as a compromise.</p>
<p >The canopy is built using the <a class="el" href="class_canopy_generator.html#a1c7efa40c83c82ec081a7723c9c9ed98">CanopyGenerator::buildCanopy()</a> function, which takes the parameter structure we created earlier. UUIDs of leaf primitives in the canopy can be queried using the <a class="el" href="class_canopy_generator.html#a73680976a2826f0b5dbf567551fd5593">CanopyGenerator::getLeafUUIDs()</a> function, which we'll store for use in the next step.</p>
<h2><a class="anchor" id="tutorial11_slice"></a>
2. Slicing and cropping primitives on the boundaries</h2>
<p >As introduced above, we have not applied a "buffer" at the canopy boundaries, and thus we have some primitives that extend beyond the intended boundaries. We'll use the <a class="el" href="_voxel_intersection_doc.html">Voxel Intersection</a> plug-in to crop leaves to the exact location of the boundary, and then use the <a class="el" href="classhelios_1_1_context.html#a73036d2c81202f14545393cc0403f46f">helios::Context::cropDomain()</a> function to remove remaining leaf segments beyond the boundaries.</p>
<p >The <a class="el" href="class_voxel_intersection.html">VoxelIntersection</a> class is declared and initialized in a similar way as other plug-ins by passing a pointer to the Context. It's job will be to slice any primitives lying on the canopy boundaries, which creates two or more triangle primitives with a break along the slicing plane. Two variables are defined that give the (x,y,z) coordinates of the canopy center location and the width of the canopy in the x-, y-, and z-directions:</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> vec3 slice_box_center(0,0,0.5f*canopy_height);
 vec3 slice_box_size(canopy_extent.x,canopy_extent.y,canopy_height);</code></pre></div><p >By default, the canopy is centered at the location (0, 0, 0.5*canopy_height), and as we specified before the dimensions of the canopy are (canopy_extent.x, canopy_extent.y, canopy_height).</p>
<p >The slicing is performed using the function <a class="el" href="class_voxel_intersection.html#a03d0dcdbf67ada3ba0d99b0e3754ef61">VoxelIntersection::slicePrimitivesUsingGrid()</a>. This function has the potential to slice based on a sub-divided voxelized grid, but since we only want to slice on the boundaries we'll specify the grid subdivisions as (1, 1, 1) (i.e., not subdivided).</p>
<p >The <a class="el" href="classhelios_1_1_context.html#a73036d2c81202f14545393cc0403f46f">helios::Context::cropDomain()</a> function is then used to crop the domain to the canopy boundaries, which will remove leaf segments outside of the specified boundaries. Some of the primitives the Canopy Generator created may no longer exist if the were sliced and/or cropped, and thus the "UUIDs_leaves" contains UUIDs referencing primitives that no longer exist. We can use the <a class="el" href="classhelios_1_1_context.html#a98516632daccf958cca6b5b6582310bb" title="Get all primitive UUIDs currently in the Context.">helios::Context::getAllUUIDs()</a> function to get all the UUIDs currently in the Context, which at this point only contains leaves.</p>
<p >Finally, we add a ground surface using the <a class="el" href="group__compoundobjects.html#gae15ba3f5741d27c52c43a35eec6c866b" title="Add a patch that is subdivided into a regular grid of sub-patches (tiled)">helios::Context::addTile()</a> function. For this particular tutorial, a ground is not explicitly needed because we have no diffuse/scattered radiation that could emanate from below.</p>
<h2><a class="anchor" id="tutorial11_rad"></a>
3. Radiation model set-up</h2>
<p >The set-up of the radiation model is very similar to the <a class="el" href="radiation_basics.html">previous tutorial</a>, except for two main differences: 1) we add a collimated radiation source rather than a "sun sphere" to match the assumptions of Beer's law, 2) the solar flux is set to a normalize value of 1.0 since we only compute absorption fractions. A variable defining the sun direction was defined at the beginning of the main() function, which is used to set the direction of the collimated source. It is important to note that the solar flux value of 1.0 that we set for the source is the flux perpendicular to the sun direction, and needs to be multiplied by the cosine of the solar zenith angle to get the flux on a horizontal surface.</p>
<h2><a class="anchor" id="tutorial11_run"></a>
4. Run model and process results</h2>
<p >Radiation model calculations are performed when the <a class="el" href="class_radiation_model.html#a7d803f2b67bc4d0d89b2dc98a58d9ff1">RadiationModel::runBand()</a> function is called.</p>
<h3><a class="anchor" id="tutorial11_G"></a>
4a. Calculate G(theta)</h3>
<p >In order to apply Beer's law, we need to calculate the G-function (fraction of leaf area projected in the direction of the sun). In this example, we used a spherical leaf angle distribution, in which case G = 0.5 regardless of sun direction. However, if a different leaf angle distribution was used, G would vary with sun angle. Either way, it is a good exercise to calculate this important parameter.</p>
<p >The G-function is simply the average dot product (absolute value) between the leaf normal and the sun direction. In this example, each leaf element has the same area, but in general this may not be the case, and the average should be area-weighted to avoid biasing toward small primitives. Functions are available to perform each of the necessary operations: a) the <a class="el" href="classhelios_1_1_context.html#abfeadf8e6a35eb97da1439abc21c434e">helios::Context::getPrimitiveNormal()</a> function returns a unit vector pointing in the direction of the primitive normal, b) the <a class="el" href="classhelios_1_1_context.html#a1dafe58b3251d2ef9d09112258b2e85d">helios::Context::getPrimitiveArea()</a> function returns the primitive surface area, and c) the '*' operator when applied to two vec3's will calculate the dot product.</p>
<p >Calculation of the G-function based on the 3D geometry can be written as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[G = \sum\limits_i |\vec{n}_i \cdot \vec{n}_s |A_i/\sum\limits_i A_i,\]" src="form_8.png" width="176" height="33"/>
</p>
<p >where <img class="formulaInl" alt="$\vec{n}_i$" src="form_9.png" width="15" height="15"/> is the normal of the i<sup>th</sup> leaf primitive (unit length), <img class="formulaInl" alt="$\vec{n}_s$" src="form_10.png" width="15" height="15"/> is a unit vector pointing in the direction of the sun, and <img class="formulaInl" alt="$A_i$" src="form_11.png" width="17" height="15"/> is the area of the i<sup>th</sup> leaf primitive.</p>
<h3><a class="anchor" id="tutorial11_abs"></a>
4b. Calculate radiation flux absorbed by the canopy on a ground area basis</h3>
<p >Beer's law gives the radiation flux absorbed by the canopy on a ground area basis, so we will need to calculate this flux based on the 3D model result. It is important to note that the 3D model gives fluxes on a leaf area basis, which can be converted to ground area basis by multiplying the LAI.</p>
<p >The flux absorbed by the canopy <img class="formulaInl" alt="$R$" src="form_1.png" width="12" height="12"/> is simply the area-weighted average leaf PAR flux multiplied by the LAI, which can be written as</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[R = LAI\sum\limits_i R_i A_i / \sum\limits_i A_i,\]" src="form_12.png" width="173" height="33"/>
</p>
<p >where <img class="formulaInl" alt="$R_i$" src="form_13.png" width="15" height="15"/> is the absorbed PAR flux of the i<sup>th</sup> leaf primitive. The <a class="el" href="classhelios_1_1_context.html#acbc8e2f6b09248ef0e1b4039ae49dc3f">helios::Context::calculatePrimitiveDataAreaWeightedMean()</a> function can be used to easily calculate the area-weighted average of the primitive data "radiation_flux_PAR".</p>
<h3><a class="anchor" id="tutorial11_absBeer"></a>
4c. Calculate the theoretical absorbed PAR flux using Beer's law</h3>
<p >The theoretical absorbed PAR flux can be calculated by substituting appropriate values into the equation for Beer's law given above. One important thing to remember is that the radiation flux specified in Helios is the flux on the surface perpendicular to the sun direction, whereas the source flux specified in Beer's law is the flux on a horizontal surface. Thus, the source flux specified in Helios needs to be multiplied by <img class="formulaInl" alt="$\mathrm{cos}\,\theta_s$" src="form_14.png" width="36" height="15"/> to get the flux on a horizontal surface. The <a class="el" href="group__functions.html#ga32a34b00e0a28f4b35e501b8b34cfccd">helios::cart2sphere()</a> function is used to convert our Cartesian vector specifying the sun direction into a spherical coordinate, from which we can get the zenith angle.</p>
<h3><a class="anchor" id="tutorial11_fsun"></a>
4d. Calculate the sunlit leaf area fraction from the simulation</h3>
<p >In order to calculate the fraction of sunlit leaf area for the canopy, we need to determine whether each leaf element is sunlit or shaded. This is tricky because 1) the fully sunlit PAR flux for a given leaf depends on its angle relative to the sun, and 2) many leaves will neither be 100% sunlit or 100% shaded, but somewhere in between. To deal with the first issue, we first calculate what the fully sunlit flux should be for each leaf based on its angle, which is</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[R_{sun} = R_{source}|\vec{n} \cdot \vec{n}_s|,\]" src="form_15.png" width="147" height="17"/>
</p>
<p >where <img class="formulaInl" alt="$R_{source}$" src="form_16.png" width="47" height="15"/> is the PAR flux on a plane perpendicular to the sun, and other symbols are as defined above. We then define a "sunlit" leaf as a leaf whose actual absorbed flux is greater than 50% of <img class="formulaInl" alt="$R_{sun}$" src="form_17.png" width="32" height="15"/>. We then identify which leaves are "sunlit" according to this definition, and sum their areas. The fraction of sunlit leaf area is then the area of sunlit leaves divided by the total leaf area.</p>
<h3><a class="anchor" id="tutorial11_fsunBeer"></a>
4e. Calculate the theoretical sunlit area fraction</h3>
<p >Calculation of the theoretical fraction of sunlit leaf area is simply a matter of plugging values into the equation for <img class="formulaInl" alt="$f_{sun}$" src="form_18.png" width="27" height="15"/> above.</p>
<div style="padding:0.5px;background-color:#D0D0D0 ;line-height:1.2;"> <pre><code> #include "RadiationModel.h"
 #include "CanopyGenerator.h"
 #include "VoxelIntersection.h"

 using namespace helios; //note that we are using the helios namespace so we can omit 'helios::' before names

 int main(){

    <code></code>// !!!!!!!!! Inputs for this example study !!!!!!!!! //

    vec3 sun_direction(1,0,1);                              //Cartesian unit vector pointing in the direction of (toward) the sun
    sun_direction.normalize();

    std::string leaf_angle_dist = "spherical";              //name of leaf angle distribution for the canopy - (spherical, uniform, planophile, erectophile, plagiophile, extremophile)

    float LAI = 1.5f;                                       //one-sided leaf area index of the canopy

    vec2 canopy_extent(3,3);                                //dimension of the canopy in the x- and y-directions (horizontal)
    float canopy_height = 1.f;                              //vertical dimension of the canopy

    <code></code>// *** 1. Model geometry creation *** //

    Context context;                                        //declare the Context class

    CanopyGenerator cgen(&amp;context);                        //declare the Canopy Generator class and pass it the Context so it can add geometry

    HomogeneousCanopyParameters params;                    //structure containing parameters for homogeneous canopy
    params.buffer = "none";                                 //no buffer on the canopy edges - we will slice along border
    params.leaf_angle_distribution = leaf_angle_dist;       //set the leaf angle distribution based on the variable we set above
    params.canopy_extent = canopy_extent;                   //set the lateral canopy extent based on the variable we set above
    params.canopy_height = canopy_height;                   //set the canopy height based on the variable we set above
    params.leaf_area_index = LAI;                           //set the canopy LAI based on the variable we set above

    params.leaf_subdivisions = make_int2(5,5);              //set the number of subdivisions per leaf to be 5x5=25 primitives

    cgen.buildCanopy(params);                               //build the homogeneous canopy

    std::vector&lt;uint&gt; UUIDs_leaves = cgen.getLeafUUIDs();   //get UUIDs for all leaves in the canopy

    <code></code>// *** 2. Slicing and cropping primitives on the boundaries *** //

    <code></code>// slice and primitives that lie on the canopy boundaries (imagine taking a knife and perfectly cutting along the edges of the canopy)
    VoxelIntersection vslice(&amp;context);

    <code></code>// define variables that give the center (x,y,z) coordinate of the canopy and the overall canopy dimensions
    vec3 slice_box_center(0,0,0.5f*canopy_height);
    vec3 slice_box_size(canopy_extent.x,canopy_extent.y,canopy_height);

    <code></code>// do the slicing
    vslice.slicePrimitivesUsingGrid( UUIDs_leaves, slice_box_center, slice_box_size, make_int3(1,1,1) );

    <code></code>// delete any leaf slices that fall outside of the slicing volume
    context.cropDomain( make_vec2(-0.5f*canopy_extent.x,0.5f*canopy_extent.x), make_vec2(-0.5f*canopy_extent.y,0.5f*canopy_extent.y), make_vec2(0,canopy_height) );

    <code></code>// our UUID vector now contains some primitives that have been deleted. We can just get all the primitives currently in the Context and store them in a vector
    UUIDs_leaves = context.getAllUUIDs();

    <code></code>//make a ground
    std::vector&lt;uint&gt; UUIDs_ground = context.addTile(make_vec3(0, 0, 0), canopy_extent, nullrotation,make_int2(10, 10));

    <code></code>// *** 3. Radiation model set-up *** //

    RadiationModel radiation(&amp;context);                      //declare and initialize the radiation model class

    <code></code>// add a sun source. We'll assume collimated radiation since that is what is assumed in Beer's law
    uint sourceID = radiation.addCollimatedRadiationSource( sun_direction );

    <code></code>// set up the PAR band. We'll use separate direct and diffuse bands to keep them separate for post-processing (normally you would combine them)
    radiation.addRadiationBand("PAR");
    radiation.disableEmission("PAR");
    radiation.setSourceFlux(sourceID, "PAR", 1.f);  //set a flux of 1.0 W/m^2 to simplify calculations
    radiation.setDiffuseRadiationFlux("PAR", 0.f);      //no diffuse radiation this band

    radiation.enforcePeriodicBoundary("xy");      //use periodic boundary conditions in the horizontal to simulate an infinite canopy

    context.setPrimitiveData(UUIDs_ground, "twosided_flag",uint(0)); //only want ground to intercept/emit radiation from the top

    radiation.updateGeometry();                            //update the geometry in the radiation model

    <code></code>// 4. Run model and process results //

    <code></code>//Run the radiation model calculations
    radiation.runBand("PAR");

    <code></code>// 4a. Calculate G(theta)
    float Gtheta = 0;
    float area_total = 0;
    for( auto UUID : UUIDs_leaves ){
      vec3 normal = context.getPrimitiveNormal(UUID);
      float area = context.getPrimitiveArea(UUID);
      Gtheta += std::abs( sun_direction*normal )*area;
      area_total += area;
    }
    Gtheta = Gtheta/area_total;  //normalize

    std::cout &lt;&lt; "G(theta) = " &lt;&lt; Gtheta &lt;&lt; std::endl;

    <code></code>// 4b. Calculate radiation flux absorbed by the canopy on a ground area basis - this will end up just being the area-weighted average PAR flux multiplied by LAI.

    float PAR_abs_dir;
    context.calculatePrimitiveDataAreaWeightedMean( UUIDs_leaves, "radiation_flux_PAR", PAR_abs_dir ); //recall that the output primitive data from the radiation model has the form "radiation_flux_[*band_name*]"
    PAR_abs_dir = PAR_abs_dir*LAI; //converts between leaf area basis to ground area basis

    <code></code>// 4c. Calculate the theoretical absorbed PAR flux using Beer's law

    float theta_s = cart2sphere(sun_direction).zenith;  //calculate the solar zenith angle

    float R0 = cos(theta_s); //PAR flux on horizontal surface
    float intercepted_theoretical_direct = R0*(1.f-exp(-Gtheta*LAI/cos(theta_s)));  //Beer's law

    std::cout &lt;&lt; "Calculated interception: " &lt;&lt; PAR_abs_dir &lt;&lt; std::endl;
    std::cout &lt;&lt; "Theoretical interception: " &lt;&lt; intercepted_theoretical_direct &lt;&lt; std::endl;
    std::cout &lt;&lt; "Error of interception: " &lt;&lt; std::abs(PAR_abs_dir-intercepted_theoretical_direct)/intercepted_theoretical_direct*100.f &lt;&lt; " %" &lt;&lt; std::endl;

    <code></code>// 4d. Calculate the sunlit leaf area fraction from the simulation

    float sunlit_area = 0;
    float total_area = 0;
    for( auto UUID : UUIDs_leaves ){ //looping over all leaf elements

      vec3 normal = context.getPrimitiveNormal(UUID);

      float PARmax = std::abs( normal*sun_direction );  //this is the PAR flux of a leaf with the same normal that is fully sunlit

      float PAR;
      context.getPrimitiveData( UUID, "radiation_flux_PAR", PAR ); //get this leaf's PAR flux

      float fsun_leaf = PAR/PARmax;  //PAR flux as a fraction of the fully sunlit flux

      float area = context.getPrimitiveArea(UUID);

      if( fsun_leaf&gt;0.5 ){ //if fsun is greater than 0.5, we'll call this leaf "sunlit"
        sunlit_area += area;
      }
      total_area += area;

    }

    float fsun = sunlit_area/total_area;

    <code></code>// 4e. Calculate the theoretical sunlit area fraction

    float fsun_theoretical = cos(theta_s)/(Gtheta*LAI)*(1-exp(-Gtheta*LAI/cos(theta_s)));

    std::cout &lt;&lt; "Calculated sunlit fraction: " &lt;&lt; fsun &lt;&lt; std::endl;
    std::cout &lt;&lt; "Theoretical sunlit fraction: " &lt;&lt; fsun_theoretical &lt;&lt; std::endl;
    std::cout &lt;&lt; "Error of sunlit fraction: " &lt;&lt; std::abs(fsun-fsun_theoretical)/fsun_theoretical*100.f &lt;&lt; " %" &lt;&lt; std::endl;

    return 0;

 }</code></pre></div> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
