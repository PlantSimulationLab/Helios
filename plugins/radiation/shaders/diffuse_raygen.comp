#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_shader_atomic_float : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_KHR_shader_subgroup_basic : enable

// Diffuse ray generation shader
// Launches rays from surfaces in hemispherical directions for diffuse radiation transfer

// Workgroup size: 8×32×1 = 256 threads
layout(local_size_x = 8, local_size_y = 32, local_size_z = 1) in;

// Push constants (launch parameters)
layout(push_constant) uniform PushConstants {
    uint launch_offset;
    uint launch_count;
    uint rays_per_primitive;
    uint random_seed;
    uint band_count;
    uint source_count;
    uint primitive_count;
    uint launch_face;      // 0 = bottom face, 1 = top face
    uint launch_dim_x;     // Grid dimension X for stratified hemisphere sampling
    uint launch_dim_y;     // Grid dimension Y for stratified hemisphere sampling
    uint material_band_count;  // Global band count (for material buffers)
    uint periodic_flag_x;      // 1 if periodic in X direction
    uint periodic_flag_y;      // 1 if periodic in Y direction
    uint bbox_count;           // Number of bbox faces (0-4)
    float domain_xmin;         // Domain bounds for periodic wrapping
    float domain_xmax;
    float domain_ymin;
    float domain_ymax;
} pc;

// ========== Descriptor Set 0: Geometry ==========
layout(set = 0, binding = 0) readonly buffer BVHBuffer {
    float data[]; // BVHNode array (accessed via bvh_traversal.glsl)
} bvh_buf;

layout(set = 0, binding = 1) readonly buffer PrimIndicesBuffer {
    uint indices[];
} prim_indices_buf;

layout(set = 0, binding = 2) readonly buffer TransformMatricesBuffer {
    float matrices[]; // 16 floats per primitive (row-major)
} transform_buf;

layout(set = 0, binding = 3) readonly buffer PrimTypesBuffer {
    uint types[];
} prim_types_buf;

layout(set = 0, binding = 4) readonly buffer PrimUUIDsBuffer {
    uint uuids[];
} prim_uuids_buf;

layout(set = 0, binding = 5) readonly buffer PrimPositionsBuffer {
    uint positions[];
} prim_positions_buf;

layout(set = 0, binding = 6) readonly buffer ObjectSubdivisionsBuffer {
    ivec2 subdivisions[];
} obj_subdivisions_buf;

layout(set = 0, binding = 7) readonly buffer TwosidedFlagBuffer {
    uint twosided_flags[];
} twosided_buf;

layout(set = 0, binding = 8) readonly buffer PatchVerticesBuffer {
    float vertices[]; // 12 floats per patch (4 vec3 vertices)
} patch_vertices_buf;

layout(set = 0, binding = 9) readonly buffer TriangleVerticesBuffer {
    float vertices[]; // 9 floats per triangle (3 vec3 vertices)
} triangle_vertices_buf;

layout(set = 0, binding = 10) readonly buffer NormalsBuffer {
    float normals[]; // 3 floats per primitive (pre-computed world-space normal)
} normals_buf;

// ---- Texture masking buffers ----
layout(set = 0, binding = 11) readonly buffer MaskDataBuffer { uint mask_data[]; } mask_data_buf;
layout(set = 0, binding = 12) readonly buffer MaskSizesBuffer { ivec2 mask_sizes[]; } mask_sizes_buf;
layout(set = 0, binding = 13) readonly buffer MaskOffsetsBuffer { uint mask_offsets[]; } mask_offsets_buf;
layout(set = 0, binding = 14) readonly buffer MaskIDsBuffer { int mask_ids[]; } mask_ids_buf;
layout(set = 0, binding = 15) readonly buffer UVDataBuffer { vec2 uv_data[]; } uv_data_buf;
layout(set = 0, binding = 16) readonly buffer UVIDsBuffer { int uv_ids[]; } uv_ids_buf;

// ---- Periodic boundary bbox vertices ----
layout(set = 0, binding = 17) readonly buffer BboxVerticesBuffer {
    float vertices[]; // 12 floats per face (4 vec3 vertices)
} bbox_verts_buf;

// ========== Descriptor Set 1: Materials/Sources ==========
layout(set = 1, binding = 0) readonly buffer SourcePositionsBuffer {
    vec3 positions[];
} source_positions_buf;

layout(set = 1, binding = 1) readonly buffer SourceTypesBuffer {
    uint types[];
} source_types_buf;

layout(set = 1, binding = 2) readonly buffer SourceRotationsBuffer {
    vec3 rotations[];
} source_rotations_buf;

layout(set = 1, binding = 3) readonly buffer SourceWidthsBuffer {
    vec2 widths[];
} source_widths_buf;

layout(set = 1, binding = 4) readonly buffer SourceFluxesBuffer {
    float fluxes[];
} source_fluxes_buf;

layout(set = 1, binding = 5) readonly buffer ReflectivityBuffer {
    float reflectivity[]; // [primitive * band_count + band]
} reflectivity_buf;

layout(set = 1, binding = 6) readonly buffer TransmissivityBuffer {
    float transmissivity[];
} transmissivity_buf;

layout(set = 1, binding = 10) readonly buffer BandMapBuffer {
    uint map[]; // Maps launch band index → global band index
} band_map_buf;

// ========== Descriptor Set 2: Results ==========
layout(set = 2, binding = 0) buffer RadiationInBuffer {
    float radiation_in[]; // [primitive * band_count + band]
} rad_in_buf;

layout(set = 2, binding = 1) readonly buffer RadiationOutTopBuffer {
    float radiation_out_top[]; // Energy emitted from top face
} rad_out_top_buf;

layout(set = 2, binding = 2) readonly buffer RadiationOutBottomBuffer {
    float radiation_out_bottom[]; // Energy emitted from bottom face
} rad_out_bottom_buf;

layout(set = 2, binding = 3) buffer ScatterTopBuffer {
    float scatter_top[]; // Scattered energy from top face
} scatter_top_buf;

layout(set = 2, binding = 4) buffer ScatterBottomBuffer {
    float scatter_bottom[]; // Scattered energy from bottom face
} scatter_bottom_buf;

// ========== Descriptor Set 3: Sky Parameters ==========
layout(set = 3, binding = 0) readonly buffer DiffuseFluxBuffer {
    float diffuse_flux[]; // [band] - Sky irradiance per band
} diffuse_flux_buf;

layout(set = 3, binding = 1) readonly buffer DiffusePeakDirBuffer {
    vec3 diffuse_peak_dir[]; // [band] - Sun direction per band
} diffuse_peak_dir_buf;

layout(set = 3, binding = 2) readonly buffer DiffuseExtinctionBuffer {
    float diffuse_extinction[]; // [band] - Power-law K parameter
} diffuse_extinction_buf;

layout(set = 3, binding = 3) readonly buffer DiffuseDistNormBuffer {
    float diffuse_dist_norm[]; // [band] - Power-law normalization
} diffuse_dist_norm_buf;

layout(set = 3, binding = 4) readonly buffer SkyRadianceParamsBuffer {
    vec4 sky_radiance_params[]; // [band] - Prague model params (circ_str, circ_width, horiz_bright, norm)
} sky_radiance_params_buf;

// ========== Include common shader utilities ==========
#include "common/random.glsl"
#include "common/transforms.glsl"
#include "common/buffer_indexing.glsl"
#include "common/bvh_traversal.glsl"
#include "common/periodic_boundary.glsl"
#include "common/sky_distribution.glsl"
#include "common/texture_mask.glsl"

// ========== Helper Functions ==========

// Sample random point on patch (matches CUDA)
vec3 sample_patch(inout RNGState rng, ivec2 subdivision, ivec2 sub_cell) {
    int NX = subdivision.x;
    int NY = subdivision.y;

    float dx = 1.0 / float(NX);
    float dy = 1.0 / float(NY);

    float Rx = rng_float(rng);
    float Ry = rng_float(rng);

    // Map to patch local space [-0.5, 0.5] x [-0.5, 0.5]
    vec3 sp;
    sp.x = -0.5 + (sub_cell.x + Rx) * dx;
    sp.y = -0.5 + (sub_cell.y + Ry) * dy;
    sp.z = 0.0;

    return sp;
}

// Sample random point on triangle
vec3 sample_triangle(inout RNGState rng) {
    float Rx = rng_float(rng);
    float Ry = rng_float(rng);

    vec3 sp;
    // Map to triangle with vertices (0,0,0), (0,1,0), (1,1,0)
    if (Rx < Ry) {
        sp.x = Rx;
        sp.y = Ry;
    } else {
        sp.x = Ry;
        sp.y = Rx;
    }
    sp.z = 0.0;

    return sp;
}

// Sample random point on disk (uniform distribution)
vec3 sample_disk(inout RNGState rng) {
    float Rx = rng_float(rng);
    float Ry = rng_float(rng);

    // Map to square [-1,1] x [-1,1]
    vec3 sp;
    sp.x = -1.0 + 2.0 * Rx;
    sp.y = -1.0 + 2.0 * Ry;

    // Concentric disk mapping (Shirley & Chiu 1997)
    float r, phi;
    if (sp.x > -sp.y) {
        if (sp.x > sp.y) {
            r = sp.x;
            phi = sp.y / sp.x;
        } else {
            r = sp.y;
            phi = 2.0 - sp.x / sp.y;
        }
    } else {
        if (sp.x < sp.y) {
            r = -sp.x;
            phi = 4.0 + sp.y / sp.x;
        } else {
            r = -sp.y;
            if (sp.y != 0.0) {
                phi = 6.0 - sp.x / sp.y;
            } else {
                phi = 0.0;
            }
        }
    }
    phi *= 0.25 * 3.14159265359;

    sp.x = r * cos(phi);
    sp.y = r * sin(phi);
    sp.z = 0.0;

    return sp;
}

// Get patch normal in world space
vec3 get_patch_normal(float transform_mat[16]) {
    mat4 transform = floats_to_mat4(transform_mat);

    vec3 v0 = transform_point(transform, vec3(0, 0, 0));
    vec3 v1 = transform_point(transform, vec3(1, 0, 0));
    vec3 v2 = transform_point(transform, vec3(0, 1, 0));

    return normalize(cross(v1 - v0, v2 - v0));
}

// Get triangle normal in world space
vec3 get_triangle_normal(float transform_mat[16]) {
    mat4 transform = floats_to_mat4(transform_mat);

    vec3 v0 = transform_point(transform, vec3(0, 0, 0));
    vec3 v1 = transform_point(transform, vec3(0, 1, 0));
    vec3 v2 = transform_point(transform, vec3(1, 1, 0));

    return normalize(cross(v1 - v0, v2 - v0));
}

// Rotate local hemisphere direction to align with surface normal
// Local frame: Z-up (hemisphere aligned with +Z axis)
// World frame: Arbitrary normal direction
vec3 rotate_to_normal(vec3 dir_local, vec3 normal) {
    // Compute rotation to align Z-axis with normal
    // Using spherical coordinate rotation (matches CUDA d_rotatePoint)

    // Elevation angle (from Z-axis)
    float elevation = acos(clamp(normal.z, -1.0, 1.0));

    // Azimuthal angle (in XY plane)
    float azimuth = atan(normal.y, normal.x);

    // Rotate local direction to world frame
    // First rotate around Y by elevation, then around Z by azimuth
    float ce = cos(elevation);
    float se = sin(elevation);
    float ca = cos(azimuth);
    float sa = sin(azimuth);

    // Rotation matrix: Rz(azimuth) × Ry(elevation)
    vec3 dir_world;
    dir_world.x = dir_local.x * (ce * ca) - dir_local.y * sa + dir_local.z * (se * ca);
    dir_world.y = dir_local.x * (ce * sa) + dir_local.y * ca + dir_local.z * (se * sa);
    dir_world.z = -dir_local.x * se + dir_local.z * ce;

    return normalize(dir_world);
}

// ========== Main Shader ==========
void main() {
    // 3D dispatch: X/Y = ray grid position, Z = primitive index
    uint launch_x = gl_GlobalInvocationID.x;
    uint launch_y = gl_GlobalInvocationID.y;
    uint prim_batch_idx = gl_GlobalInvocationID.z;

    // Bounds check — early return (no barriers to worry about)
    if (launch_x >= pc.launch_dim_x || launch_y >= pc.launch_dim_y ||
        prim_batch_idx >= pc.launch_count) {
        return;
    }

    uint prim_idx = pc.launch_offset + prim_batch_idx;

    if (prim_idx >= pc.primitive_count) {
        return;
    }

    // Get primitive data
    uint prim_type = prim_types_buf.types[prim_idx];
    uint prim_uuid = prim_uuids_buf.uuids[prim_idx];
    ivec2 subdivisions = obj_subdivisions_buf.subdivisions[prim_idx];
    uint twosided = twosided_buf.twosided_flags[prim_idx];

    // Skip if launching from bottom face and twosided_flag = 0 (single-sided, top only)
    if (pc.launch_face == 0 && twosided == 0) {
        return;
    }

    // Total rays per primitive (matches CUDA: dimx = launch_dim.x * launch_dim.y)
    uint dimx = pc.launch_dim_x * pc.launch_dim_y;

    // Per-ray RNG seed (matches CUDA: tea(indx + dimx * launch_index.z, random_seed))
    uint ray_index = pc.launch_dim_x * launch_y + launch_x;
    RNGState rng = rng_init(pc.random_seed, ray_index + dimx * prim_idx);

    // Get transform matrix (16 floats per primitive)
    float transform_mat[16];
    for (uint i = 0; i < 16; ++i) {
        transform_mat[i] = transform_buf.matrices[prim_idx * 16 + i];
    }
    mat4 transform = floats_to_mat4(transform_mat);

    // Read pre-computed world-space normal from buffer
    uint nbase = prim_idx * 3;
    vec3 normal = vec3(normals_buf.normals[nbase], normals_buf.normals[nbase + 1], normals_buf.normals[nbase + 2]);

    // Ray strength (equal energy per ray)
    float strength = 1.0 / float(dimx);

    // Loop over sub-patches (matches OptiX: still loops over NX*NY sub-patches per thread)
    int NX = subdivisions.x;
    int NY = subdivisions.y;

    for (int jj = 0; jj < NY; ++jj) {
        for (int ii = 0; ii < NX; ++ii) {
            uint UUID = prim_uuid + jj * NX + ii;

            // Sample random point on primitive surface (per-ray, matching CUDA)
            vec3 sp_local;
            if (prim_type == 0 || prim_type == 3) { // Patch or Tile
                sp_local = sample_patch(rng, subdivisions, ivec2(ii, jj));
            } else if (prim_type == 1) { // Triangle
                sp_local = sample_triangle(rng);
            } else if (prim_type == 2) { // Disk
                sp_local = sample_disk(rng);
            }

            // Origin masking: reject transparent texels (matches OptiX d_sampleTexture_patch, RayTracing.cuh:504)
            if (prim_type == 0 || prim_type == 3) { // Patch or Tile
                int mask_id_check = mask_ids_buf.mask_ids[prim_idx];
                if (mask_id_check >= 0) {
                    vec2 sample_uv = vec2(sp_local.x + 0.5, sp_local.y + 0.5);
                    int resample_count = 0;
                    while (!check_texture_mask(prim_idx, sample_uv, prim_type) && resample_count < 10) {
                        resample_count++;
                        float dx = 1.0 / float(NX);
                        float dy = 1.0 / float(NY);
                        sp_local.x = -0.5 + (float(ii) + rng_float(rng)) * dx;
                        sp_local.y = -0.5 + (float(jj) + rng_float(rng)) * dy;
                        sp_local.z = 0.0;
                        sample_uv = vec2(sp_local.x + 0.5, sp_local.y + 0.5);
                    }
                    if (!check_texture_mask(prim_idx, sample_uv, prim_type)) {
                        continue; // Skip ray after 10 failed retries
                    }
                }
            } else if (prim_type == 1 && mask_ids_buf.mask_ids[prim_idx] >= 0) {
                // Triangle origin masking via rejection sampling
                vec2 uv0 = uv_data_buf.uv_data[prim_idx * 4 + 0];
                vec2 uv1 = uv_data_buf.uv_data[prim_idx * 4 + 1];
                vec2 uv2 = uv_data_buf.uv_data[prim_idx * 4 + 2];
                bool masked = true;
                for (int attempt = 0; attempt < 50 && masked; attempt++) {
                    // Generate random point on canonical triangle
                    float r1 = rng_float(rng);
                    float r2 = rng_float(rng);
                    if (r1 + r2 > 1.0) { r1 = 1.0 - r1; r2 = 1.0 - r2; }
                    sp_local = vec3(r2, r1 + r2, 0.0); // canonical: x=gamma, y=beta+gamma
                    float beta = r1;  // sp_local.y - sp_local.x
                    float gamma = r2; // sp_local.x
                    vec2 tex_uv = uv0 + beta * (uv1 - uv0) + gamma * (uv2 - uv0);
                    tex_uv.y = 1.0 - tex_uv.y;
                    int mask_id = mask_ids_buf.mask_ids[prim_idx];
                    ivec2 sz = mask_sizes_buf.mask_sizes[mask_id];
                    uint offset = mask_offsets_buf.mask_offsets[mask_id];
                    int tx = clamp(int(floor(float(sz.x - 1) * tex_uv.x)), 0, sz.x - 1);
                    int ty = clamp(int(floor(float(sz.y - 1) * tex_uv.y)), 0, sz.y - 1);
                    masked = (mask_data_buf.mask_data[offset + ty * sz.x + tx] == 0);
                }
                if (masked) {
                    continue; // Skip this ray - all 50 attempts hit transparent texels
                }
            }

            // Transform to world space
            vec3 ray_origin = transform_point(transform, sp_local);

            // Stratified random samples [0,1] within grid cell
            float Rt = (float(launch_x) + rng_float(rng)) / float(pc.launch_dim_x);
            float Rp = (float(launch_y) + rng_float(rng)) / float(pc.launch_dim_y);

            // Cosine-weighted hemisphere sampling
            // Theta in [0, π/2], Phi in [0, 2π]
            float theta = asin(sqrt(Rt));
            float phi = 2.0 * 3.14159265359 * Rp;

            // Cartesian direction in local hemisphere frame (+Z up)
            vec3 dir_local;
            dir_local.x = sin(theta) * cos(phi);
            dir_local.y = sin(theta) * sin(phi);
            dir_local.z = cos(theta);

            // Rotate to align with surface normal
            vec3 ray_direction = rotate_to_normal(dir_local, normal);

            // Flip direction if launching from bottom face
            if (pc.launch_face == 0 && twosided == 1) {
                ray_direction = -ray_direction;
            }

            // Trace ray through BVH with periodic boundary wrap loop
            // If ray hits a bbox face, wrap to opposite side and re-trace (up to 10 wraps)
            float closest_t;
            uint hit_prim_type;
            vec2 hit_uv;
            uint hit_prim_idx;
            vec3 trace_origin = ray_origin;

            for (int wrap = 0; wrap < 10; ++wrap) {
                hit_prim_idx = traverse_cwbvh(
                    trace_origin,
                    ray_direction,
                    1e-5, // t_min (avoid self-intersection)
                    prim_idx, // origin primitive index (skip self-hits)
                    closest_t,
                    hit_prim_type,
                    hit_uv
                );

                if (pc.bbox_count == 0) break; // No periodic boundaries

                vec3 wrapped_origin;
                bool hit_periodic = check_periodic_boundary(
                    trace_origin, ray_direction, closest_t,
                    pc.periodic_flag_x, pc.periodic_flag_y, pc.bbox_count,
                    pc.domain_xmin, pc.domain_xmax, pc.domain_ymin, pc.domain_ymax,
                    wrapped_origin);

                if (!hit_periodic) break; // Real hit or miss
                trace_origin = wrapped_origin;
            }

            // Process hit or miss — loop over all bands (BVH traversal is band-independent)
            bool hit_found = (hit_prim_idx != 0xFFFFFFFF);

            // Read hit surface normal once (shared across bands)
            vec3 hit_normal;
            bool hit_top_face;
            if (hit_found) {
                uint hit_nbase = hit_prim_idx * 3;
                hit_normal = vec3(normals_buf.normals[hit_nbase], normals_buf.normals[hit_nbase + 1], normals_buf.normals[hit_nbase + 2]);
                hit_top_face = dot(hit_normal, ray_direction) < 0.0;
            }

            for (uint band = 0; band < pc.band_count; ++band) {
                uint global_b = band_map_buf.map[band];
                uint global_idx = index_prim_band(prim_idx, band, pc.band_count);
                uint mat_idx = prim_idx * pc.material_band_count + global_b;
                float rho = reflectivity_buf.reflectivity[mat_idx];
                float tau = transmissivity_buf.transmissivity[mat_idx];

                // Compute energy contributions unconditionally (zero for inactive path).
                // subgroupAdd must be called by all active threads in the subgroup at the same
                // point — calling it inside divergent if/else branches is undefined per spec.
                float absorption_val = 0.0;
                float scatter_top_val = 0.0;
                float scatter_bottom_val = 0.0;

                if (hit_found) {
                    // ========== HIT: Ray intersected another surface ==========
                    uint hit_rad_idx = index_prim_band(hit_prim_idx, band, pc.band_count);

                    float incoming;
                    if (hit_top_face) {
                        incoming = rad_out_top_buf.radiation_out_top[hit_rad_idx];
                    } else {
                        incoming = rad_out_bottom_buf.radiation_out_bottom[hit_rad_idx];
                    }

                    float hit_energy = incoming * strength;
                    absorption_val = hit_energy * (1.0 - rho - tau);

                    float reflect_energy = hit_energy * rho;
                    float transmit_energy = hit_energy * tau;
                    if (pc.launch_face == 1) {
                        scatter_top_val    = reflect_energy;
                        scatter_bottom_val = transmit_energy;
                    } else {
                        scatter_bottom_val = reflect_energy;
                        scatter_top_val    = transmit_energy;
                    }

                } else {
                    // ========== MISS: Ray hit sky ==========
                    float diffuse_flux = diffuse_flux_buf.diffuse_flux[band];

                    if (diffuse_flux > 0.0) {
                        vec3 peak_dir = diffuse_peak_dir_buf.diffuse_peak_dir[band];
                        float extinction = diffuse_extinction_buf.diffuse_extinction[band];
                        float dist_norm = diffuse_dist_norm_buf.diffuse_dist_norm[band];
                        vec4 sky_params = sky_radiance_params_buf.sky_radiance_params[band];

                        float fd = evaluate_sky_distribution(ray_direction, peak_dir, extinction, dist_norm, sky_params);
                        float sky_energy = fd * diffuse_flux * strength;

                        absorption_val = sky_energy * (1.0 - rho - tau);

                        float sky_reflect  = sky_energy * rho;
                        float sky_transmit = sky_energy * tau;
                        if (pc.launch_face == 1) {
                            scatter_top_val    = sky_reflect;
                            scatter_bottom_val = sky_transmit;
                        } else {
                            scatter_bottom_val = sky_reflect;
                            scatter_top_val    = sky_transmit;
                        }
                    }
                }

                // Subgroup reductions called uniformly by all threads (inactive paths contribute 0)
                float absorption_sum    = subgroupAdd(absorption_val);
                float scatter_top_sum   = subgroupAdd(scatter_top_val);
                float scatter_bottom_sum = subgroupAdd(scatter_bottom_val);
                if (subgroupElect()) {
                    if (absorption_sum != 0.0)
                        atomicAdd(rad_in_buf.radiation_in[global_idx], absorption_sum);
                    if (scatter_top_sum != 0.0)
                        atomicAdd(scatter_top_buf.scatter_top[global_idx], scatter_top_sum);
                    if (scatter_bottom_sum != 0.0)
                        atomicAdd(scatter_bottom_buf.scatter_bottom[global_idx], scatter_bottom_sum);
                }
            } // band loop
        } // ii loop (sub-patches)
    } // jj loop (sub-patches)
}
